<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 一条MySQL更新语句的执行过程是什么样的 · 代码 | 自由</title><meta name="description" content="一条MySQL更新语句的执行过程是什么样的 - Jeffrey"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.tenpercent.top/atom.xml" title="代码 | 自由"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon-logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about-me.html" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">一条MySQL更新语句的执行过程是什么样的</h1><div class="post-info">Sep 12, 2019</div><div class="post-content"><h2 id="一条MySQL更新语句的执行过程是什么样的"><a href="#一条MySQL更新语句的执行过程是什么样的" class="headerlink" title="一条MySQL更新语句的执行过程是什么样的"></a>一条MySQL更新语句的执行过程是什么样的</h2><h3 id="1-连接验证及解析"><a href="#1-连接验证及解析" class="headerlink" title="1.连接验证及解析"></a>1.连接验证及解析</h3><p>客户端与MySQL Server建立连接，发送语句给MySQL Server，接收到后如果是查询语句会先去查询缓存中看，有的话就直接返回了，（新版本的MySQL已经废除了查询缓存，命中率太低了），如果是缓存没有或者是非查询语句，会创建一个解析树，然后进行优化，（解析器知道语句是要执行什么，会评估使用各种索引的代价，然后去使用索引，以及调节表的连接顺序）然后调用innodb引擎的接口来执行语句。</p>
<h2 id="2-写undo-log"><a href="#2-写undo-log" class="headerlink" title="2.写undo log"></a>2.写undo log</h2><p>innodb 引擎首先开启事务，获得一个事务ID(是一直递增的)，根据执行的语句生成一个反向的语句，(如果是INSERT会生成一条DELETE语句，如果UPDATE语句就会生成一个UPDATE成旧数据的语句)，用于提交失败后回滚，将这条反向语句写入undo log，得到回滚指针，并且更新这个数据行的回滚指针和事务id。（事务提交后，Undo log并不能立马被删除，而是放入待清理的链表，由purge 线程判断是否有其他事务在使用undo 段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间，简单的说就是看之前的事务是否提交成功，这个事务及之前的事务都提交成功了，这部分undo log才能删除。）</p>
<h3 id="3-从索引中查找数据"><a href="#3-从索引中查找数据" class="headerlink" title="3.从索引中查找数据"></a>3.从索引中查找数据</h3><p>根据索引去B+树中找到这一行数据（如果是普通索引，查到不符合条件的索引，会把所有数据查找出来，唯一性索引查到第一个数据就可以了）</p>
<h3 id="4-更新数据"><a href="#4-更新数据" class="headerlink" title="4.更新数据"></a>4.更新数据</h3><p>判断数据页是否在内存中？</p>
<h3 id="4-1数据页在内存中"><a href="#4-1数据页在内存中" class="headerlink" title="4.1数据页在内存中"></a>4.1数据页在内存中</h3><p>索引是普通索引还是唯一性索引？</p>
<h4 id="4-1-1普通索引"><a href="#4-1-1普通索引" class="headerlink" title="4.1.1普通索引"></a>4.1.1普通索引</h4><p>直接更新内存中的数据页</p>
<h4 id="4-1-2唯一性索引"><a href="#4-1-2唯一性索引" class="headerlink" title="4.1.2唯一性索引"></a>4.1.2唯一性索引</h4><p>判断更新后是否会数据冲突(不能破坏索引的唯一性)，不会的话就更新内存中的数据页。</p>
<h3 id="4-2-数据页不在内存中"><a href="#4-2-数据页不在内存中" class="headerlink" title="4.2 数据页不在内存中"></a>4.2 数据页不在内存中</h3><p>索引是普通索引还是唯一性索引？</p>
<h4 id="4-2-1普通索引"><a href="#4-2-1普通索引" class="headerlink" title="4.2.1普通索引"></a>4.2.1普通索引</h4><p>将对数据页的更新操作记录到change buffer，暂时不更新到磁盘。change buffer会在空闲时异步更新到磁盘。</p>
<h4 id="4-2-2-唯一性索引"><a href="#4-2-2-唯一性索引" class="headerlink" title="4.2.2 唯一性索引"></a>4.2.2 唯一性索引</h4><p>因为需要保证更新后的唯一性，所以不能延迟更新，必须把数据页从磁盘加载到内存，然后判断更新后是否会数据冲突，不会的话就更新数据页。</p>
<h3 id="5-写undo-log（prepare状态）"><a href="#5-写undo-log（prepare状态）" class="headerlink" title="5.写undo log（prepare状态）"></a>5.写undo log（prepare状态）</h3><p>将对数据页的更改写入到redo log，将redo log设置为prepare状态。</p>
<h3 id="6-写bin-log（commit状态）"><a href="#6-写bin-log（commit状态）" class="headerlink" title="6.写bin log（commit状态）"></a>6.写bin log（commit状态）</h3><p>通知MySQL server已经更新操作写入到redo log 了，随时可以提交，将执行的SQL写入到bin log日志，将redo log改成commit状态，事务提交成功。</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>主要是保证事务的原子性，事务执行失败就回滚，用于在事务执行失败后，对数据回滚。</p>
<p>是逻辑日志，记录的是SQL语句。</p>
<p>在事务提交后，undo log日志不会立即删除，会放到一个待删除的链表中，有purge线程判断是否有其他事务在使用上一个事务之前的版本信息，然后决定是否可以清理，简单的来说就是前面的事务都提交成功了，这些undo才能删除。</p>
<h4 id="change-buffer是什么？"><a href="#change-buffer是什么？" class="headerlink" title="change buffer是什么？"></a>change buffer是什么？</h4><p>（change buffer就是将更新数据页的操作缓存下来）</p>
<p>在更新数据时，如果数据行所在的数据页在内存中，直接更新内存中的数据页。</p>
<p>如果不在内存中，为了减少磁盘IO的次数，innodb会将这些更新操作缓存在change buffer中，在下一次查询时需要访问这个数据页时，在执行change buffer中的操作对数据页进行更新。（或者是在MySQL Server空闲时，会将change buffer中所有操作更新到磁盘，也就是俗称的‘刷页’。）</p>
<p>适合写多读少的场景，因为这样即便立即写了，也不太可能会被访问到，延迟更新可以减少磁盘I/O，只有普通索引会用到，因为唯一性索引，在更新时就需要判断唯一性，所以没有必要。</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>就是为了保证事务的持久性，在做数据更新操作时，先将对数据页的更改记录到redo log，然后再去更新内存中的数据页，在下次查询数据页或者空闲时间，将操作记录更新到磁盘。这样可以将随机I/O改为顺序I/O。</p>
<p>优点是减少磁盘I/O次数，即便发生故障也可以根据redo log来将数据恢复到最新状态。</p>
<p>缺点是会造成内存脏页，后台线程会自动对脏页刷盘，或者是淘汰数据页时刷盘，此时会暂时查询操作，影响查询。</p>
<h3 id="二段提交制"><a href="#二段提交制" class="headerlink" title="二段提交制"></a>二段提交制</h3><p>更新时，先改内存中的数据页，将更新操作写入redo log日志，此时redo log进入prepare状态，然后通知MySQL Server执行完了，随时可以提交，MySQL Server将更新的SQL写入bin log，然后调用innodb接口将redo log设置为提交状态，更新完成。</p>
<p>如果只是写了bin log就提交，那么忽然发生故障，主节点可以根据redo log恢复数据到最新，但是主从同步时会丢掉这部分更新的数据。</p>
<p>如果只是写binlog，然后写redo log，如果忽然发生故障，主节点根据redo log恢复数据时就会丢掉这部分数据。</p>
<h4 id="崩溃恢复时的判断规则（以redolog是否commit或者binlog是否完整来确定）"><a href="#崩溃恢复时的判断规则（以redolog是否commit或者binlog是否完整来确定）" class="headerlink" title="崩溃恢复时的判断规则（以redolog是否commit或者binlog是否完整来确定）"></a>崩溃恢复时的判断规则（以redolog是否commit或者binlog是否完整来确定）</h4><ol>
<li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；</li>
<li>如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：<br>a. 如果是，则提交事务；<br>b. 否则，回滚事务。</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2019/10/17/mysql-index-1/" class="prev">上一篇</a><a href="/2019/03/26/depth-nginx/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2021 <a href="http://www.tenpercent.top">Jeffrey</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-146782675-1",'auto');ga('send','pageview');</script></body></html>