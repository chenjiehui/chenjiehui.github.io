<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅析 PHP7 的垃圾回收机制 · 代码 & 自由</title><meta name="description" content="浅析 PHP7 的垃圾回收机制 - Jeffrey"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.tenpercent.top/atom.xml" title="代码 &amp; 自由"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon1.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about-me.html" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅析 PHP7 的垃圾回收机制</h1><div class="post-info">Aug 31, 2019</div><div class="post-content"><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>垃圾回收机制是一种动态存储分配方案。它会自动释放程序不再需要的已分配的内存块。 自动回收内存的过程叫垃圾收集。垃圾回收机制可以让程序员不必过分关心程序内存分配，从而将更多的精力投入到业务逻辑。 在现在的流行各种语言当中，垃圾回收机制是新一代语言所共有的特征。</p>
<a id="more"></a>
<h2 id="垃圾的产生"><a href="#垃圾的产生" class="headerlink" title="垃圾的产生"></a>垃圾的产生</h2><p>PHP7 中复杂类型，像字符串、数组、对象等的数据结构中，头部都有一个 gc, 这个 gc 的作用就是用来对垃圾回收的支持。当变量赋值、传递时，会增加 value 的引用数， unset、return 等释放变量时再减掉引用数，减掉后如果发现 refcount 变为 0 则直接释放 value，这是变量的基本回收过程。</p>
<p>不过有一种问题是这个机制无法解决的，就是循环引用的问题。</p>
<p>什么是循环引用呢？ 简单说就是变量的内部里存的 value 又引用了变量自身。 这种比较经常发生在数组和对象类型的变量上。</p>
<p>这里先讲一下引用，即 zend_reference 这个类型，这个是 PHP7 新增的变量类型，当对变量使用 “&amp;” 操作时，会创建新的中间结构体 zend_reference，这个结构体会真正的指向对应的 value 结构。</p>
<p>举个例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当进行如下赋值操作时</span></span><br><span class="line">$a = <span class="string">'hello'</span>; <span class="comment">// $a -&gt; zend_string</span></span><br><span class="line">$b = $a; <span class="comment">// $b,$a -&gt; zend_string</span></span><br><span class="line">$c = &amp;$b; <span class="comment">// $c,$b -&gt; zval(type = IS_REFERENCE, refcount = 2) -&gt; zend_string</span></span><br></pre></td></tr></table></figure>
<p>最终会变成如下这样：</p>
<p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20190901220325.png" alt></p>
<p>即 $b 和 $c 的 zval 是通过中间结构体 zend_reference 再指向最终的 zend_string。</p>
<p>回到循环引用的问题，举个数组循环引用例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$a = [<span class="number">1</span>];</span><br><span class="line">$a[] = &amp;$a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unset</span>($a);</span><br></pre></td></tr></table></figure>
<p>使用 &amp; 操作之后，变量 a 就变成了引用类型且引用计数 refcount 为 2，而又赋值给自己里面的元素，即变量 a 变成了自己引用自己。</p>
<p>具体如下如所示：</p>
<p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20190901220346.png" alt></p>
<p>当 unset 之后就变成下图这样：</p>
<p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20190901220358.png" alt></p>
<p>即 $a 所在的 zval 类型已经变成了 IS_UNDEF 了，zend_reference 结构体的引用计数减 1，但是仍然大于 0，这时候，这部分结构体就变成了垃圾，对此不处理的话，就可能会造成内存泄露。这里就需要垃圾收集器将这部分收集到缓冲区，之后进行回收处理。</p>
<h2 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h2><p>如果当变量的 refcount 减小后大于 0，PHP 并不会立即对这个变量进行垃圾鉴定和回收，而是放入一个缓冲区中，等这个缓冲区满了以后(10000 个值)再统一进行处理，加入缓冲区的是变量 zend_value 里的 gc，目前垃圾只会出现在数组和对象两种类型中，数组的情况上面已经介绍了，对象的情况则是成员属性引用对象本身导致的，其它类型不会出现这种变量中的成员引用变量自身的情况，所以垃圾回收只会处理这两种类型的变量。</p>
<p>gc 的结构 zend_refcounted_h 具体如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_refcounted_h</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>         refcount; <span class="comment">// 记录 zend_value 的引用数</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            zend_uchar    type,  <span class="comment">// zend_value的类型, 与zval.u1.type一致</span></span><br><span class="line">            zend_uchar    flags, </span><br><span class="line">            <span class="keyword">uint16_t</span>      gc_info <span class="comment">// GC信息，记录在 gc 池中的位置和颜色，垃圾回收的过程会用到</span></span><br><span class="line">        &#125; v;</span><br><span class="line">        <span class="keyword">uint32_t</span> type_info;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; zend_refcounted_h;</span><br></pre></td></tr></table></figure>
<p>一个变量只能加入一次缓冲区，为了防止重复加入，变量加入后会把 zend_refcounted_h.gc_info 置为 GC_PURPLE，即标为紫色，后续不会重复插入。</p>
<p>垃圾缓冲区是一个双向链表，等到缓存区满了以后则启动垃圾检查过程：遍历缓冲区，对当前变量的所有成员进行遍历，然后把成员的 refcount 减 1 (如果成员还包含子成员则也进行递归遍历，即深度优先遍历)，最后再检查当前变量的引用，如果减为了 0 则为垃圾。这个算法的原理核心是：垃圾是由于成员引用自身导致的，那么就对所有的成员减一遍引用，如果发现最后变量本身的 refcount 变为了 0 则就表明其引用全部来自自身成员，即其他任何地方都不再使用它，那么它就是垃圾，需要被回收掉。反之说明不是垃圾，需要将其从缓冲区移出去。具体的过程如下：</p>
<p>(1) 从缓冲区链表的 roots 开始遍历，把当前 value 标为灰色 (zend_refcounted_h.gc_info 置为 GC_GREY)，然后对当前 value 的成员进行深度优先遍历，把成员 value 的 refcount 减 1，并且也标为灰色；</p>
<p>(2) 重复遍历缓冲区链表，检查当前 value 引用是否为 0，为 0 则表示确实是垃圾，把它标为白色(GC_WHITE)，如果不为 0 则排除了引用全部来自自身成员的可能，表示还有外部的引用，并不是垃圾，这时候因为步骤(1)对成员进行了 refcount 减 1 操作，需要再还原回去，对所有成员进行深度遍历，把成员 refcount 加 1，同时标为黑色；</p>
<p>(3) 再次遍历缓冲区链表，将非 GC_WHITE 的节点从 roots 链表中移出（移到待释放的列表），最终 roots 链表中全部为真正的垃圾，最后将这些垃圾清除。</p>
<p><em>参考资料</em> </p>
<p>《PHP7 底层设计与源码解析》</p>
<p><a href="https://github.com/pangudashu/php7-internal" target="_blank" rel="noopener">php7-internal</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/08/23/PHP7-Array/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2019 <a href="http://www.tenpercent.top">Jeffrey</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-146782675-1",'auto');ga('send','pageview');</script></body></html>