<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Spring 的 IOC 学习总结 · 代码 | 自由</title><meta name="description" content="Spring 的 IOC 学习总结 - Jeffrey"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.tenpercent.top/atom.xml" title="代码 | 自由"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon-logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about-me.html" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Spring 的 IOC 学习总结</h1><div class="post-info">May 12, 2018</div><div class="post-content"><h2 id="IOC-描述"><a href="#IOC-描述" class="headerlink" title="IOC 描述"></a>IOC 描述</h2><p>IOC —— Inversion of control，即控制反转。还有个别名叫 DI（Dependency inject 依赖注入）。</p>
<ul>
<li>定义</li>
</ul>
<p>所谓 IoC ，就是由 IoC 容器来负责对象的生命周期和对象之间的关系。</p>
<ul>
<li>最初的时候</li>
</ul>
<p>在最早我们使用对象的时候，都是在用到的时候 new 一个，这个会存在一个问题：不灵活。</p>
<p>即当某个类里依赖着某个 new 出来的对象的时候，在后续的使用中，如果需要换个依赖的对象了，需要去修改类里的代码。</p>
<h2 id="IOC-的用处"><a href="#IOC-的用处" class="headerlink" title="IOC 的用处"></a>IOC 的用处</h2><p>用 IOC 的用处就是可以避免在类里依赖着某个指定对象时直接使用 new 这样的强耦合情况。</p>
<p>IOC 容器存放着对象，管理着依赖关系。当某个类需要什么对象时，只要声明好它对应的依赖，IOC 容器就会自动找到其所依赖的对象进行注入。</p>
<p>所以这就是控制反转：有传统的直接 new 的方式来主动控制到变成由 IOC 容器来控制进行对象的注入</p>
<h2 id="Spring-里的-IOC-实现"><a href="#Spring-里的-IOC-实现" class="headerlink" title="Spring 里的 IOC 实现"></a>Spring 里的 IOC 实现</h2><h3 id="Spring-的-IOC-容器"><a href="#Spring-的-IOC-容器" class="headerlink" title="Spring 的 IOC 容器"></a>Spring 的 IOC 容器</h3><p>Spring IOC 容器是一个管理 Bean 的容器，Spring 里所有的 IOC 容器都需要实现 BeanFactory 接口，它是一个顶级容器接口。其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansExcept 工 on ;</span><br><span class="line"><span class="keyword">import</span> org.springframework . core.ResolvableType ; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前缀</span></span><br><span class="line">	String FACTORY BEAN PREFIX = <span class="string">"&amp;”; //多个 getBean 方法</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	Object getBean(String name) throws BeansException;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	&lt;T&gt; T getBean(String 口ame, Class&lt;T&gt; requiredType) throws Bea口sExcept工on;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	Object getBean(String name, Object . . args) throws BeansException ;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	&lt;T&gt; T getBea口( Class&lt;T&gt; requiredType , Object ... args) throws BeansExcept工on;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	//是否包含 Bean</span></span><br><span class="line"><span class="string">	boolean containsBean (String name); II Bean是否单例</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	boolean isS工ngleton(String name) throws NoSuchBeanDefinitionExcept工on ; II Bean是否原型</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	boolean isPrototype(String name) throws NoSuchBeanDefinitionException;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	//是否类型匹配</span></span><br><span class="line"><span class="string">	bool ean isTypeMatch(String name , ResolvableType typeToMatch) throws NoSuchBeanDefin工tionException;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	boolean isTypeMatch(String name , Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefin工tionException;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	//获取 Bean 的类型</span></span><br><span class="line"><span class="string">	Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinit工onException ;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	//获取 Bean 的别名</span></span><br><span class="line"><span class="string">	String[] getAliases(String name);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到上面代码中有多个getBean方法，这也是IoC容器最重要的方法之一， 它的意义是从 IoC 容器中获取 Beano 而从多个 getBean 方法中可 以看到有按类型( by type)获取 Bean 的，也有按 名称( by name)获取 Bean 的，这就意味着在 Spring IoC 容器中 ，允许我们按类型或者名称获取 Bean。</p>
<p>由于 BeanFactory 的功能还不够强大，因此 Spring在 BeanFactory 的基础上， 还设计了一个更为高级的接口 ApplicationContext。 它是 BeanFactory 的子接口之一 ， 在 Spring 的体 系中 BeanFactory 和 ApplicationContext 是最为重要的接口设计 ，在现实中我们使用的大部分Spring IoC 容器是 ApplicationContext接口的实现类</p>
<h3 id="装配-bean-至容器中"><a href="#装配-bean-至容器中" class="headerlink" title="装配 bean 至容器中"></a>装配 bean 至容器中</h3><ul>
<li>通过扫描装配，即使用 @Component 注解和 @ComponentScan </li>
</ul>
<ul>
<li>用 @Bean 注解来实现装配，对某个方法直接使用 @Bean 注解来将其返回的对象注入到容器里</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/05/19/AOP 学习笔记/" class="prev">上一篇</a><a href="/2018/04/23/泛型总结/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2021 <a href="http://www.tenpercent.top">Jeffrey</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-146782675-1",'auto');ga('send','pageview');</script></body></html>