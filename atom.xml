<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码 | 自由</title>
  <icon>https://www.gravatar.com/avatar/c7953fb7f3bc4f8181191e5e6f352f05</icon>
  <subtitle>但行好事，莫问前程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.tenpercent.top/"/>
  <updated>2021-02-16T13:30:02.384Z</updated>
  <id>http://www.tenpercent.top/</id>
  
  <author>
    <name>Jeffrey</name>
    <email>chenjiehui0807@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis过期key是怎么清理的</title>
    <link href="http://www.tenpercent.top/2020/03/28/Redis%20%E8%BF%87%E6%9C%9F%20key%20%E6%98%AF%E6%80%8E%E4%B9%88%E6%B8%85%E7%90%86%E7%9A%84/"/>
    <id>http://www.tenpercent.top/2020/03/28/Redis 过期 key 是怎么清理的/</id>
    <published>2020-03-27T16:00:00.000Z</published>
    <updated>2021-02-16T13:30:02.384Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 的 key 清理，也就是内存回收的时候主要分为：过期删除策略与 内存淘汰策略两部分。</p><h2 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h2><p>删除到达过期时间的 key 。</p><h3 id="第一种：定时检查删除"><a href="#第一种：定时检查删除" class="headerlink" title="第一种：定时检查删除"></a>第一种：定时检查删除</h3><p>对于每一个设置了过期时间的 key 都会创建一个定时器，一旦达到过期时间都会删除。这种方式立即清除过期数据，对内存比较好，</p><p>但是有缺点是：占用了大量 CPU 的资源去处理过期数据，会影响 redis 的吞吐量 和 响应时间。 </p><a id="more"></a><h3 id="第二种：惰性检查删除"><a href="#第二种：惰性检查删除" class="headerlink" title="第二种：惰性检查删除"></a>第二种：惰性检查删除</h3><p>当访问一个 key 的时候，才会判断该 key 是否过期，如果过期就删除。该方式能最大限度节省 CPU 的资源。</p><p>但是对内存不太好，有一种比较极端的情况：出现大量的过期 key 没有被再次访问，因为不会被清除，导致占用了大量的内存。</p><h3 id="第三种：定期检查删除"><a href="#第三种：定期检查删除" class="headerlink" title="第三种：定期检查删除"></a>第三种：定期检查删除</h3><p>每隔一段时间，扫描redis 中过期key 的字典，并清除部分过期的key。这种方式是前俩种一种折中方法。不同的情况下，调整定时扫描时间间隔，让CPU 与 内存达到最优。</p><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>Redis 内存淘汰策略是指达到maxmemory极限时，使用某种算法来决定来清理哪些数据，以保证新数据存入。</p><h3 id="第一类-不处理，等报错-默认的配置"><a href="#第一类-不处理，等报错-默认的配置" class="headerlink" title="第一类 不处理，等报错(默认的配置)"></a>第一类 不处理，等报错(默认的配置)</h3><ul><li>noeviction，发现内存不够时，不删除key，执行写入命令时直接返回错误信息。（Redis默认的配置就是noeviction）</li></ul><h3 id="第二类-从所有结果集中的key中挑选，进行淘汰"><a href="#第二类-从所有结果集中的key中挑选，进行淘汰" class="headerlink" title="第二类 从所有结果集中的key中挑选，进行淘汰"></a>第二类 从所有结果集中的key中挑选，进行淘汰</h3><ul><li>allkeys-random 就是从所有的key中随机挑选key，进行淘汰</li><li>allkeys-lru 就是从所有的key中挑选最近使用时间距离现在最远的key，进行淘汰</li><li>allkeys-lfu 就是从所有的key中挑选使用频率最低的key，进行淘汰。（这是Redis 4.0版本后新增的策略）</li></ul><h3 id="第三类-从设置了过期时间的key中挑选，进行淘汰"><a href="#第三类-从设置了过期时间的key中挑选，进行淘汰" class="headerlink" title="第三类 从设置了过期时间的key中挑选，进行淘汰"></a>第三类 从设置了过期时间的key中挑选，进行淘汰</h3><pre><code>这种就是从设置了expires过期时间的结果集中选出一部分key淘汰，挑选的算法有：</code></pre><ul><li><p>volatile-random 从设置了过期时间的结果集中随机挑选key删除。  </p></li><li><p>volatile-lru 从设置了过期时间的结果集中挑选上次使用时间距离现在最久的key开始删除  </p></li><li><p>volatile-ttl 从设置了过期时间的结果集中挑选可存活时间最短的key开始删除(也就是从哪些快要过期的key中先删除)  </p></li><li><p>volatile-lfu 从过期时间的结果集中选择使用频率最低的key开始删除（这是Redis 4.0版本后新增的策略）</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 的 key 清理，也就是内存回收的时候主要分为：过期删除策略与 内存淘汰策略两部分。&lt;/p&gt;
&lt;h2 id=&quot;过期删除策略&quot;&gt;&lt;a href=&quot;#过期删除策略&quot; class=&quot;headerlink&quot; title=&quot;过期删除策略&quot;&gt;&lt;/a&gt;过期删除策略&lt;/h2&gt;&lt;p&gt;删除到达过期时间的 key 。&lt;/p&gt;
&lt;h3 id=&quot;第一种：定时检查删除&quot;&gt;&lt;a href=&quot;#第一种：定时检查删除&quot; class=&quot;headerlink&quot; title=&quot;第一种：定时检查删除&quot;&gt;&lt;/a&gt;第一种：定时检查删除&lt;/h3&gt;&lt;p&gt;对于每一个设置了过期时间的 key 都会创建一个定时器，一旦达到过期时间都会删除。这种方式立即清除过期数据，对内存比较好，&lt;/p&gt;
&lt;p&gt;但是有缺点是：占用了大量 CPU 的资源去处理过期数据，会影响 redis 的吞吐量 和 响应时间。 &lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://www.tenpercent.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="PHP" scheme="http://www.tenpercent.top/tags/PHP/"/>
    
      <category term="Redis" scheme="http://www.tenpercent.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的持久化是怎么实现的</title>
    <link href="http://www.tenpercent.top/2020/03/23/Redis%20%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
    <id>http://www.tenpercent.top/2020/03/23/Redis 的持久化是怎么实现的/</id>
    <published>2020-03-22T16:00:00.000Z</published>
    <updated>2021-02-16T13:41:35.792Z</updated>
    
    <content type="html"><![CDATA[<p>Redis因为Redis是基于内存的数据库，一旦断电，所有实例都会关机，所有数据都会丢失，在运行期间，可以通过开启Redis的持久化功能，将数据写入磁盘，供实例重启时恢复数据。Redis的持久化主要通过AOF和RDB实现持久化。</p><a id="more"></a><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF持久化主要是Redis在修改相关的命令后，将命令添加到aof_buf缓存区（aof_buf是Redis中的SDS结构，SDS结构可以认为是对C语言中字符串的扩展）的末尾，然后在每次事件循环结束时，根据appendfsync的配置（always是总是写入，everysec是每秒写入，no是根据操作系统来决定何时写入），判断是否需要将aof_buf写入AOF文件。生产环境中一般用默认配置everysec，也就是每秒写入一次，一旦挂机会丢掉1分钟的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct redisServer &#123;</span><br><span class="line"> /* AOF buffer, written before entering the event loop */</span><br><span class="line"> sds aof_buf;//aof_buf缓冲区其实就是Redis的一个简单动态字符串</span><br><span class="line"> &#125;</span><br><span class="line">struct sdshdr &#123;</span><br><span class="line">    unsigned int len;</span><br><span class="line">    unsigned int free;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>RDB持久化指的是在满足一定的触发条件时（在一个的时间间隔内执行修改命令达到一定的数量，或者手动执行SAVE和BGSAVE命令），对这个时间点的数据库所有键值对信息生成一个压缩文件dump.rdb，然后将旧的删除，进行替换。（在Redis默认的配置下，RDB是开启的，AOF持久化是关闭的）</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>实现原理是fork一个子进程，然后对键值对进行遍历，生成rdb文件，在生成过程中，父进程会继续处理客户端发送的请求，当父进程要对数据进行修改时，会对相关的内存页进行拷贝，修改的是拷贝后的数据。（也就是COPY ON WRITE，写时复制技术，就是当多个调用者同时请求同一个资源，如内存或磁盘上的数据存储，他们会共用同一个指向资源的指针，指向相同的资源，只有当一个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给这个调用者，其他调用者还是使用最初的资源,在CopyOnWriteArrayList的实现中，也有用到，添加或者插入一个新元素时过程是，加锁，对原数组进行复制，然后添加新元素，然后替代旧数组，解锁）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CopyOnWriteArrayList的添加元素的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击复制代码复制出错复制成功<br>AOF和RDB的区别是什么？<br>AOF因为是保存了所有执行的修改命令，粒度更细，进行数据恢复时，恢复的数据更加完整，但是由于需要对所有命令执行一遍，效率比较低，同样因为是保存了所有的修改命令，同样的数据集，保存的文件会比RDB大，而且随着执行时间的增加，AOF文件可能会越来越大，所有会通过执行BGREWRITEAOF命令来重新生成AOF文件，减小文件大小。Redis服务器故障重启后，默认恢复数据的方式首选是通过AOF文件恢复，其次是通过RDB文件恢复。</p><p>RDB是保存某一个时间点的所有键值对信息，所以恢复时可能会丢失一部分数据，但是恢复效率会比较高。</p><h3 id="怎么防止AOF文件越来越大？"><a href="#怎么防止AOF文件越来越大？" class="headerlink" title="怎么防止AOF文件越来越大？"></a>怎么防止AOF文件越来越大？</h3><p>为了防止AOF文件越来越大，可以通过执行BGREWRITEAOF命令进行AOF重写，会fork子进程出来，读取当前数据库的键值对信息，生成所需的写命令，写入新的AOF文件。在生成期间，父进程继续正常处理请求，执行修改命令后，不仅会将命令写入aof_buf缓冲区，还会写入重写aof_buf缓冲区。当新的AOF文件生成完毕后，子进程父进程发送信号，父进程将重写aof_buf缓冲区的修改命令写入新的AOF文件，写入完毕后，对新的AOF文件进行改名，原子地（atomic）地替换旧的AOF文件。</p><p>AOF重写命令可以手动执行，在满足一些条件时，Redis也会自动触发。自动触发的条件如下：</p><p>没有 BGSAVE 命令在执行。<br>没有 BGREWRITEAOF 在执行。<br>当前AOF文件大小 &gt; server.aof_rewrite_min_size(默认为1MB)。<br>当前AOF文件大小和最后一次AOF重写后的大小之间的比率大于等于指定的增长百分比(默认为1倍，100%，也就是当前AOF文件大小&gt;=上次重写后文件的2倍后)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis因为Redis是基于内存的数据库，一旦断电，所有实例都会关机，所有数据都会丢失，在运行期间，可以通过开启Redis的持久化功能，将数据写入磁盘，供实例重启时恢复数据。Redis的持久化主要通过AOF和RDB实现持久化。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://www.tenpercent.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="PHP" scheme="http://www.tenpercent.top/tags/PHP/"/>
    
      <category term="Redis" scheme="http://www.tenpercent.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB 缓冲池(buffer pool) 工作原理</title>
    <link href="http://www.tenpercent.top/2020/02/16/Innodb-buffer-pool/"/>
    <id>http://www.tenpercent.top/2020/02/16/Innodb-buffer-pool/</id>
    <published>2020-02-15T16:00:00.000Z</published>
    <updated>2021-02-16T13:31:06.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓冲池的用处"><a href="#缓冲池的用处" class="headerlink" title="缓冲池的用处"></a>缓冲池的用处</h2><p>对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引，还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只是 InnoDB 对文件系统上一个或几个实际文件的抽象，也就实际数据说到底还是存储在磁盘上的。</p><p>磁盘的速度很慢，怎么能配得上“快如闪电”的CPU 呢？</p><p>InnoDB 存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中。</p><p>也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。</p><a id="more"></a><h2 id="缓冲池内部组成"><a href="#缓冲池内部组成" class="headerlink" title="缓冲池内部组成"></a>缓冲池内部组成</h2><p>缓冲池中默认的缓存页大小和在磁盘上默认的页大小是一样的，一般是16KB。</p><p>为了更好的管理这些在缓冲池中的缓存页，InnoDB为每一个缓存页都创建了一些所谓的控制信息。</p><p>这些控制信息包括该页所属的表空间编号、页号、缓存页在缓冲池中的地址、链表节点信息、一些锁信息。</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20191229204548.png" alt></p><p>缓冲池的一些参数：<br>SHOW VARIABLES LIKE ‘innodb_buffer_pool%’;<br>free 链表<br>当最初启动MySQL服务器的时候，此时并没有真实的磁盘页被缓存到缓冲池中，之后随着程序的运行，会不断的有磁盘上的页被缓存到缓冲池中。</p><p>从磁盘上读取一个页到缓冲池中的时候该放到哪个缓存页的位置呢？</p><p><em>思路：区分缓冲池中哪些缓存页是空闲的，哪些已经被使用了。</em></p><p>把所有空闲的缓存页对应的控制块作为节点放到一个链表中，这个链表叫作 free 链表。</p><h2 id="flush-链表"><a href="#flush-链表" class="headerlink" title="flush 链表"></a>flush 链表</h2><p>如果我们修改了缓冲池中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为脏页（dirty page）。</p><p>最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能。</p><p>所以，Innodb 创建了一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，在未来的某个时间点进行同步。这个链表叫做 flush 链表。</p><h2 id="缓存不够的窘境"><a href="#缓存不够的窘境" class="headerlink" title="缓存不够的窘境"></a>缓存不够的窘境</h2><p>缓冲池对应的内存大小毕竟是有限的，如果需要缓存的页占用的内存大小超过了缓冲池大小，也就是已经没有多余的空闲缓存页的时候怎么办？</p><p>把某些旧的缓存页从缓冲池中移除，然后再把新的页放进来。</p><p>移除哪些缓存页？这就需要引入缓存淘汰机制了。</p><h2 id="缓存淘汰机制"><a href="#缓存淘汰机制" class="headerlink" title="缓存淘汰机制"></a>缓存淘汰机制</h2><p>缓存淘汰有以下两个目的：</p><ul><li>实现淘汰</li><li>使缓存命中率高</li></ul><p>缓存淘汰机制比较常用的是用 LRU （Least recently used）算法。</p><h3 id="传统LRU"><a href="#传统LRU" class="headerlink" title="传统LRU"></a>传统LRU</h3><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20191229204614.png" alt></p><p>LRU 的两种情况：</p><p>（1）页已经在缓冲池里，那就只做“移至”LRU头部的动作，而没有页被淘汰；</p><p>（2）页不在缓冲池里，除了做“放入”LRU头部的动作，还要做“淘汰”LRU尾部页的动作；</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20191229204632.png" alt></p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20191229204651.png" alt></p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20191229204705.png" alt></p><p>在 InnoDB 中，传统的 LRU 会遇到两个问题：</p><p>（1）预读失效；</p><p>（2）缓冲池污染；</p><p>什么是预读失效？</p><p>由于预读 (Read-Ahead)，提前把页放入了缓冲池，但最终 MySQL 并没有从页中读取数据，称为预读失效。</p><p>如何对预读失效进行优化？</p><p>要优化预读失效，思路是：</p><p>（1）让预读失败的页，停留在缓冲池 LRU 里的时间尽可能短；</p><p>（2）让真正被读取的页，才挪到缓冲池 LRU 的头部；</p><p>以保证，真正被读取的热数据留在缓冲池里的时间尽可能长。</p><p>具体方法是：</p><p>（1）将LRU分为两个部分：</p><ul><li><p>new 区(new sublist)</p></li><li><p>old 区(old sublist)</p></li></ul><p>（2）两个区首尾相连，即：new 区的尾(tail)连接着 old 区的头(head)；</p><p>（3）新页（例如被预读的页）加入缓冲池时，只加入到 old 区头部：<br>如果数据真正被读取（预读成功），才会加入到 new 区的头部<br>如果数据没有被读取，则会比 new 区里的“热数据页”更早被淘汰出缓冲池</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20191229204718.png" alt></p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20191229204732.png" alt></p><p>改进版缓冲池LRU能够很好的解决“预读失败”的问题。</p><p>查看系统变量 innodb_old_blocks_pct 的值来确定old区域在LRU链表中所占的比例<br>SHOW VARIABLES LIKE ‘innodb_old_blocks_pct’;</p><p>什么是 MySQL 缓冲池污染？<br>当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况叫缓冲池污染。</p><p>例如，有一个数据量较大的用户表，当执行<br>select * from user where name like “%test%”;</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20191229204750.png" alt></p><p>要优化缓冲池污染，思路是：</p><p>（1）不让批量扫描的大量数据进入到 new 区；</p><p>（2）让真正被读取的页，才挪到缓冲池 LRU 的头部；</p><p>具体实现：<br>加入了一个“old 区停留时间”的机制：<br>在 old 区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，如果后续再次访问的时间与第一次访问的时间在某个时间间隔内（即该缓存页在 old 区的存在时间在某个时间间隔内），那么该页面就不会被从old 区移动到 new 区的头部。</p><p>上述的全表扫描执行：</p><p>(1) 扫描过程中，需要新插入的数据页，都被放到old区</p><p>(2) 一个数据页会有多条记录，因此一个数据页会被访问多次</p><p>(3) 由于是顺序扫描,数据页的第一次被访问和最后一次被访问的时间间隔不会超过1S，因此还是会留在old区</p><p>(4) 继续扫描，之前的数据页再也不会被访问到，因此也不会被移到 new 区，最终很快被淘汰</p><p>这个间隔时间是由系统变量 innodb_old_blocks_time 控制的。</p><p><code>SHOW VARIABLES LIKE &#39;innodb_old_blocks_time&#39;;</code></p><p>配置缓冲池时的注意事项<br>innodb_buffer_pool_size<br> innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances 的倍数（这主要是想保证每一个 缓冲池 实例中包含的 chunk 数量相同）。</p><p>查看Buffer Pool的状态信息</p><p><code>SHOW ENGINE INNODB STATUS\G</code></p><p>一些参数如下：</p><p>Total memory allocated ：代表 Buffer Pool 向操作系统申请的连续内存空间大小，包括全部控制块、缓存页、以及碎片的大小。</p><p>Buffer pool size：代表该 Buffer Pool 可以容纳多少缓存页，单位是页</p><p>Free buffers：代表当前 Buffer Pool 还有多少空闲缓存页，也就是 free 链表中还有多少个节点。</p><p>Database pages：代表 LRU 链表中的页的数量，包含 new 和 old 两个区域的节点数量。</p><p>Old database pages：代表 LRU 链表 old 区域的节点数量。</p><p>Modified db pages：代表脏页数量，也就是 flush 链表中节点的数量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、磁盘太慢，用内存作为缓存很有必要。</p><p>2、缓冲池本质上是InnoDB向操作系统申请的一段连续的内存空间，可以通过innodb_buffer_pool_size 来调整它的大小。</p><p>3、InnoDB 使用了许多链表来管理缓冲池。</p><p>4、缓冲池的常见管理算法是 LRU</p><p>5、InnoDB 对普通 LRU 进行了优化：分为 new 区和 old 区，加入“停留时间”机制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缓冲池的用处&quot;&gt;&lt;a href=&quot;#缓冲池的用处&quot; class=&quot;headerlink&quot; title=&quot;缓冲池的用处&quot;&gt;&lt;/a&gt;缓冲池的用处&lt;/h2&gt;&lt;p&gt;对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引，还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只是 InnoDB 对文件系统上一个或几个实际文件的抽象，也就实际数据说到底还是存储在磁盘上的。&lt;/p&gt;
&lt;p&gt;磁盘的速度很慢，怎么能配得上“快如闪电”的CPU 呢？&lt;/p&gt;
&lt;p&gt;InnoDB 存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中。&lt;/p&gt;
&lt;p&gt;也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://www.tenpercent.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MySQL" scheme="http://www.tenpercent.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的隔离级别以及 MVCC 的原理</title>
    <link href="http://www.tenpercent.top/2020/01/17/MySQL%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8A%20MVCC%20%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://www.tenpercent.top/2020/01/17/MySQL的隔离级别以及 MVCC 的原理/</id>
    <published>2020-01-16T16:00:00.000Z</published>
    <updated>2021-02-16T13:41:47.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="隔离级别有哪些？"><a href="#隔离级别有哪些？" class="headerlink" title="隔离级别有哪些？"></a>隔离级别有哪些？</h2><h3 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h3><p>事务还没有提交的修改，其他事务都可以读取到。可能会有脏读的问题，就是读到一些未提交的脏数据。</p><a id="more"></a><h3 id="提交读"><a href="#提交读" class="headerlink" title="提交读"></a>提交读</h3><p>其他事务提交的修改，事务在执行过程中可以读取到，如果一个事务在执行过程中需要两次读取同一行数据，可能会不一致。一般发生在UPDATE和DELETE操作。（大部分数据库系统是采用的这个，但是mysql不是）</p><p>这个隔离级别下，读是不加锁的，写，更新，删除是加锁的，如果更新的行是可以通过索引查找到，那么是对这些行加行锁，否则会将所有行都加锁，然后返回给MySQL Server，让他来进行过滤，对于不满足条件的行解锁。</p><p>但是还是会有幻读的问题发生(幻读就是事务A在读取和写入符合的条件的记录时，其他事务又插入了一条符合条件的记录，此时事务A二次读取时会产生幻行，一般发生在INSERT操作。)</p><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>在事务开始时，记录当时的状态，在第二次读取同一行数据时，除非是本事务做的修改，否则读取的都是事务开始时的数据。可以解决脏读的问题，没法解决幻读的问题。这是MySQL的默认事务隔离级别。（MySQL在可重复读的隔离级别下，通过MVCC机制和Next-key Lock解决了幻读的问题。）</p><h3 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h3><p>强制事务串行执行，会让读取每一行都加锁，读用读锁，写用写锁，读写锁互斥，可以解决幻读的问题。并发比较多的话可能会造成大量的超时等待和锁竞争。如果业务并发的特别少或者没有并发，同时又要求数据及时可靠的话</p><h2 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h2><p>mvcc主要适用于可重复读，可以解决幻读的问题。</p><p>innodb在解决幻读的问题主要是通MVVC 多版本并发版本控制来实现的</p><p>就是每一行数据中额外保存两个隐藏的列：</p><p><strong>插入或上次更新该行的事务ID</strong>(删除也被认为是一次更新，只不过在代表删除的更新操作中，行中的特殊位被设置为将其标记为已删除。这个事务ID可以认为是数据行的修改版本号。)</p><p><strong>滚动指针</strong>(指向undo log中用于事务回滚的日志记录)。</p><p>具体流程：</p><h3 id="1-插入操作"><a href="#1-插入操作" class="headerlink" title="1.插入操作"></a>1.插入操作</h3><p>每次开始事务时，会对系统版本号+1作为当前事务的版本号。</p><p>插入数据后，将事务的版本号作为数据行的创建版本号。</p><h3 id="2-删除操作"><a href="#2-删除操作" class="headerlink" title="2.删除操作"></a>2.删除操作</h3><p>在使用SQL语句删除行时，并不会立即将其从数据库中物理删除，只会将其标记为删除，并且修改更新该行的事务ID。（<code>InnoDB</code>只会在丢弃为删除而编写的undo log日志记录时，才物理删除相应的行及其索引记录。此删除操作称为<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_purge" target="_blank" rel="noopener">purge</a>，它非常快，通常花费与执行删除操作的SQL语句相同的时间顺序。）</p><h3 id="4-或更新操作"><a href="#4-或更新操作" class="headerlink" title="4.或更新操作"></a>4.或更新操作</h3><p>将当前的事务版本号作为数据行的更新版本号。</p><h3 id="5-查询操作"><a href="#5-查询操作" class="headerlink" title="5.查询操作"></a>5.查询操作</h3><p>数据行要被查询出来必须满足两个条件，</p><p>数据行没有标记为删除或者标记为删除但是删除的事务ID&gt;当前事务ID的数据（否则数据已经被标记删除了)</p><p>更新事务ID&lt;=当前事务ID的数据（否则数据是后面的事务创建出来的，或者是被修改过的，那么需要去undo log中找上次的快照数据。）</p><p>如果查询时，该行数据被加了X锁，那么读数据的事务不会进行等待，而是会根据该行数据中的回滚指针undo log日志中读之前版本的数据（这里存储的数据本身是用于回滚的），在可重复读的隔离级别下，从undo log中读取的数据总是事务开始时的快照数据(也就是版本号小于当前事务id的数据)，在提交读的隔离级别下，从undo log中读取的总是最新的快照数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;隔离级别有哪些？&quot;&gt;&lt;a href=&quot;#隔离级别有哪些？&quot; class=&quot;headerlink&quot; title=&quot;隔离级别有哪些？&quot;&gt;&lt;/a&gt;隔离级别有哪些？&lt;/h2&gt;&lt;h3 id=&quot;未提交读&quot;&gt;&lt;a href=&quot;#未提交读&quot; class=&quot;headerlink&quot; title=&quot;未提交读&quot;&gt;&lt;/a&gt;未提交读&lt;/h3&gt;&lt;p&gt;事务还没有提交的修改，其他事务都可以读取到。可能会有脏读的问题，就是读到一些未提交的脏数据。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="MySQL" scheme="http://www.tenpercent.top/tags/MySQL/"/>
    
      <category term="事务" scheme="http://www.tenpercent.top/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>为什么 InnoDB 使用 B+ 树</title>
    <link href="http://www.tenpercent.top/2019/11/16/%E4%B8%BA%E4%BB%80%E4%B9%88%20InnoDB%20%E4%BD%BF%E7%94%A8%20B+%20%E6%A0%91/"/>
    <id>http://www.tenpercent.top/2019/11/16/为什么 InnoDB 使用 B+ 树/</id>
    <published>2019-11-15T16:00:00.000Z</published>
    <updated>2021-02-16T13:28:31.149Z</updated>
    
    <content type="html"><![CDATA[<p>每一种解决方案都是为了解决某一类问题而产生，所以在问为什么使用某种方案的时候，其本质就是在探索该方案是用来满足什么样的需求，解决什么样的问题。</p><p>所以探究 InnoDb 为什么使用 B+ 树这个问题，就是要弄清楚 B+ 树是用来满足什么的需求，解决什么样的问题。</p><a id="more"></a><h2 id="要满足什么样的需求"><a href="#要满足什么样的需求" class="headerlink" title="要满足什么样的需求"></a>要满足什么样的需求</h2><p>我们先看一下一些常用的 SQL 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据某个确定值来查询对应的信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, email <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过区间值查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, email <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">12</span> <span class="keyword">and</span> <span class="keyword">id</span> &lt; <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过范围查询并进行排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, email <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">123</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>从以上的几个常用的 SQL 我们可以看到在对数据库进行查找数据的过程中主要有以下三类需求：</p><ol><li>根据某个值精确快速查找</li><li>根据区间的上下限来快速查找此区间的数据</li><li>查询符合条件的记录并根据某些字段进行排序</li></ol><p>所以，需要找到一种符合上面所有需求的方案。目前比较常用于查询的数据结构有以下两种：</p><ul><li>散列表</li><li>树</li></ul><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表（哈希表）是根据是一种根据(key, value)直接进行访问的数据结构，它通过哈希函数将 key 值映射到散列表对应的位置上，查找效率非常高。</p><p>索引里其中的一种索引类型哈希索引就是基于散列表实现的，假设我们对名字建立哈希索引，则查找过程如下图所示：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20200505165520.png" alt></p><p>对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（上图散列表的位置），散列表里的每个元素指向数据行的指针，由于索引自身只存储对应的哈希值，所以索引的结构十分紧凑，并且可以直接根据键值直接找到对应的数据记录，这让哈希索引查找速度非常快！但是哈希索引也有它的劣势，具体如下：</p><ol><li>只有精确匹配索引所有列的查询才有效，比如我在列（name, address）建立哈希索引，如果只查询数据列 name, 则无法使用该索引。</li><li>哈希索引不是按照索引值顺序存储的，即 key 经过哈希函数计算后的哈希值不是按顺序的，所以也就无法用于排序，就不能根据区间进行查找。</li><li>哈希索引只支持等值比较查询，如 = 和 in()，不支持范围的查找，如 id &gt; 17。</li></ol><p>所以，哈希索引只适用于特定场合，在适当的场景使用，的确能带来很大的性能提升。比如在 InnoDB 里，就有一种特殊的功能叫 “自适应哈希索引”，如果 InnoDB 注意到某些索引列值被频繁使用时，它会在内存基于 B+ 树索引之上再创建一个哈希索引，这样就能让 B+ 树也具有哈希索引的优点。</p><p>所以散列表结构无法满足上文提到的需求。</p><p>​接着我们来看看树。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树可用于查找，且其查找的时间复杂度近似 O(log2n),但是可以用平衡二叉树作为索引的结构吗？ </p><p>答案是不能。</p><p>因为数据库表的数据通常是很多的，正常都是存放在磁盘上的。而磁盘的速度相比内存的速度是慢很多倍的，所以要尽量减少读取磁盘的次数，通过从内存读取数据来提高速度。</p><p>那么，如何将尽量多且有效的索引数据放到内存中呢？</p><p>这里有两个问题要解决：</p><p>1、尽量多</p><p>读取磁盘数据的时候，都是按磁盘块来读取的（局部性原理与磁盘预读），并不是一条一条的读。在使用树这种结构作为索引的数据结构时，我们每查找一次数据就需要从磁盘中读取一个树节点，也就是对应的一个磁盘块，所以如果我们能把尽量多的数据放到磁盘块中，那么每次读取的数据就会较多。</p><p>而平衡二叉树是每个节点只存储一个键值和数据，也就是说，存储的时候，每个磁盘块只存储一个键值和数据。</p><p>那如果存储了海量的数据，可以想象平衡二叉树的节点将会非常多，树高也会极其高，在查找数据的时候就会进行很多次磁盘 IO，效率将会极低。</p><p>所以平衡二叉树无法解决存储尽量多的索引到内存中这个问题。</p><p>2、有效的索引数据</p><p>我们所说的平衡二叉树，指的是逻辑结构上的平衡二叉树，其物理实现是数组。所以在逻辑相近的节点上，其物理位置可能相差会很远。因此，每次读取的磁盘页数据，很多可能是用不上的，即有效的索引数据并不多，所以在查找过程中还是要进行许多次的磁盘读取操作。</p><p>所以平衡二叉树也无法解决这个问题。</p><p>所以，能解决这两个问题的数据结构 —— B 树就被发明出来了。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p>B 树（Balance Tree），即平衡树的意思。B 树是从平衡二叉树演化而来，B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。B 树的结构示例如下图所示：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20200523132621.png" alt></p><p>由于 B 树的每一个节点，即每一个磁盘块存储的数据较多，所以一定程度上解决了上文提到的存储尽量多的索引的问题。也一定程度上的解决了存储尽量多的有效索引的问题。</p><p>但是，B 树只是一定程度上的解决了问题，我们需要更好的解决问题。即能不能的做到存储更多的有效的索引呢？</p><p>答案是可以。这时候就就需要 B+ 树闪亮登场了。</p><h3 id="更好的解决了问题的-B-树"><a href="#更好的解决了问题的-B-树" class="headerlink" title="更好的解决了问题的 B+ 树"></a>更好的解决了问题的 B+ 树</h3><p>B 树一定程度上的解决了问题，而从 B 树演化而来的 B+ 树能更好的解决问题，所以现实使用中几乎已经没有使用 B 树的情况了。</p><p>B + 树的结构示意图如下：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20200524093949.png" alt></p><p>那么 B+ 树和 B 树有哪些不同? </p><ul><li>在 B+ 树中，非叶子节点上是不存储数据的，仅存储键值。</li></ul><p>因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16 KB，如果不存储数据，那么节点就可以存储更多的键值，相应的树的阶树就会更大，对于同样的数据量来说，需要的树高就会变低，树会更矮胖，如此一来查找数据的时候进行磁盘的 IO 次数就会减少，提升查询效率。</p><p>由于 B+ 树的阶数等于键值数量，假设 B+ 树的一个节点可以存储 1000 个键值，那么 3 层的 B+ 树 可以存储 1000 x 1000 x 1000 = 10亿个数据。并且一般根节点是常驻内存的，所以查找 10 亿个数据，只需要 2 次磁盘 IO。</p><p>B+ 这个特点很好的解决了上文提到的存储尽量多的索引数据的问题，并且查询效率也高。</p><ul><li>B+ 树的叶子节点中的索引数据是按顺序排列的，并且叶子节点间是通过双向链表进行连接的。</li></ul><p>这个特点使 B+ 树在实现范围查找，排序查找，分组查找等操作时变得异常简单。而 B 树由于数据分散在各个节点，要实现这些操作很不容易。</p><p>由于索引数据是按顺序排序的，即每次读取了数据页的时候，里面的索引数据大部分都是需要用的，所以也很好的解决了上文提到的如何存储尽量多的有效的索引数据的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，我们可以发现，在使用某种解决方案的时候，这种方案一定是用来满足某些需求的，在满足需求的过程中就会遇到一些问题，而最终的解决方案一定是能尽量好的解决问题并满足需求的。</p><p>所以，探究清楚某种方案是要满足什么样的需求，解决什么样的问题以及如何的解决了问题，也就明白了为什么使用这个方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每一种解决方案都是为了解决某一类问题而产生，所以在问为什么使用某种方案的时候，其本质就是在探索该方案是用来满足什么样的需求，解决什么样的问题。&lt;/p&gt;
&lt;p&gt;所以探究 InnoDb 为什么使用 B+ 树这个问题，就是要弄清楚 B+ 树是用来满足什么的需求，解决什么样的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="MySQL" scheme="http://www.tenpercent.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>当我们在谈索引的时候，我们在谈什么</title>
    <link href="http://www.tenpercent.top/2019/10/17/mysql-index-1/"/>
    <id>http://www.tenpercent.top/2019/10/17/mysql-index-1/</id>
    <published>2019-10-16T16:00:00.000Z</published>
    <updated>2020-05-05T07:29:18.580Z</updated>
    
    <content type="html"><![CDATA[<p>一句话总结：在 InnoDB 里，一个索引就是一棵 B+ 树。</p><p>那么这个 B+ 树是什么样子的呢？</p><p>数据存储在叶子节点，中间节点存目录项。</p><p>那么，</p><p>叶子节点啥样的？</p><p>中间节点啥样的？</p><p>要知道节点的结构，就得先知道 InnoDB 管理存储空间的基本单位 —— 页。</p><p>InnoDB 引擎将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，页的大小一般为 16 KB。InnoDB 设计了许多种不同类型的页，比如存放表数据记录的页，存放表空间头部信息的页，存放 Insert Buffer 信息的页，存放 undo 日志的页等等，而这之中存放表中索引数据记录的页即数据页就是 B+ 数的叶子节点。</p><a id="more"></a><h3 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h3><p>数据页中由多个部分组成，不同部分有不同的作用，其结构如下图：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20191013223331.png" alt></p><p>其中，各个部分的作用如下：</p><ul><li>File Header</li></ul><p>File Header 是各种类型的页都有的部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页分别是谁等信息。通过 File Header 存储的上一页下一页的信息，各个数据页可以组成一种双向链表的结构。</p><ul><li>Page Header</li></ul><p>Page Header 用来存储本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等。</p><ul><li>Infimum + Supremum    </li></ul><p>InnoDB 定义的两条分别为最小记录与最大记录的伪记录</p><ul><li>User Records </li></ul><p>User Records 插入数据库的记录存储的地方，一开始生成页的时候，并没有 User Records 这部分，每当插入一条记录后，都会从 Free Space 部分申请一个记录大小的空间划分到 User Records 部分，当插入的记录越来越多导致 Free Space 用完之后，也就意味着这个也使用完了，要再插入新记录，就需要申请新的页了。每条记录通过 next_record 属性记录着下一条记录的地址偏移量，即所有记录实际上是一个单向链表的结构。记录里的 record_type 属性值为 0。</p><ul><li>Page Directory </li></ul><p>为了便于查找， InnoDB 将 User Records 里的记录划分为多个组，每个组的最后一条记录的地址偏移量取出来放在 Page Directory 中，这个地址偏移量被称为槽（Slot），所以 Page Directory 就是由槽组成的。</p><p>所以在页中要查找一条记录的过程是：通过主键值用二分法确定要查找的记录位于哪个槽所对应的组中，在对应的组里遍历（每个组里包含的记录只能是 1 ~ 8 条）找到对应的记录。</p><ul><li>File Trailer</li></ul><p>File Trailer 是用来校验页是否完整的，确保数据在内存和磁盘间同步不会有差错。</p><p>以上就是数据页的结构，所以，索引的叶子节点就是存有被设为索引的记录的数据页。</p><h2 id="索引的结构"><a href="#索引的结构" class="headerlink" title="索引的结构"></a>索引的结构</h2><p>上面说到数据页之间是通过 File Header 里记录的信息来找到上一页和下一页的信息，那么如何找到第一页呢？这里就得需要有目录项了，每个目录项包括两个部分：页的用户记录中最小的主键值和页号。因为存储的记录会很多导致目录项也很多，所以为了方便对目录项进行存放和管理，InnoDB 目录项的结构设计是跟数据页一样的，不同的是其中保存记录的部分存放的是目录的信息，即目录的主键和其页号，且记录里的record_type 属性值为 1。</p><p>目录指向叶子节点的的示意图如下：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20191017212544.png" alt></p><p>当存储的记录越来越多导致目录项越来越多时，要查找一个目录项就变得越来越不容易，此时，就需要有指向目录项的目录了，于是一直演变下去就会出现多级目录，形成数据的索引，而这个多级目录就是一个树的结构，如下图所示：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20191017221243.png" alt></p><p>在 InnoDB 里这种树叫 B+ 树，所谓的索引就是长这样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一句话总结：在 InnoDB 里，一个索引就是一棵 B+ 树。&lt;/p&gt;
&lt;p&gt;那么这个 B+ 树是什么样子的呢？&lt;/p&gt;
&lt;p&gt;数据存储在叶子节点，中间节点存目录项。&lt;/p&gt;
&lt;p&gt;那么，&lt;/p&gt;
&lt;p&gt;叶子节点啥样的？&lt;/p&gt;
&lt;p&gt;中间节点啥样的？&lt;/p&gt;
&lt;p&gt;要知道节点的结构，就得先知道 InnoDB 管理存储空间的基本单位 —— 页。&lt;/p&gt;
&lt;p&gt;InnoDB 引擎将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，页的大小一般为 16 KB。InnoDB 设计了许多种不同类型的页，比如存放表数据记录的页，存放表空间头部信息的页，存放 Insert Buffer 信息的页，存放 undo 日志的页等等，而这之中存放表中索引数据记录的页即数据页就是 B+ 数的叶子节点。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="MySQL" scheme="http://www.tenpercent.top/tags/MySQL/"/>
    
      <category term="索引" scheme="http://www.tenpercent.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中有哪些锁</title>
    <link href="http://www.tenpercent.top/2019/09/17/MySQL%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81/"/>
    <id>http://www.tenpercent.top/2019/09/17/MySQL中有哪些锁/</id>
    <published>2019-09-16T16:00:00.000Z</published>
    <updated>2021-02-16T13:41:09.144Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>就是对整个数据库加锁，让整个数据库处于只读状态，所有更新操作停止。（如果是主库就不能执行更新语句，从库也不能执行同步过来的bin log）</p><p>最常用的场景是对数据库加锁，让数据库只能读，然后对整个数据库做逻辑备份（就是将所有数据生成SQL写入备份文件。）</p><a id="more"></a><p>做逻辑备份有三种方式：</p><h4 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1.全局锁"></a>1.全局锁</h4><p>对数据库执行</p><p>Flush tables with read lock命令让整个库处于只读状态。</p><h4 id="2-利用innodb的事务隔离性（可重复读）"><a href="#2-利用innodb的事务隔离性（可重复读）" class="headerlink" title="2.利用innodb的事务隔离性（可重复读）"></a>2.利用innodb的事务隔离性（可重复读）</h4><p>就是通过官方自带的逻辑备份工具mysqldump来进行逻辑备份时，可以设置一个参数-single-transaction，这样导数据的时候就会开启一个事务，这样利用innodb的mvcc机制可以保证在事务执行过程中，读到的数据都跟事务开始时的一致，并且执行过程中，其他事务可以执行更新操作， 不会对他造成影响。这种方法必须要求数据库所有表的引擎都是innodb才行。</p><h4 id="3-set-global-readonly-true"><a href="#3-set-global-readonly-true" class="headerlink" title="3.set global readonly=true"></a>3.set global readonly=true</h4><p>执行这个命令也可以让全库只能读，但是第一有些系统会使用readonly来做一个操作，例如根据readonly是否为true判断数据库是否是从库，第二是如果执行这个命令后，客户端断开连接后，数据库会一直处于只读状态，如果是FTWRL命令发送异常会释放全局锁。（如果是从库，设置read-only对super user权限无效）</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级别的锁有两种，一种是表锁，一种是元数据锁MDL。</p><h4 id="表锁-lock-table"><a href="#表锁-lock-table" class="headerlink" title="表锁 lock table"></a>表锁 lock table</h4><p>就是使用lock table user_table read/write命令来对表进行加读锁或者写锁<br>加读锁后，表对所有线程都是只能读，即便是当前线程也只能读表，不然会数据不一致。<br>加写锁后，表是对当前线程写，其他线程不能读，不然会数据不一致。<br>可以通过unlock tables来解锁，客户端断开时也会自动释放锁，但是影响所有线程，影响面太大了。</p><h4 id="元数据锁MDL-MetaData-Lock"><a href="#元数据锁MDL-MetaData-Lock" class="headerlink" title="元数据锁MDL(MetaData Lock)"></a>元数据锁MDL(MetaData Lock)</h4><p>分为读锁和写锁，加读锁时，所有的线程都可以读表，加写锁时，只能一个线程写，其他的不能读。<br>锁不用显式使用，是访问一个表时，自动加上的。<br>对表执行普通SQL语句对表数据进行增删改查时，会加读锁。<br>对表结构做修改时，会加写锁。</p><p>元数据锁是为了修改表结构不会出现问题而设计的，因为一边修改表结构一边读数据可能会读到脏数据，所以在增删改查时会申请读锁，在这个期间不能修改表结构，要修改表结构需要先申请写锁，申请成功后对表结构进行修改，在这个期间不能进行增删改查。</p><h4 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h4><p>插入语句主要分为两种：<br>1.能确定插入行数的，例如插入一条或者多条数据，INSERT…<br>2.不能确定行数的，例如从一个表查询出满足条件的数据，然后插入另外一个表，INSERT…SELECT</p><p>在所有模式中，如果一个事务回滚，这些自增值将被“丢失”。</p><p>innodb_autoinc_lock_mode为0<br>这种是tradition模式，每次执行一条插入语句时都会去申请表级别的auto_increment锁</p><p>innodb_autoinc_lock_mode为1<br>这种是consecutive模式，执行不确定数量的插入语句时，才会去申请表级别的auto_increment锁，<br>执行确定数量的插入语句时，只需要执行前去获取 AUTO_INCREMENT 计数器的互斥锁并在获取主键后直接释放，<br>不需要等待当前语句执行完成。</p><p>innodb_autoinc_lock_mode为2<br>交叉模式 所有的插入语句都不需要获取表级别的 AUTO_INCREMENT 锁，<br>如果binlog_format为statement模式，如果从服务器上的计数器的值可能会与主服务器不一致，<br>可能会有同一行数据在主从数据库上id不一样的情况，如果binlog_format为row模式，那么就不影响。</p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>意向锁定的主要目的是表明有人正在锁定表中的行，或者打算锁定表中的行。意向锁的作用主要在于，当一个事务去申请表级别的排斥锁X，共享锁S时，需要去判断是否有其他事务在修改数据行，或者让数据行处于只读状态。假如没有意向锁，可能需要查询每一行数据，判断是否加了行锁。而如果有意向锁的情况下，可以快速进行判断，只需要判断当前表是否有加意向锁就可以了，减小了性能开销。</p><p><strong>意向共享锁（IS锁）</strong></p><p>事务让一行数据只能读，需要申请对这行数据加行级别的锁共享锁S，在申请S锁之前会主动申请表级别的共享意向锁IS锁。</p><p><strong>意向排斥锁(IX锁)</strong></p><p>事务在更新某一行数据时，需要申请对这行数据加行级别的锁排斥锁X，在申请X锁之前会申请IX</p><p>意向锁之间是兼容的，IS锁和IX是兼容，因为可能我们对第一行数据加S锁，那么会申请IS锁，对第二行数据加X锁，此时跟第一行的数据的S锁不冲突，所以也会先申请IX锁，由此可见，IS锁和IX之间不冲突，IS锁，IX锁与行级别的S，行级别的X之间也不冲突。</p><p>意向锁只是跟表级别的S，X锁可能会冲突，</p><p>场景1：假设一个事务要加表级别的S锁，让整个表只能被读。那么如果当前有意向锁IX，说明有其他事务在改数据，那么不能加，只能进行等待，等事务改完是否意向锁IX。</p><p>场景2：假设当前事务要加表级别的S锁时，让整个表只能被读。只有IS意向锁，没有IX锁，说明只是有其他事务在让数据只能被读取，不能被修改，那么加表级别S锁，也不会其他事务造成影响。</p><p>场景3：假设当前事务要加表级别的X锁时，让整个表只能被这个事务写，不能被其他事务读。如果现在有其他事务加了意向读锁IS，说明有其他事务在让一些数据行只能被读，或者是一些写锁IX，说明其他事务让一些数据行正在被修改。那么当前要加表级别的X锁就不行，会跟其他事务冲突，只能等其他事务执行完毕才能申请成功。</p><table><thead><tr><th></th><th>表级别的S锁</th><th>表级别的X锁</th></tr></thead><tbody><tr><td>意向读锁IS</td><td>兼容</td><td>不兼容</td></tr><tr><td>意向写锁IX</td><td>不兼容</td><td>不兼容</td></tr></tbody></table><h4 id="那么意向锁的作用是什么呢？"><a href="#那么意向锁的作用是什么呢？" class="headerlink" title="那么意向锁的作用是什么呢？"></a>那么意向锁的作用是什么呢？</h4><p>假如没有意向锁，我们执行lock table read命令来申请表锁，让整个表只能读，在获得表级别的只读锁之前，需要执行的步骤是：</p><p>1.数据库会先判断当前表是否加了表级别的排斥锁，因为这个时候要是加了排斥锁，是只能由加了那个排斥锁的事务来更新数据，其他事务都不能读数据，只能阻塞等待。</p><p>2.如果当前表没有加表级别的排斥锁，那么就需要对每一行数据进行判断，判断是否加了行级别的X锁，如果加了只能阻塞等待，这样需要对一行进行判断，性能开销太大了。</p><p>所以才有了意向锁，在获得表级别的只读锁之前，需要执行的步骤是：</p><p>1.第一步还是跟上面的步骤一一样</p><p>2.第二步只需要判断当前锁是否加了表级别的意向排斥锁，因为如果加了意向排斥锁，说明正在有事务在对数据加行锁，对数据进行更新，这样避免了对每一行数据进行判断，判断是否加了行锁。</p><h2 id="Innodb的锁"><a href="#Innodb的锁" class="headerlink" title="Innodb的锁"></a>Innodb的锁</h2><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul><li><p>共享锁 S锁，就是读锁，允许事务读一行数据，不能被修改。所以读锁之间不排斥</p></li><li><p>互斥锁 X锁，就是写锁，就是让当前事务可以修改这行数据，其他事务不能修改这行数据</p></li></ul><h3 id="记录锁-record-lock"><a href="#记录锁-record-lock" class="headerlink" title="记录锁 record lock"></a>记录锁 record lock</h3><p> 记录锁定是对单条索引记录的锁定。例如， <code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code> 可以防止从插入，更新或删除行。</p><h3 id="间隙锁-gap-lock"><a href="#间隙锁-gap-lock" class="headerlink" title="间隙锁 gap lock"></a>间隙锁 gap lock</h3><p>间隙锁就会对记录之间的间隙加锁，防止数据插入。就是我们在使用实时读(SELECT  FOR … UPDATE)或者更新，为了防止读的过程中有新的数据插入，会对我们读的数据的左右区间进行加锁，防止其他事务插入数据，所以间隙锁之间是不排斥的，间隙锁排斥的只是插入数据的操作。</p><h3 id="下一键锁-next-key-lock"><a href="#下一键锁-next-key-lock" class="headerlink" title="下一键锁 next-key lock"></a>下一键锁 next-key lock</h3><p> next-key lock就是会锁记录以及记录之间的间隙，就是 record lock 和 gap lock的组合，就是会对索引记录加记录锁 + 索引记录前面间隙上的锁”，就是对要更新的数据的左右两个端点加间隙锁，</p><p>例如num是一个普通索引，非唯一性索引，已有数据是1，5，10，20，30</p><p>那么 next-key lock可以锁定的区间是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(负无穷,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">(<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">(<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line"></span><br><span class="line">(<span class="number">30</span>,正无穷)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新操作</span></span><br><span class="line">update table set note = <span class="string">'1'</span> where num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//或者是使用实时读</span></span><br><span class="line">SELECT * FROM table WHERE num = <span class="number">10</span> <span class="keyword">for</span> UPDATE;</span><br></pre></td></tr></table></figure><p>如果num是唯一性索引，那么只需要对num为10的这条索引加锁就行了（就加一个Record lock锁），因为不用担心其他事务再插入一条num为10的数据，因为会有唯一性判断。但是如果num是非唯一性索引，为了防止事务执行过程中有num为10的数据插入，那么会对（5，10]和（10，20]这两个区间加锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;全局锁&quot;&gt;&lt;a href=&quot;#全局锁&quot; class=&quot;headerlink&quot; title=&quot;全局锁&quot;&gt;&lt;/a&gt;全局锁&lt;/h3&gt;&lt;p&gt;就是对整个数据库加锁，让整个数据库处于只读状态，所有更新操作停止。（如果是主库就不能执行更新语句，从库也不能执行同步过来的bin log）&lt;/p&gt;
&lt;p&gt;最常用的场景是对数据库加锁，让数据库只能读，然后对整个数据库做逻辑备份（就是将所有数据生成SQL写入备份文件。）&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="MySQL" scheme="http://www.tenpercent.top/tags/MySQL/"/>
    
      <category term="锁" scheme="http://www.tenpercent.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>一条MySQL更新语句的执行过程是什么样的</title>
    <link href="http://www.tenpercent.top/2019/08/20/%E4%B8%80%E6%9D%A1MySQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84/"/>
    <id>http://www.tenpercent.top/2019/08/20/一条MySQL更新语句的执行过程是什么样的/</id>
    <published>2019-08-19T16:00:00.000Z</published>
    <updated>2021-02-16T13:42:17.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一条MySQL更新语句的执行过程是什么样的"><a href="#一条MySQL更新语句的执行过程是什么样的" class="headerlink" title="一条MySQL更新语句的执行过程是什么样的"></a>一条MySQL更新语句的执行过程是什么样的</h2><h3 id="1-连接验证及解析"><a href="#1-连接验证及解析" class="headerlink" title="1.连接验证及解析"></a>1.连接验证及解析</h3><p>客户端与MySQL Server建立连接，发送语句给MySQL Server，接收到后如果是查询语句会先去查询缓存中看，有的话就直接返回了，（新版本的MySQL已经废除了查询缓存，命中率太低了），如果是缓存没有或者是非查询语句，会创建一个解析树，然后进行优化，（解析器知道语句是要执行什么，会评估使用各种索引的代价，然后去使用索引，以及调节表的连接顺序）然后调用innodb引擎的接口来执行语句。</p><h2 id="2-写undo-log"><a href="#2-写undo-log" class="headerlink" title="2.写undo log"></a>2.写undo log</h2><p>innodb 引擎首先开启事务，获得一个事务ID(是一直递增的)，根据执行的语句生成一个反向的语句，(如果是INSERT会生成一条DELETE语句，如果UPDATE语句就会生成一个UPDATE成旧数据的语句)，用于提交失败后回滚，将这条反向语句写入undo log，得到回滚指针，并且更新这个数据行的回滚指针和事务id。（事务提交后，Undo log并不能立马被删除，而是放入待清理的链表，由purge 线程判断是否有其他事务在使用undo 段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间，简单的说就是看之前的事务是否提交成功，这个事务及之前的事务都提交成功了，这部分undo log才能删除。）</p><h3 id="3-从索引中查找数据"><a href="#3-从索引中查找数据" class="headerlink" title="3.从索引中查找数据"></a>3.从索引中查找数据</h3><p>根据索引去B+树中找到这一行数据（如果是普通索引，查到不符合条件的索引，会把所有数据查找出来，唯一性索引查到第一个数据就可以了）</p><h3 id="4-更新数据"><a href="#4-更新数据" class="headerlink" title="4.更新数据"></a>4.更新数据</h3><p>判断数据页是否在内存中？</p><h3 id="4-1数据页在内存中"><a href="#4-1数据页在内存中" class="headerlink" title="4.1数据页在内存中"></a>4.1数据页在内存中</h3><p>索引是普通索引还是唯一性索引？</p><h4 id="4-1-1普通索引"><a href="#4-1-1普通索引" class="headerlink" title="4.1.1普通索引"></a>4.1.1普通索引</h4><p>直接更新内存中的数据页</p><h4 id="4-1-2唯一性索引"><a href="#4-1-2唯一性索引" class="headerlink" title="4.1.2唯一性索引"></a>4.1.2唯一性索引</h4><p>判断更新后是否会数据冲突(不能破坏索引的唯一性)，不会的话就更新内存中的数据页。</p><h3 id="4-2-数据页不在内存中"><a href="#4-2-数据页不在内存中" class="headerlink" title="4.2 数据页不在内存中"></a>4.2 数据页不在内存中</h3><p>索引是普通索引还是唯一性索引？</p><h4 id="4-2-1普通索引"><a href="#4-2-1普通索引" class="headerlink" title="4.2.1普通索引"></a>4.2.1普通索引</h4><p>将对数据页的更新操作记录到change buffer，暂时不更新到磁盘。change buffer会在空闲时异步更新到磁盘。</p><h4 id="4-2-2-唯一性索引"><a href="#4-2-2-唯一性索引" class="headerlink" title="4.2.2 唯一性索引"></a>4.2.2 唯一性索引</h4><p>因为需要保证更新后的唯一性，所以不能延迟更新，必须把数据页从磁盘加载到内存，然后判断更新后是否会数据冲突，不会的话就更新数据页。</p><h3 id="5-写undo-log（prepare状态）"><a href="#5-写undo-log（prepare状态）" class="headerlink" title="5.写undo log（prepare状态）"></a>5.写undo log（prepare状态）</h3><p>将对数据页的更改写入到redo log，将redo log设置为prepare状态。</p><h3 id="6-写bin-log（commit状态）"><a href="#6-写bin-log（commit状态）" class="headerlink" title="6.写bin log（commit状态）"></a>6.写bin log（commit状态）</h3><p>通知MySQL server已经更新操作写入到redo log 了，随时可以提交，将执行的SQL写入到bin log日志，将redo log改成commit状态，事务提交成功。</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>主要是保证事务的原子性，事务执行失败就回滚，用于在事务执行失败后，对数据回滚。</p><p>是逻辑日志，记录的是SQL语句。</p><p>在事务提交后，undo log日志不会立即删除，会放到一个待删除的链表中，有purge线程判断是否有其他事务在使用上一个事务之前的版本信息，然后决定是否可以清理，简单的来说就是前面的事务都提交成功了，这些undo才能删除。</p><h4 id="change-buffer是什么？"><a href="#change-buffer是什么？" class="headerlink" title="change buffer是什么？"></a>change buffer是什么？</h4><p>（change buffer就是将更新数据页的操作缓存下来）</p><p>在更新数据时，如果数据行所在的数据页在内存中，直接更新内存中的数据页。</p><p>如果不在内存中，为了减少磁盘IO的次数，innodb会将这些更新操作缓存在change buffer中，在下一次查询时需要访问这个数据页时，在执行change buffer中的操作对数据页进行更新。（或者是在MySQL Server空闲时，会将change buffer中所有操作更新到磁盘，也就是俗称的‘刷页’。）</p><p>适合写多读少的场景，因为这样即便立即写了，也不太可能会被访问到，延迟更新可以减少磁盘I/O，只有普通索引会用到，因为唯一性索引，在更新时就需要判断唯一性，所以没有必要。</p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>就是为了保证事务的持久性，在做数据更新操作时，先将对数据页的更改记录到redo log，然后再去更新内存中的数据页，在下次查询数据页或者空闲时间，将操作记录更新到磁盘。这样可以将随机I/O改为顺序I/O。</p><p>优点是减少磁盘I/O次数，即便发生故障也可以根据redo log来将数据恢复到最新状态。</p><p>缺点是会造成内存脏页，后台线程会自动对脏页刷盘，或者是淘汰数据页时刷盘，此时会暂时查询操作，影响查询。</p><h3 id="二段提交制"><a href="#二段提交制" class="headerlink" title="二段提交制"></a>二段提交制</h3><p>更新时，先改内存中的数据页，将更新操作写入redo log日志，此时redo log进入prepare状态，然后通知MySQL Server执行完了，随时可以提交，MySQL Server将更新的SQL写入bin log，然后调用innodb接口将redo log设置为提交状态，更新完成。</p><p>如果只是写了bin log就提交，那么忽然发生故障，主节点可以根据redo log恢复数据到最新，但是主从同步时会丢掉这部分更新的数据。</p><p>如果只是写binlog，然后写redo log，如果忽然发生故障，主节点根据redo log恢复数据时就会丢掉这部分数据。</p><h4 id="崩溃恢复时的判断规则（以redolog是否commit或者binlog是否完整来确定）"><a href="#崩溃恢复时的判断规则（以redolog是否commit或者binlog是否完整来确定）" class="headerlink" title="崩溃恢复时的判断规则（以redolog是否commit或者binlog是否完整来确定）"></a>崩溃恢复时的判断规则（以redolog是否commit或者binlog是否完整来确定）</h4><ol><li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；</li><li>如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：<br>a. 如果是，则提交事务；<br>b. 否则，回滚事务。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一条MySQL更新语句的执行过程是什么样的&quot;&gt;&lt;a href=&quot;#一条MySQL更新语句的执行过程是什么样的&quot; class=&quot;headerlink&quot; title=&quot;一条MySQL更新语句的执行过程是什么样的&quot;&gt;&lt;/a&gt;一条MySQL更新语句的执行过程是什么样的&lt;/
      
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="MySQL" scheme="http://www.tenpercent.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>深入 Nginx 之架构篇</title>
    <link href="http://www.tenpercent.top/2019/03/26/depth-nginx/"/>
    <id>http://www.tenpercent.top/2019/03/26/depth-nginx/</id>
    <published>2019-03-25T16:00:00.000Z</published>
    <updated>2021-02-16T13:13:56.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在读 Nginx 相关的书籍，做一下读书笔记。</p><p>Nginx 作为业界知名的高性能服务器，被广泛的应用。它的高性能正是由于其优秀的架构设计，其架构主要包括这几点：模块化设计、事件驱动架构、请求的多阶段异步处理、管理进程与多工作进程设计、内存池的设计，以下内容依次进行说明。</p><a id="more"></a><h2 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h2><p>高度模块化的设计是 Nginx 的架构基础。在 Nginx 中，除了少量的核心代码，其他一切皆为模块。</p><p>所有模块间是分层次、分类别的，Nginx 官方共有五大类型的模块：核心模块、配置模块、事件模块、HTTP 模块、mail 模块。它们之间的关系如下：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20190220142626.png" alt></p><p>在这 5 种模块中，配置模块和核心模块是与 Nginx 框架密切相关的。而事件模块则是 HTTP 模块和 mail 模块的基础。HTTP 模块和 mail 模块的“地位”类似，它们都是更关注于应用层面。</p><h2 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h2><p>事件驱动架构，简单的说就是由一些事件发生源来产生事件，由事件收集器来收集、分发事件，然后由事件处理器来处理这些事件（事件处理器需要先在事件收集器里注册自己想处理的事件）。</p><p>对于 Nginx 服务器而言，一般由网卡、磁盘产生事件，Nginx 中的事件模块将负责事件的收集、分发操作；而所有的模块都可能是事件消费者，它们首先需要向事件模块注册感兴趣的事件类型，这样，在有事件产生时，事件模块会把事件分发到相应的模块中进行处理。</p><p>对于传统 web 服务器（如 Apache）而言，采用的所谓事件驱动往往局限在 TCP 连接建立、关闭事件上，一个连接建立以后，在其关闭之前的所有操作都不再是事件驱动，这时会退化成按顺序执行每个操作的批处理模式，这样每个请求在连接建立后都将始终占用着系统资源，直到关闭才会释放资源。这种请求占用着服务器资源等待处理的模式会造成服务器资源极大的浪费。如下图所示，传统 web 服务器往往把一个进程或线程作为时间消费者，当一个请求产生的事件被该进程处理时，直到这个请求处理结束时，进程资源都将被这一请求所占用。比较典型的例子如 Apache 同步阻塞的多进程模式就是这样的。</p><p>传统 web 服务器处理事件的简单模型（矩形代表进程）:<br><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20190220195312.png" alt></p><p>Nginx 采用事件驱动架构处理业务的方式与传统的 web 服务器是不同的。它不使用进程或者线程来作为事件消费者，所谓的事件消费者只能是某个模块。只有事件收集、分发器才有资格占用进程资源，它们会在分发某个事件时调用事件消费模块使用当前占用的进程资源，如下图所示，该图中列出了 5 个不同的事件，在事件收集、分发者进程的一次处理过程中，这 5 个事件按照顺序被收集后，将开始使用当前进程分发事件，从而调用相应的事件消费者来处理事件。当然，这种分发、调用也是有序的。</p><p>Nginx 处理事件的简单模型：<br><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20190220201030.png" alt></p><p>由上图可以看出，处理请求事件时，Nginx 的事件消费者只是被事件分发者进程短期调用而已，这种设计使得网络性能、用户感知的请求时延都得到了提升，每个用户的请求所产生的事件会及时响应，整个服务器的网络吞吐量都会由于事件的及时响应而增大。当然，这也带来一定的要求，即每个事件消费者都不能有阻塞行为，否则将会由于长时间占用事件分发者进程而导致其他事件得不到及时响应，Nginx 的非阻塞特性就是由于它的模块都是满足这个要求的。</p><h2 id="请求的多阶段异步处理"><a href="#请求的多阶段异步处理" class="headerlink" title="请求的多阶段异步处理"></a>请求的多阶段异步处理</h2><p>多阶段异步处理请求与事件驱动架构是密切相关的，也就是说，请求的多阶段异步处理只能基于事件驱动架构实现。多阶段异步处理就是把一个请求的处理过程按照事件的触发方式划分为多个阶段，每个阶段都可以由事件收集、分发器来触发。</p><p>处理获取静态文件的 HTTP 请求时切分的阶段及各阶段的触发事件如下所示：<br><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20190221171304.png" alt></p><p>这个例子中，该请求大致分为 7 个阶段，这些阶段是可以重复发生的，因此，一个下载静态资源请求可能会由于请求数据过大，网速不稳定等因素而被分解为成百上千个上图所列出的阶段。</p><p>异步处理和多阶段是相辅相成的，只有把请求分为多个阶段，才有所谓的异步处理。当一个时间被分发到事件消费者中进行处理时，事件消费者处理完这个事件只相当于处理完 1 个请求的阶段。什么时候可以处理下一个阶段呢？这只能等待内核的通知，即当下一次事件出现时，epoll 等事件分发器将会获取到通知，然后去调用事件消费者进行处理。</p><h2 id="管理进程、多工作进程设计"><a href="#管理进程、多工作进程设计" class="headerlink" title="管理进程、多工作进程设计"></a>管理进程、多工作进程设计</h2><p>Nginx 在启动后，会有一个 master 进程和多个 worker 进程。master 进程主要用来管理worker 进程，包括接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态以及启动 worker 进程。 worker 进程是用来处理来自客户端的请求事件。多个 worker 进程之间是对等的，它们同等竞争来自客户端的请求，各进程互相独立，一个请求只能在一个 worker 进程中处理。worker 进程的个数是可以设置的，一般会设置与机器 CPU 核数一致，这里面的原因与事件处理模型有关。Nginx 的进程模型，可由下图来表示：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20190217223753.png" alt></p><p>在服务器上查看 Nginx 进程：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20190217223806.png" alt></p><p>这种设计带来以下优点：</p><p>1） 利用多核系统的并发处理能力</p><p>现代操作系统已经支持多核 CPU 架构，这使得多个进程可以分别占用不同的 CPU 核心来工作。Nginx 中所有的 worker 工作进程都是完全平等的。这提高了网络性能、降低了请求的时延。</p><p>2） 负载均衡</p><p>多个 worker 工作进程通过进程间通信来实现负载均衡，即一个请求到来时更容易被分配到负载较轻的 worker 工作进程中处理。这也在一定程度上提高了网络性能、降低了请求的时延。</p><p>3） 管理进程会负责监控工作进程的状态，并负责管理其行为</p><p>管理进程不会占用多少系统资源，它只是用来启动、停止、监控或使用其他行为来控制工作进程。首先，这提高了系统的可靠性，当 worker 进程出现问题时，管理进程可以启动新的工作进程来避免系统性能的下降。其次，管理进程支持 Nginx 服务运行中的程序升级、配置项修改等操作，这种设计使得动态可扩展性、动态定制性较容易实现。</p><h2 id="内存池的设计"><a href="#内存池的设计" class="headerlink" title="内存池的设计"></a>内存池的设计</h2><p>为了避免出现内存碎片，减少向操作系统申请内存的次数、降低各个模块的开发复杂度，Nginx 设计了简单的内存池，它的作用主要是把多次向系统申请内存的操作整合成一次，这大大减少了 CPU 资源的消耗，同时减少了内存碎片。</p><p>因此，通常每一个请求都有一个简易的独立内存池（如每个 TCP 连接都分配了一个内存池），而在请求结束时则会销毁整个内存池，把曾经分配的内存一次性归还给操作系统。这种设计大大提高了模块开发的简单些，因为在模块申请内存后不用关心它的释放问题；而且因为分配内存次数的减少使得请求执行的时延得到了降低。同时，通过减少内存碎片，提高了内存的有效利用率和系统可处理的并发连接数，从而增强了网络性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在读 Nginx 相关的书籍，做一下读书笔记。&lt;/p&gt;
&lt;p&gt;Nginx 作为业界知名的高性能服务器，被广泛的应用。它的高性能正是由于其优秀的架构设计，其架构主要包括这几点：模块化设计、事件驱动架构、请求的多阶段异步处理、管理进程与多工作进程设计、内存池的设计，以下内容依次进行说明。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://www.tenpercent.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nginx" scheme="http://www.tenpercent.top/tags/Nginx/"/>
    
      <category term="架构" scheme="http://www.tenpercent.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>深入 Nginx 之配置篇</title>
    <link href="http://www.tenpercent.top/2019/03/15/learn-nginx-configuration/"/>
    <id>http://www.tenpercent.top/2019/03/15/learn-nginx-configuration/</id>
    <published>2019-03-14T16:00:00.000Z</published>
    <updated>2021-02-16T13:13:44.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h2><p>在工作中，我们与 Nginx 打交道更多的是通过其配置文件来进行。那么掌握这些配置项各自的作用就很有必要了。</p><p>首先，nginx.conf 的内容通常是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">...              </span><br><span class="line">...        #核心摸块</span><br><span class="line"></span><br><span class="line">events &#123;        #事件模块</span><br><span class="line"> </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;     # http 模块</span><br><span class="line"></span><br><span class="line">    server &#123;      # server块</span><br><span class="line">     </span><br><span class="line">        location [PATTERN] &#123;  # location块</span><br><span class="line">        </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] &#123;</span><br><span class="line">        </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mail &#123;     # mail 模块</span><br><span class="line"> </span><br><span class="line"> server &#123;    # server块</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>我们依次看一下每个模块一般有哪些配置项：</p><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user admin; #配置用户或者组。</span><br><span class="line"></span><br><span class="line">worker_processes 4; #允许生成的进程数，默认为1 </span><br><span class="line"></span><br><span class="line">pid /nginx/pid/nginx.pid; #指定 nginx 进程运行文件存放地址 </span><br><span class="line"></span><br><span class="line">error_log log/error.log debug; #错误日志路径，级别。</span><br></pre></td></tr></table></figure><h3 id="事件模块"><a href="#事件模块" class="headerlink" title="事件模块"></a>事件模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">events &#123; </span><br><span class="line">accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on </span><br><span class="line"></span><br><span class="line">multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off </span><br><span class="line"></span><br><span class="line">use epoll; #事件驱动模型select|poll|kqueue|epoll|resig</span><br><span class="line"></span><br><span class="line">worker_connections 1024; #最大连接数，默认为512</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;   #文件扩展名与文件类型映射表</span><br><span class="line">    </span><br><span class="line">    default_type  application/octet-stream; #默认文件类型，默认为text/plain</span><br><span class="line">    </span><br><span class="line">    access_log off; #取消服务日志    </span><br><span class="line"></span><br><span class="line">    sendfile on;   #允许 sendfile 方式传输文件，默认为off，可以在http块，server块，location块。</span><br><span class="line">    </span><br><span class="line">    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br><span class="line">    </span><br><span class="line">    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。</span><br><span class="line"></span><br><span class="line">    server </span><br><span class="line">    &#123;</span><br><span class="line">    keepalive_requests 120; #单连接请求上限次数。</span><br><span class="line">    </span><br><span class="line">    listen 80; #监听端口</span><br><span class="line">    </span><br><span class="line">    server_name  127.0.0.1;   #监听地址      </span><br><span class="line">    </span><br><span class="line">    index index.html index.htm index.php;</span><br><span class="line">    </span><br><span class="line">    root your_path;  #根目录</span><br><span class="line">  </span><br><span class="line">location ~ \.php$</span><br><span class="line">&#123;</span><br><span class="line">  fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;</span><br><span class="line">  </span><br><span class="line">  #fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">  </span><br><span class="line">  fastcgi_index index.php;</span><br><span class="line">  </span><br><span class="line">  include fastcgi_params;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置项解析"><a href="#配置项解析" class="headerlink" title="配置项解析"></a>配置项解析</h2><ul><li><p>worker_processes</p><p>worker_processes 用来设置 Nginx 服务的进程数。该值推荐使用 CPU 内核数。</p></li><li><p>worker_cpu_affinity</p><p>worker_cpu_affinity 用来为每个进程分配CPU的工作内核，参数有多个二进制值表示，每一组代表一个进程，每组中的每一位代表该进程使用CPU的情况，1代表使用，0代表不使用。所以我们使用 worker_cpu_affinity 0001 0010 0100 1000;来让进程分别绑定不同的核上。默认情况下worker进程不绑定在任何一个CPU上。</p></li><li><p>worker_rlimit_nofile</p><p>设置毎个进程的最大文件打开数。如果不设的话上限就是系统的 ulimit –n的数字，一般为65535。</p></li><li><p>worker_connections</p><p>设置一个进程理论允许的最大连接数，理论上越大越好，但不可以超过 worker_rlimit_nofile 的值。</p></li><li><p>use epoll</p><p>设置事件驱动模型使用 epoll。epoll 是 Nginx 支持的高性能事件驱动库之一。是公认的非  常优秀的事件驱动模型。</p></li><li><p>accept_mutex  off</p><p>关闭网络连接序列化，当其设置为开启的时候，将会对多个 Nginx 进程接受连接进行序列化，防止多个进程对连接的争抢。当服务器连接数不多时，开启这个参数会让负载有一定程度的降低。但是当服务器的吞吐量很大时，为了效率，请关闭这个参数；并且关闭这个参数的时候也可以让请求在多个 worker 间的分配更均衡。所以我们设置 accept_mutex off;</p></li><li><p>multi_accept  on </p><p>设置一个进程可同时接受多个网络连接</p></li><li><p>Sendfile on</p><p>Sendfile是 Linux2.0 以后的推出的一个系统调用,它能简化网络传输过程中的步骤，提高服务器性能。<br>不用 sendfile的传统网络传输过程：硬盘 &gt;&gt; kernel buffer &gt;&gt; user buffer &gt;&gt; kernel socket buffer &gt;&gt; 协议栈</p><p>用 sendfile()来进行网络传输的过程：<br>硬盘 &gt;&gt; kernel buffer (快速拷贝到 kernelsocket buffer) &gt;&gt; 协议栈</p></li><li><p>tcp_nopush on</p><p>设置数据包会累积一下再一起传输，可以提高一些传输效率。 tcp_nopush 必须和 sendfile 搭配使用。</p></li><li><p>tcp_nodelay on</p><p>小的数据包不等待直接传输。默认为on。看上去是和 tcp_nopush 相反的功能，但是两边都为 on 时 nginx 也可以平衡这两个功能的使用。</p></li><li><p>keepalive_timeout</p><p>HTTP 连接的持续时间。设的太长会使无用的线程变的太多。这个根据服务器访问数量、处理速度以及网络状况方面考虑。 </p></li><li><p>send_timeout</p><p>设置 Nginx 服务器响应客户端的超时时间，这个超时时间只针对两个客户端和服务器建立连接后，某次活动之间的时间，如果这个时间后，客户端没有任何活动，Nginx服务器将关闭连接</p></li><li><p>gzip on</p><p>启用 gzip，对响应数据进行在线实时压缩,减少数据传输量。</p></li><li><p>gzip_disable “msie6”</p><p>Nginx服务器在响应这些种类的客户端请求时，不使用 Gzip 功能缓存应用数据，gzip_disable “msie6”对IE6浏览器的数据不进行 GZIP 压缩。</p></li></ul><p>常用的配置项大致这些，对于不同的业务场景，有的需要额外的其他配置项，这里不做展开。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>http 配置里有 location 这一项，它是用来根据请求中的 uri 来为其匹配相应的处理规则。</p><h3 id="location-查找规则"><a href="#location-查找规则" class="headerlink" title="location 查找规则"></a>location 查找规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">location  = / &#123;</span><br><span class="line">  # 精确匹配 / ，主机名后面不能带任何字符串</span><br><span class="line">  [ config A ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location  / &#123;</span><br><span class="line">  # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求</span><br><span class="line">  # 但是正则和最长字符串会优先匹配</span><br><span class="line">  [ config B ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /documents/ &#123;</span><br><span class="line">  # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索</span><br><span class="line">  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span><br><span class="line">  [ config C ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /documents/Abc &#123;</span><br><span class="line">  # 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索</span><br><span class="line">  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span><br><span class="line">  [ config CC ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">  # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。</span><br><span class="line">  [ config D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">  # 匹配所有以 gif,jpg或jpeg 结尾的请求</span><br><span class="line">  # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则</span><br><span class="line">  [ config E ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images/ &#123;</span><br><span class="line">  # 字符匹配到 /images/，继续往下，会发现 ^~ 存在</span><br><span class="line">  [ config F ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images/abc &#123;</span><br><span class="line">  # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在</span><br><span class="line">  # F与G的放置顺序是没有关系的</span><br><span class="line">  [ config G ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /images/abc/ &#123;</span><br><span class="line">  # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用</span><br><span class="line">    [ config H ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正则查找优先级从高到低依次如下：</p><p>“ = ” 开头表示精确匹配，如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。</p><p>“ ^~ ” 开头表示uri以某个常规字符串开头，不是正则匹配</p><p>“ ~ ” 开头表示区分大小写的正则匹配;</p><p>“ ~* ”开头表示不区分大小写的正则匹配</p><p>“ / ” 通用匹配, 如果没有其它匹配,任何请求都会匹配到</p><h3 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h3><p>Nginx 的负载均衡需要用到 upstream 模块，可通过以下配置来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream test-upstream &#123;</span><br><span class="line">    ip_hash; # 使用 ip_hash 算法分配</span><br><span class="line"> </span><br><span class="line">    server 192.168.1.1; # 要分配的 ip</span><br><span class="line">    server 192.168.1.2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">location / &#123;   </span><br><span class="line">    proxy_pass http://test-upstream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子定义了一个 test-upstream 的负载均衡配置，通过 proxy_pass 反向代理指令将请求转发给该模块进行分配处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常用配置项&quot;&gt;&lt;a href=&quot;#常用配置项&quot; class=&quot;headerlink&quot; title=&quot;常用配置项&quot;&gt;&lt;/a&gt;常用配置项&lt;/h2&gt;&lt;p&gt;在工作中，我们与 Nginx 打交道更多的是通过其配置文件来进行。那么掌握这些配置项各自的作用就很有必要了。&lt;/p&gt;
&lt;p&gt;首先，nginx.conf 的内容通常是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;... 	       #核心摸块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;events &amp;#123;        #事件模块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http &amp;#123;     # http 模块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    server &amp;#123;      # server块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        location [PATTERN] &amp;#123;  # location块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        location [PATTERN] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    server &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mail &amp;#123;     # mail 模块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 server &amp;#123;    # server块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	      ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://www.tenpercent.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nginx" scheme="http://www.tenpercent.top/tags/Nginx/"/>
    
      <category term="配置" scheme="http://www.tenpercent.top/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java 如何解决可见性和有序性</title>
    <link href="http://www.tenpercent.top/2019/02/27/Java%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7/"/>
    <id>http://www.tenpercent.top/2019/02/27/Java如何解决可见性和有序性/</id>
    <published>2019-02-26T16:00:00.000Z</published>
    <updated>2021-02-16T13:15:10.525Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道导致可见性的原因是缓存，导致有序性的原因是编译优化。那解决可见性和有序性的办法就是禁用缓存和禁用编译优化了，不过我们都知道缓存和编译优化的目的是为了提高 CPU 的效率从而提高程序的性能，所以不能完全禁止，折中的方案就是按需禁用缓存和编译优化。</p><p>那么，如何进行按需禁用呢？</p><p>对于这个问题，Java 提供了 Java 内存模型（JMM）这个方案来解决。</p><a id="more"></a><h2 id="Java-内存模型的抽象结构"><a href="#Java-内存模型的抽象结构" class="headerlink" title="Java 内存模型的抽象结构"></a>Java 内存模型的抽象结构</h2><p>在 Java 中，所有实例域，静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。方法定义参数和异常处理器参数以及方法内定义的变量这些局部变量则存在调用栈里。由于每个线程与自己的调用栈是一一对应的，所以局部变量不会在线程之间共享，它们不会有内存可见性问题。</p><p>Java 线程间的通信由 Java 内存模型（JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系，其示意图如下：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20200504113735.png" alt></p><p>即线程间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程所读写的共享变量的副本。</p><p>本地内存是 JMM 的一个抽象概念，并不是真实的存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><p>从上图看，如果线程 A 与线程B之间要通信的话，必须要经历下面2个步骤。</p><p>1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。</p><p>2）线程B到主内存中去读取线程A之前已更新过的共享变量。</p><p>示例过程如下所示：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20200504113809.png" alt></p><p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要 经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 Java 程序员提供内存可见性保证。</p><h2 id="volatile、synchronized-关键字的语义以及-Happens-Before-规则"><a href="#volatile、synchronized-关键字的语义以及-Happens-Before-规则" class="headerlink" title="volatile、synchronized 关键字的语义以及 Happens-Before 规则"></a>volatile、synchronized 关键字的语义以及 Happens-Before 规则</h2><p>有了 JMM 后，如何让程序员在编程中根据 Java 给出的“约定”来实现遵循 JMM 机制的程序呢？就是通过 volatile、synchronized 和 final 这三个关键字原语来实现，以及与之配套的 Happens-Before 规则。</p><h3 id="volatile-的内存语义"><a href="#volatile-的内存语义" class="headerlink" title="volatile 的内存语义"></a>volatile 的内存语义</h3><p>当一个变量被设为 volatile 后，线程对该变量的写会及时的刷新到主内存中，而当另一个线程读取该变量的时候，JMM 会把该线程对应的本地内存置为无效而从主内存中读取最新的变量正确值。从而实现线程间的通信。（注：线程写 volatile 变量后刷新到内存的操作是对线程自身整个本地内存的刷新，不仅仅是只对 volatile 变量进行刷新，所以如果该线程在写 volatile 变量前也对其他变量做了修改，则其他变量也会一并被刷新到主内存中，这个体现在 Happens-Before 规则里）</p><h3 id="synchronized-的内存语义"><a href="#synchronized-的内存语义" class="headerlink" title="synchronized 的内存语义"></a>synchronized 的内存语义</h3><p>synchronized 即锁，锁是 Java 并发中最重要的同步机制。其内存语义其实与 volatile 是有点类似的，当线程释放锁的时候，JMM 会把该线程对应的本地内存中的所有共享变量刷新到主内存中（与线程写 volatile 变量类似）。当线程获取锁时，JMM 会把该线程对应的本地内存置为无效，并从主内存中获取所需共享变量的值（与读 volatile 变量类似），从而实现线程间通信。</p><h3 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h3><ul><li>程序顺序规则</li></ul><p>一个线程中的每个操作，happens-before 于该线程中的任意后续操作。这是是遵循顺序一致性规则，比较好理解。</p><ul><li>监视器锁规则</li></ul><p>对一个锁的解锁，happens-before 于随后对这个锁的加锁。由上面 synchronized 的内存语义可知，当对一个锁解锁的时候，该线程会将本地内存里的共享变量刷新到主内存里，随后加锁时，线程会从主内存读取最新的数据，所以解锁后的共享变量是对后面进行加锁的线程是可见的。</p><ul><li>volatile变量规则</li></ul><p>对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。这个根据上面 volatile 的内存语义也是很好理解。</p><ul><li>传递性：</li></ul><p>如果A happens-before B，且B happens-before C，那么A happens-before C。</p><ul><li>start()规则</li></ul><p>如果线程 A 执行操作 ThreadB.start()（启动线程B），那么A线程的 ThreadB.start() 操作 happens-before 于线程B中的任意操作。<br>这条规则怎么理解呢？我们可以参考上面 volatile 和 synchronized 内存语义的本质，就是及时的将本地内存的共享变量刷新到主内存里，而其他线程从主内存进行读数据。</p><p>所以本条规则的本质我的理解是当线程调用 ThreadB.start()去启动别的线程时，线程会先将本地内存的共享变量刷新到主内存里，被 start 的线程则会将自己本地内存置为无效，从主内存里获取最新共享变量。</p><ul><li>join()规则</li></ul><p>如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的所有操作完成后，线程 A 都能看到。</p><p>与上一条类似，这条规则可以这么理解：当主线程调用了子线程的 join 后，子线程在执行完成后，会将自己本地内存刷新到主内存里，而主线程则会将自己本地内存置为无效，从主内存里获取最新的共享变量。从而实现了子线程的所有操作对主线程可见。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于如何解决可见性和有序性的问题上，Java 使用内存模型（JMM）这个解决方案，通过内存模型来进行按需的禁用缓存和编译优化，JMM 屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为程序员呈现了一个一致的内存模型。同时，Java 也提供了相应的原语和 Happens-Before 规则来让程序员可以按照它的规定进行编写满足要求的程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道导致可见性的原因是缓存，导致有序性的原因是编译优化。那解决可见性和有序性的办法就是禁用缓存和禁用编译优化了，不过我们都知道缓存和编译优化的目的是为了提高 CPU 的效率从而提高程序的性能，所以不能完全禁止，折中的方案就是按需禁用缓存和编译优化。&lt;/p&gt;
&lt;p&gt;那么，如何进行按需禁用呢？&lt;/p&gt;
&lt;p&gt;对于这个问题，Java 提供了 Java 内存模型（JMM）这个方案来解决。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JAVA" scheme="http://www.tenpercent.top/tags/JAVA/"/>
    
      <category term="并发" scheme="http://www.tenpercent.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>为什么并发编程会产生 bug</title>
    <link href="http://www.tenpercent.top/2019/02/20/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BC%9A%E4%BA%A7%E7%94%9F%20bug/"/>
    <id>http://www.tenpercent.top/2019/02/20/为什么并发编程会产生 bug/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2021-02-16T13:15:25.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文结构"><a href="#本文结构" class="headerlink" title="本文结构"></a>本文结构</h2><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20200417233239.png" alt></p><a id="more"></a><h2 id="为什么需要并发编程"><a href="#为什么需要并发编程" class="headerlink" title="为什么需要并发编程"></a>为什么需要并发编程</h2><p>我们都知道计算机的核心组成 CPU，内存，I/O 设备的运行速度差异是很大的，它们间的速度是 CPU &gt;&gt; 内存 &gt;&gt; I/O，CPU 和内存的速度差异就如同天上一天和地上一年的差别。而内存和 I/O 设备的速度差异就更大了，相当于天上一天与地上十年的区别。</p><p>而程序里大部分语句都要访问内存和 I/O，所以一段程序执行的性能是取决于最慢的那部分的执行速度——即读写 I/O 设备。 所以，如何合理的平衡这三者的速度差异来使程序运行的最快呢？ 这就需要从计算机体系结构，操作系统，编译程序这些方面进行优化了。目前计算机科学界的大佬们对在这些方面做出的优化主要有以下几点：</p><p>1、 CPU 增加了缓存，用来缓存常用的内存数据或地址，以均衡与内存的速度差异；</p><p>2、操作系统增加了进程、线程，用来对 CPU 进行分时复用，进而均衡 CPU 与 I/O 设备的速度差异；</p><p>3、编译程序优化指定执行次序，使得缓存能够得到更加合理的利用。</p><p>这几点的优化在一定程度上大大提升了程序的运行速度，但是相应的也产生了并发程序的一些问题，也就是并发编程可能会出现的 bug。</p><h2 id="为什么会产生-bug"><a href="#为什么会产生-bug" class="headerlink" title="为什么会产生 bug"></a>为什么会产生 bug</h2><p>首先，我们需要定义一下这个 bug 是什么样的 bug。</p><p>并发编程，所引起的问题，其本质 bug 就是对某个资源的操作没有</p><h3 id="原因一：CPU-缓存带来可见性问题"><a href="#原因一：CPU-缓存带来可见性问题" class="headerlink" title="原因一：CPU 缓存带来可见性问题"></a>原因一：CPU 缓存带来可见性问题</h3><p>在单核的 CPU 中，所有的线程都是在一颗 CPU 上执行，因为所有线程都是操作同一块缓存和内存，所以不同线程对缓存的写，是互相透明的。</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20200417125147.png" alt></p><p>但是在多核时代，每个 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就不容易保证了。当多个线程在不同的 CPU 上执行时，这些线程操作的是不同 CPU 的缓存，如下图：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20200417125505.png" alt></p><p>线程 A 操作的是 CPU-1 上缓存，而线程 B 操作的是 CPU-2 上的缓存，这个时候，线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。举个例子，假设变量 V 初始值为 0，线程 A 从内存读取变量 V 到 CPU 中并缓存起来，随后线程 A 对变量 V + 1 并更新缓存，而此时，线程 B 也从 内存读取变量 V，然后也开始执行 +1 操作并进行更新缓存；这样当线程 A 把变量 V 的值从缓存写入到内存里后，变量 V 的值为 1，而当线程 B 也将变量 V 写入到缓存时，变量 V 的值也是 1，最终就是变量 V 虽然被两个线程分别执行了两次 +1 操作，但是其最终的值却是 1，而不是我们期望的正确值 2。这就是可见性引起的问题。</p><h3 id="原因二：线程切换带来的原子性问题"><a href="#原因二：线程切换带来的原子性问题" class="headerlink" title="原因二：线程切换带来的原子性问题"></a>原因二：线程切换带来的原子性问题</h3><p>我们都知道 Unix 采用分时复用的方式，即通过对线程进行调度切换来提高 CPU 的利用率</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20200417132339.png" alt></p><p>由于我们现在编程基本都是使用高级语言，高级语言里的一条语句往往需要多条 CPU 指令完成。例如 count += 1, 至少需要三条 CPU 指令。</p><p>指令 1： 将变量 count 从内存加载到 CPU 的寄存器；</p><p>指令 2： 在寄存器中执行 +1 操作</p><p>指令 3： 将结果写入缓存</p><p>而操作系统在线程切换时，可以发送在任何一条 <strong>CPU 指令</strong> 执行完，而高级语言里的一条语句。对于上面的三条指令来说，假设 count 为 0, 如果线程 A 在指令 1 执行完后做线程切换，线程 B 开始执行三条指令后，即将 count 的值 +1 并写入了缓存了，这时再切换回线程 A，由于线程 A 在前面已经执行了指令 1，线程 A 里的 count 值是 0，此时再去执行指令 2 和指令 3，最后线程 A 执行完后，count 的值依然为 1。即 count 变量分别被两个线程获取并进行了 +1 的操作，但是最终的结果是 1 而不是我们所期望的正确值 2。这就是线程切换引起的问题。</p><p>上述过程示意图如下：</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20200417133508.png" alt></p><h3 id="原因三：编译优化带来的有序性问题"><a href="#原因三：编译优化带来的有序性问题" class="headerlink" title="原因三：编译优化带来的有序性问题"></a>原因三：编译优化带来的有序性问题</h3><p>编译优化是指当我们的程序进行编译后，编译器为了优化性能，有时候会改变程序中语句的先后顺序。例如 “a = 1; b = 2;”  编译器优化后可能变成“b = 2, a = 1”。</p><p>在 Java 领域一个经典的案例就是利用双重检查创建单例对象。在实现单例的时候，首先判断 instance 是不是为空，如果为空进入同步代码块初始化 instance，否而直接返回 instance。初始化 instance 时再次判断 instance 是否为空，避免了在进入同步代码块这段时间有线程抢先一步完成了 instance 初始化。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;       </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种单例的实现方式，看似在提高效率的同时，做到了天衣无缝。其实不然，因为 instance = new Singleton (); 这一行代码会被编译为三条指令，正常指令顺序如下：</p><p>1、为 instance 分配一块内存 A</p><p>2、在分配的内存 A 上初始化 instance 实例</p><p>3、把内存 A 的地址赋值给 instance 变量</p><p>而编译器优化后可能会变成：</p><p>1、为 instance 分配一块内存 A</p><p>2、把内存 A 的地址赋值给 instance 变量</p><p>3、在分配的内存 A 上初始化 instance 实例</p><p>上面的顺序调换在单线程环境下是没有问题的，但是在多线程的情况下，假如线程 A 正在初始化 instance，此时执行完第 2 步，正在执行第三步。而线程 B 执行到 if (instance == null) 的判断，那么线程 B 就会直接得到未初始化好的 instance，而此时线程 B 使用此 instance 显然是有问题的。</p><p>要解决本例的有序性问题很简单，我们只需要为 instance 声明时增加 volatile 关键字，volatile 修饰的变量是会保证读操作一定能读到写完的值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要写好并发程序，首先要知道并发程序的问题在哪，是因为什么引起的。并发程序问题的产生主要是由可见性，原子性，有序性这三方面引起。</p><p>此外，上面所提到的缓存，线程，编译优化的目的与我们写并发程序的目的是相同的，都是提高程序性能。但是，从这里我们可以看到，技术在解决一个问题的时候，很难有完美的解决方案，往往是解决了问题的同时也会带来另外的问题。所以在采用一项新技术的同时，一定要清楚它能解决什么问题，可能带来什么问题，以及如何进行规避。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;本文结构&quot;&gt;&lt;a href=&quot;#本文结构&quot; class=&quot;headerlink&quot; title=&quot;本文结构&quot;&gt;&lt;/a&gt;本文结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20200417233239.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JAVA" scheme="http://www.tenpercent.top/tags/JAVA/"/>
    
      <category term="并发" scheme="http://www.tenpercent.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁</title>
    <link href="http://www.tenpercent.top/2019/01/23/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://www.tenpercent.top/2019/01/23/乐观锁与悲观锁/</id>
    <published>2019-01-22T16:00:00.000Z</published>
    <updated>2021-02-16T13:12:54.303Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。</p></blockquote><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><a id="more"></a><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p><h3 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h3><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p><h2 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h2><blockquote><p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong></p></blockquote><h3 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h3><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>举一个简单的例子：</strong><br>假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号（ version=1 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号（ version=1 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ol><p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p><h3 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h3><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p><ul><li>需要读写的内存值 V </li><li>进行比较的值 A </li><li>拟写入的新值 B</li></ul><p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p><p>关于自旋锁，大家可以看一下这篇文章，非常不错：<a href="https://blog.csdn.net/qq_34337272/article/details/81252853" target="_blank" rel="noopener">《<br>面试必备之深入理解自旋锁》</a></p><h2 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h2><blockquote><p> ABA 问题是乐观锁一个常见的问题</p></blockquote><h3 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h3><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题。</strong></p><p>JDK 1.5 以后的 <code>AtomicStampedReference 类</code>就提供了此种能力，其中的 <code>compareAndSet 方法</code>就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h3 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h3><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p><h3 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h3><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p><h2 id="CAS与-synchronized-的使用情景"><a href="#CAS与-synchronized-的使用情景" class="headerlink" title="CAS与 synchronized 的使用情景"></a>CAS与 synchronized 的使用情景</h2><blockquote><p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p></blockquote><ol><li>对于资源竞争较少（线程冲突较轻）的情况，使用<code>synchronized</code>同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li></ol><p>补充： Java并发编程这个领域中<code>synchronized</code>关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。<code>synchronized</code>的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;乐观锁&quot;&gt;&lt;a href=&quot;#乐观锁&quot; class=&quot;headerlink&quot; title=&quot;乐观锁&quot;&gt;&lt;/a&gt;乐观锁&lt;/h3&gt;&lt;p&gt;总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（&lt;strong&gt;共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程&lt;/strong&gt;）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;ReentrantLock&lt;/code&gt;等独占锁就是悲观锁思想的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JAVA" scheme="http://www.tenpercent.top/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 的反射机制</title>
    <link href="http://www.tenpercent.top/2018/11/23/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.tenpercent.top/2018/11/23/反射机制/</id>
    <published>2018-11-22T16:00:00.000Z</published>
    <updated>2021-02-16T13:02:01.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射机制介绍"><a href="#反射机制介绍" class="headerlink" title="反射机制介绍"></a>反射机制介绍</h2><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><a id="more"></a><h2 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a>获取 Class 对象的四种方式</h2><p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p><p>1.知道具体类的情况下可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass = TargetObject.class;</span><br></pre></td></tr></table></figure><p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取Class对象不会进行初始化</p><p>2.通过 <code>Class.forName()</code>传入类的路径获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass1 = Class.forName(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br></pre></td></tr></table></figure><p>Class.forName(className)方法，内部实际调用的是一个native方法  forName0(className, true, ClassLoader.getClassLoader(caller), caller);</p><p>第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。</p><p>一旦初始化，就会触发目标对象的 static块代码执行，static参数也会被再次初始化。</p><p>3.通过对象实例<code>instance.getClass()</code>获取：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">Class alunbarClass2 = e.getClass();</span><br></pre></td></tr></table></figure></p><p>4.通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clazz</span> </span>= ClassLoader.LoadClass(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br></pre></td></tr></table></figure></p><p>通过类加载器获取Class对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p><strong>简单用代码演示一下反射的一些操作!</strong></p><p>1.创建一个我们要使用反射操作的类 <code>TargetObject</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value = <span class="string">"JavaGuide"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethod</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I love "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"value is "</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用反射操作这个类的方法以及参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取TargetObject类的Class对象并且创建TargetObject类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; tagetClass = Class.forName(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br><span class="line">        TargetObject targetObject = (TargetObject) tagetClass.newInstance();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取所有类中所有定义的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method[] methods = tagetClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定方法并调用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method publicMethod = tagetClass.getDeclaredMethod(<span class="string">"publicMethod"</span>,</span><br><span class="line">                String.class);</span><br><span class="line"></span><br><span class="line">        publicMethod.invoke(targetObject, <span class="string">"JavaGuide"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定参数并对参数进行修改</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Field field = tagetClass.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//为了对类中的参数进行修改我们取消安全检查</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(targetObject, <span class="string">"JavaGuide"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 private 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method privateMethod = tagetClass.getDeclaredMethod(<span class="string">"privateMethod"</span>);</span><br><span class="line">        <span class="comment">//为了调用private方法我们取消安全检查</span></span><br><span class="line">        privateMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publicMethod</span><br><span class="line">privateMethod</span><br><span class="line">I love JavaGuide</span><br><span class="line">value is JavaGuide</span><br></pre></td></tr></table></figure><p><strong>注意</strong> : 有读者提到上面代码运行会抛出 <code>ClassNotFoundException</code> 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 <code>TargetObject</code> 所在的包 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; tagetClass = Class.forName(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br></pre></td></tr></table></figure><h2 id="静态编译和动态编译"><a href="#静态编译和动态编译" class="headerlink" title="静态编译和动态编译"></a>静态编译和动态编译</h2><ul><li><strong>静态编译：</strong> 在编译时确定类型，绑定对象</li><li><strong>动态编译：</strong> 运行时确定类型，绑定对象</li></ul><h2 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h2><ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</li></ul><h2 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h2><p><strong>反射是框架设计的灵魂。</strong></p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p><p>举例：</p><ol><li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li><li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li><li>动态配置实例的属性；</li><li>……</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;反射机制介绍&quot;&gt;&lt;a href=&quot;#反射机制介绍&quot; class=&quot;headerlink&quot; title=&quot;反射机制介绍&quot;&gt;&lt;/a&gt;反射机制介绍&lt;/h2&gt;&lt;p&gt;JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JAVA" scheme="http://www.tenpercent.top/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>谈谈 JDK 代理和 CGLIB 代理</title>
    <link href="http://www.tenpercent.top/2018/09/23/JDK%20%E4%BB%A3%E7%90%86%E5%92%8C%20CGLIB%20%E4%BB%A3%E7%90%86/"/>
    <id>http://www.tenpercent.top/2018/09/23/JDK 代理和 CGLIB 代理/</id>
    <published>2018-09-22T16:00:00.000Z</published>
    <updated>2021-02-16T12:56:36.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h2><p>在讲JDK 代理和 CGLIB 代理前需要先了解代理模式。<br>代理模式是一种比较简单的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p><p>代理分为静态代理和动态代理两种。</p><a id="more"></a><h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（<em>后面会具体演示代码</em>），非常不灵活（<em>比如接口一旦新增加方法，目标对象和代理对象都要进行修改</em>）且麻烦(<em>需要对每个目标类都单独写一个代理类</em>)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p><p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p><p>静态代理实现步骤:</p><ol><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li></ol><p>下面通过代码展示！</p><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send message:"</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before method send()"</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after method send()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">        SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">"java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure><p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p><h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p><p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p><p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p><p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p><p>就 Java 来说，动态代理的实现方式比较常见的就是 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>。</p><h3 id="3-1-JDK-动态代理机制"><a href="#3-1-JDK-动态代理机制" class="headerlink" title="3.1. JDK 动态代理机制"></a>3.1. JDK 动态代理机制</h3><h4 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1. 介绍"></a>3.1.1. 介绍</h4><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p><p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法一共有 3 个参数：</p><ol><li><strong>loader</strong> :类加载器，用于加载代理对象。</li><li><strong>interfaces</strong> : 被代理类实现的一些接口；</li><li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li></ol><p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invoke()</code> 方法有下面三个参数：</p><ol><li><strong>proxy</strong> :动态生成的代理类</li><li><strong>method</strong> : 与代理类对象调用的方法相对应</li><li><strong>args</strong> : 当前 method 方法的参数</li></ol><p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><h4 id="3-1-2-JDK-动态代理类使用步骤"><a href="#3-1-2-JDK-动态代理类使用步骤" class="headerlink" title="3.1.2. JDK 动态代理类使用步骤"></a>3.1.2. JDK 动态代理类使用步骤</h4><ol><li>定义一个接口及其实现类；</li><li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li></ol><h4 id="3-1-3-代码示例"><a href="#3-1-3-代码示例" class="headerlink" title="3.1.3. 代码示例"></a>3.1.3. 代码示例</h4><p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send message:"</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.定义一个 JDK 动态代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before method "</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after method "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p><p><strong>4.获取代理对象的工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> DebugInvocationHandler(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p><p><strong>5.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> SmsServiceImpl());</span><br><span class="line">smsService.send(<span class="string">"java"</span>);</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure><h3 id="3-2-CGLIB-动态代理机制"><a href="#3-2-CGLIB-动态代理机制" class="headerlink" title="3.2. CGLIB 动态代理机制"></a>3.2. CGLIB 动态代理机制</h3><h4 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1. 介绍"></a>3.2.1. 介绍</h4><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p><p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p><p><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm" target="_blank" rel="noopener">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p><p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p><p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>obj</strong> :被代理的对象（需要增强的对象）</li><li><strong>method</strong> :被拦截的方法（需要增强的方法）</li><li><strong>args</strong> :方法入参</li><li><strong>methodProxy</strong> :用于调用原始方法</li></ol><p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p><h4 id="3-2-2-CGLIB-动态代理类使用步骤"><a href="#3-2-2-CGLIB-动态代理类使用步骤" class="headerlink" title="3.2.2. CGLIB 动态代理类使用步骤"></a>3.2.2. CGLIB 动态代理类使用步骤</h4><ol><li>定义一个类；</li><li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li></ol><h4 id="3-2-3-代码示例"><a href="#3-2-3-代码示例" class="headerlink" title="3.2.3. 代码示例"></a>3.2.3. 代码示例</h4><p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1.实现一个使用阿里云发送短信的类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliSmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send message:"</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before method "</span> + method.getName());</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after method "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.获取代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> DebugMethodInterceptor());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">"java"</span>);</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure><h3 id="3-3-JDK-动态代理和-CGLIB-动态代理对比"><a href="#3-3-JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="3.3. JDK 动态代理和 CGLIB 动态代理对比"></a>3.3. JDK 动态代理和 CGLIB 动态代理对比</h3><ol><li><strong>JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ol><h2 id="4-静态代理和动态代理的对比"><a href="#4-静态代理和动态代理的对比" class="headerlink" title="4. 静态代理和动态代理的对比"></a>4. 静态代理和动态代理的对比</h2><ol><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-代理模式&quot;&gt;&lt;a href=&quot;#1-代理模式&quot; class=&quot;headerlink&quot; title=&quot;1. 代理模式&quot;&gt;&lt;/a&gt;1. 代理模式&lt;/h2&gt;&lt;p&gt;在讲JDK 代理和 CGLIB 代理前需要先了解代理模式。&lt;br&gt;代理模式是一种比较简单的设计模式。简单来说就是 &lt;strong&gt;我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代理分为静态代理和动态代理两种。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JAVA" scheme="http://www.tenpercent.top/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能监控工具</title>
    <link href="http://www.tenpercent.top/2018/07/10/Linux-performance-monitor/"/>
    <id>http://www.tenpercent.top/2018/07/10/Linux-performance-monitor/</id>
    <published>2018-07-09T16:00:00.000Z</published>
    <updated>2019-03-06T06:46:54.671Z</updated>
    
    <content type="html"><![CDATA[<p>最近了解了下 Linux 性能相关的东西，主要是如何查看服务器性能的一些工具，在这里做个记录，以后遇到相关使用场景的时候，方便查看。</p><h3 id="Linux-性能指标"><a href="#Linux-性能指标" class="headerlink" title="Linux 性能指标"></a>Linux 性能指标</h3><ul><li>CPU</li></ul><p>CPU利用率、用户时间（表示CPU在用户进程上的时间百分比）、系统时间（表示CPU花在内核操作上的时间百分比）、空闲时间、平均负载、阻塞、上下文切换、中断等</p><ul><li>内存</li></ul><p>空闲内存、Swap利用率、缓冲和缓存、活动和非活动内存等</p><ul><li>磁盘IO</li></ul><p>IO等待、平均队列长度、每秒传输（TPS）等</p><ul><li>网络</li></ul><p>接收和发送的包、每秒碰撞（各个网络接口所连接网络的所发生的冲突数量）、丢包、错误等</p><a id="more"></a><h3 id="监测工具"><a href="#监测工具" class="headerlink" title="监测工具"></a>监测工具</h3><p>以下是对 Linux 的性能进行监控的常用工具：</p><table><thead><tr><th style="text-align:center">工具</th><th>简介</th></tr></thead><tbody><tr><td style="text-align:center">top</td><td>查看进程活动状态以及一些系统状况</td></tr><tr><td style="text-align:center">vmstat</td><td>查看系统状态、硬件和系统信息等</td></tr><tr><td style="text-align:center">iostat</td><td>查看 CPU 负载、硬盘状况</td></tr><tr><td style="text-align:center">sar</td><td>综合工具，查看系统状况</td></tr><tr><td style="text-align:center">mpstat</td><td>查看多处理器状况</td></tr><tr><td style="text-align:center">netstat</td><td>查看网络状况</td></tr><tr><td style="text-align:center">iptraf</td><td>实时网络状态监测</td></tr><tr><td style="text-align:center">tcpdump</td><td>抓取网络数据包，详细分析</td></tr><tr><td style="text-align:center">tcptrace</td><td>网络包分析工具</td></tr><tr><td style="text-align:center">netperf</td><td>网络带宽工具</td></tr><tr><td style="text-align:center">dstat</td><td>综合了 vmstat、iostat、ifstat、netstat 等多个信息</td></tr></tbody></table><p>这里介绍其中几个。</p><h3 id="top-工具"><a href="#top-工具" class="headerlink" title="top 工具"></a>top 工具</h3><p>top是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20180725153253005740341.png" alt="20180725153253005740341.png"> </p><p>PID：进程的ID </p><p>USER：进程所有者 </p><p>PR：进程的优先级别，越小越优先被执行 </p><p>NI：nice值 </p><p>VIRT：进程占用的虚拟内存 </p><p>RES：进程占用的物理内存 </p><p>SHR：进程使用的共享内存 </p><p>S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数 </p><p>%CPU：进程占用CPU的使用率 </p><p>%MEM：进程使用的物理内存和总内存的百分比 </p><p>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。 </p><p>COMMAND：进程启动命令名称</p><h3 id="vmstat-工具"><a href="#vmstat-工具" class="headerlink" title="vmstat 工具"></a>vmstat 工具</h3><p>vmstat 是个查看系统整体性能的小工具，小巧，即使在机器负载很高的情况下也运行良好，并且可以用时间间隔采集得到连续的性能数据。</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/2018072515325286132815.png" alt="2018072515325286132815.png"></p><p>参数介绍：</p><ul><li>r，可运行队列的线程数，这些线程都是可运行状态，只不过 CPU 暂时不可用</li><li>b，被 blocked 的进程数，正在等待 IO 请求</li><li>in，被处理过的中断数</li><li>cs，系统上正在做上下文切换的数目</li><li>us，用户占用 CPU 的百分比</li><li>sys，内核和中断占用 CPU 的百分比</li><li>wa，所有可运行的线程被 blocked 以后都在等待 IO，这时候 CPU 空闲的百分比</li><li>id，CPU 完全空闲的百分比</li></ul><p>举两个例子来分析一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 4  0    140 2915476 341288 3951700  0    0     0     0 1057  523 89 21  0  0  0</span><br><span class="line"> 4  0    140 2915724 341296 3951700  0    0     0     0 1048  546 79 11  0  0  0</span><br><span class="line"> 4  0    140 2915848 341296 3951700  0    0     0     0 1044  514 88 22  0  0  0</span><br><span class="line"> 4  0    140 2915848 341296 3951700  0    0     0    24 1044  564 80 20  0  0  0</span><br><span class="line"> 4  0    140 2915848 341296 3951700  0    0     0     0 1060  546 78 12  0  0  0</span><br></pre></td></tr></table></figure><p>从上面的数据可以看出几点：</p><ol><li>interrupts(in) 非常高，context switch(cs) 比较低，说明这个 CPU 一直在不停的请求资源</li><li>user time(us) 一直保持在 80% 以上，而且上下文切换较低 (cs)，说明某个进程可能一直霸占着 CPU</li></ol><ul><li>run queue(r) 刚好在 4 个</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line">14  0    140 2904316 341912 3952308  0    0     0   460 1106 9593 36 64  1  0  0</span><br><span class="line">17  0    140 2903492 341912 3951780  0    0     0     0 1037 9614 35 65  1  0  0</span><br><span class="line">20  0    140 2902016 341912 3952000  0    0     0     0 1046 9739 35 64  1  0  0</span><br><span class="line">17  0    140 2903904 341912 3951888  0    0     0    76 1044 9879 37 63  0  0  0</span><br><span class="line">16  0    140 2904580 341912 3952108  0    0     0     0 1055 9808 34 65  1  0  0</span><br></pre></td></tr></table></figure><p>从上面的数据可以看出几点：</p><ol><li>context switch(cs) 比 interrupts(in) 要高的多，说明内核不得不来回切换进程</li><li>进一步观察发现 system time(sy) 很高而 user time(us) 很低，而且加上高频度的上下文切换 (cs)，说明正在运行的应用程序调用了大量的系统调用</li><li>run queue(r) 在 14 个线程以上，而这个机器的硬件配置 (4 核），应该保持在 12 以内。</li></ol><h3 id="iostat-工具"><a href="#iostat-工具" class="headerlink" title="iostat 工具"></a>iostat 工具</h3><p>iostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。iostat属于sysstat软件包。可以用yum install sysstat 直接安装。</p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20180725153253123443993.png" alt="20180725153253123443993.png"></p><p>cpu属性值说明：</p><p>%user：CPU处在用户模式下的时间百分比。</p><p>%nice：CPU处在带NICE值的用户模式下的时间百分比。</p><p>%system：CPU处在系统模式下的时间百分比。</p><p>%iowait：CPU等待输入输出完成时间的百分比。</p><p>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</p><p>%idle：CPU空闲时间百分比。</p><p><strong>如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。</strong></p><p>disk属性值说明：</p><p>rrqm/s:  每秒进行 merge 的读操作数目。即 rmerge/s</p><p>wrqm/s:  每秒进行 merge 的写操作数目。即 wmerge/s</p><p>r/s:  每秒完成的读 I/O 设备次数。即 rio/s</p><p>w/s:  每秒完成的写 I/O 设备次数。即 wio/s</p><p>rsec/s:  每秒读扇区数。即 rsect/s</p><p>wsec/s:  每秒写扇区数。即 wsect/s</p><p>rkB/s:  每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</p><p>wkB/s:  每秒写K字节数。是 wsect/s 的一半。</p><p>avgrq-sz:  平均每次设备I/O操作的数据大小 (扇区)。</p><p>avgqu-sz:  平均I/O队列长度。</p><p>await:  平均每次设备I/O操作的等待时间 (毫秒)。</p><p>svctm: 平均每次设备I/O操作的服务时间 (毫秒)。</p><p>%util:  一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</p><p><strong>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。</strong></p><p><strong>如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；</strong></p><p><strong>如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。</strong></p><p><strong>如果avgqu-sz比较大，也表示有大量io在等待。</strong></p><ul><li>sar 工具</li></ul><p>sar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。</p><ul><li>查看 cpu使用率</li></ul><p><strong>sar -u</strong></p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20180726153257950431065.png" alt="20180726153257950431065.png"></p><p>%user 用户模式下消耗的CPU时间的比例；</p><p>%nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例</p><p>%system 系统模式下消耗的CPU时间的比例；</p><p>%iowait CPU等待磁盘I/O导致空闲状态消耗的时间比例；</p><p>%steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例；</p><p>%idle CPU空闲时间比例；</p><p><strong>查看平均负载</strong></p><p><strong>sar -q</strong></p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20180726153257961321989.png" alt="20180726153257961321989.png"></p><p>runq-sz：运行队列的长度（等待运行的进程数）</p><p>plist-sz：进程列表中进程（processes）和线程（threads）的数量</p><p>ldavg-1：最后1分钟的系统平均负载</p><p>ldavg-5：过去5分钟的系统平均负载</p><p>ldavg-15：过去15分钟的系统平均负载</p><p><strong>查看内存使用状况</strong></p><p><strong>sar -r</strong></p><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20180726153257975922020.png" alt="20180726153257975922020.png"></p><p>kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</p><p>kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</p><p>%memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.</p><p>kbbuffers和kbcached：这两个值就是free命令中的buffer和cache.</p><p>kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</p><p>%commit：这个值是kbcommit与内存总量(包括swap)的一个百分比.</p><p><strong>sar参数说明</strong></p><p>-A 汇总所有的报告</p><p>-a 报告文件读写使用情况</p><p>-B 报告附加的缓存的使用情况</p><p>-b 报告缓存的使用情况</p><p>-c 报告系统调用的使用情况</p><p>-d 报告磁盘的使用情况</p><p>-g 报告串口的使用情况</p><p>-h 报告关于buffer使用的统计数据</p><p>-m 报告IPC消息队列和信号量的使用情况</p><p>-n 报告命名cache的使用情况</p><p>-p 报告调页活动的使用情况</p><p>-q 报告运行队列和交换队列的平均长度</p><p>-R 报告进程的活动情况</p><p>-r 报告没有使用的内存页面和硬盘块</p><p>-u 报告CPU的利用率</p><p>-v 报告进程、i节点、文件和锁表状态</p><p>-w 报告系统交换活动状况</p><p>-y 报告TTY设备活动状况</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近了解了下 Linux 性能相关的东西，主要是如何查看服务器性能的一些工具，在这里做个记录，以后遇到相关使用场景的时候，方便查看。&lt;/p&gt;
&lt;h3 id=&quot;Linux-性能指标&quot;&gt;&lt;a href=&quot;#Linux-性能指标&quot; class=&quot;headerlink&quot; title=&quot;Linux 性能指标&quot;&gt;&lt;/a&gt;Linux 性能指标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU利用率、用户时间（表示CPU在用户进程上的时间百分比）、系统时间（表示CPU花在内核操作上的时间百分比）、空闲时间、平均负载、阻塞、上下文切换、中断等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;空闲内存、Swap利用率、缓冲和缓存、活动和非活动内存等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘IO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IO等待、平均队列长度、每秒传输（TPS）等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接收和发送的包、每秒碰撞（各个网络接口所连接网络的所发生的冲突数量）、丢包、错误等&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://www.tenpercent.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://www.tenpercent.top/tags/Linux/"/>
    
      <category term="工具" scheme="http://www.tenpercent.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>AOP 学习总结</title>
    <link href="http://www.tenpercent.top/2018/05/19/AOP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.tenpercent.top/2018/05/19/AOP 学习笔记/</id>
    <published>2018-05-18T16:00:00.000Z</published>
    <updated>2021-02-16T12:41:05.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOP-简述"><a href="#AOP-简述" class="headerlink" title="AOP 简述"></a>AOP 简述</h2><p>AOP，面向切面编程。其实并不是什么很深奥的理论，就是当你想在做完某个操作后，希望在这个操作的发生前，发生后，返回值后等等场景里，进行一些相应的操作时，不需要每次都要重复的写一遍相应的操作，而是把这些操作定义成一个切面，通过定义好相应的切点后，在操作发生时，由框架帮你把你所定义好的切面织入进来，从而让你再开发的过程中，只需要聚焦于业务即可，而不用每次去处理很多重复的细节。</p><h2 id="AOP-的用处"><a href="#AOP-的用处" class="headerlink" title="AOP 的用处"></a>AOP 的用处</h2><p>AOP 最典型的应用是在数据库事务的管控中。比如要保存用户时，需要连同用户的角色一并保存如数据库，此时，用 OOP 无法完成这样的事务操作，而 AOP 可以完成这些事情。</p><a id="more"></a><h2 id="AOP-开发细节"><a href="#AOP-开发细节" class="headerlink" title="AOP 开发细节"></a>AOP 开发细节</h2><h3 id="确定连接点"><a href="#确定连接点" class="headerlink" title="确定连接点"></a>确定连接点</h3><p>AOP 需要有连接点，即在什么时候触发。在 Spring 中就是某个类里的某个方法。</p><h3 id="开发切面"><a href="#开发切面" class="headerlink" title="开发切面"></a>开发切面</h3><p>切面用来描述各个过程中需要做什么，用 @Aspect 注解来定义切面。用 @Before、@After、@AfterReturning、@AfterThrowing 等注解来表示各个过程。</p><h3 id="定义切点"><a href="#定义切点" class="headerlink" title="定义切点"></a>定义切点</h3><p>Spring 里 定义了切点（Pointcut）的概念，切点的作用就是向 Spring 描述哪个类的哪个方法需要启用 AOP 编程。在切面里，切点的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.xxx.xxx.xxxImpl.xxxfunction(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>代码中，用 @Pointcut 来定义切点，标注在 pointcut 方法上。 切点里的正则式含义如下：</p><ul><li>execution 表示在执行的时候，拦截里面的正则匹配方法</li><li><ul><li>号表示任意返回类型的方法</li></ul></li><li>com.xxx.xxx.xxxImpl 指定目标对象类的全限定名称</li><li>xxxfunction 指定目标对象类里的方法</li><li>(..)表示任意参数进行匹配</li></ul><h3 id="引入，增加切面"><a href="#引入，增加切面" class="headerlink" title="引入，增加切面"></a>引入，增加切面</h3><p>加入某个切面非自己提供的，不能修改它，而想对它进行补充的时候，Spring 允许通过为这个切面引入新的接口来增强这个切面的功能。<br>步骤如下：</p><p>1、 先定义需要引入的新接口</p><p>2、在切面里，通过 @DeclareParents 注解来引入，它有两个必须配置的属性 value 和 defaultImpl。</p><ul><li>value: 指向你要增强功能的目标对象类</li><li>defaultImpl: 引入增强功能的类，即引入的接口的实现类。</li></ul><h2 id="多个切面"><a href="#多个切面" class="headerlink" title="多个切面"></a>多个切面</h2><p>spring 支持多个切面的运行。在组织多个切面时，需要指定各个切面运行的顺序。</p><p>SPring 提供了 @Order 注解 和 Orderd 接口两种方式来指定切面的顺序。 实际使用中，用 @Order 比较方便，使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AOP-简述&quot;&gt;&lt;a href=&quot;#AOP-简述&quot; class=&quot;headerlink&quot; title=&quot;AOP 简述&quot;&gt;&lt;/a&gt;AOP 简述&lt;/h2&gt;&lt;p&gt;AOP，面向切面编程。其实并不是什么很深奥的理论，就是当你想在做完某个操作后，希望在这个操作的发生前，发生后，返回值后等等场景里，进行一些相应的操作时，不需要每次都要重复的写一遍相应的操作，而是把这些操作定义成一个切面，通过定义好相应的切点后，在操作发生时，由框架帮你把你所定义好的切面织入进来，从而让你再开发的过程中，只需要聚焦于业务即可，而不用每次去处理很多重复的细节。&lt;/p&gt;
&lt;h2 id=&quot;AOP-的用处&quot;&gt;&lt;a href=&quot;#AOP-的用处&quot; class=&quot;headerlink&quot; title=&quot;AOP 的用处&quot;&gt;&lt;/a&gt;AOP 的用处&lt;/h2&gt;&lt;p&gt;AOP 最典型的应用是在数据库事务的管控中。比如要保存用户时，需要连同用户的角色一并保存如数据库，此时，用 OOP 无法完成这样的事务操作，而 AOP 可以完成这些事情。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JAVA" scheme="http://www.tenpercent.top/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Spring 的 IOC 学习总结</title>
    <link href="http://www.tenpercent.top/2018/05/12/IOC%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://www.tenpercent.top/2018/05/12/IOC 学习总结/</id>
    <published>2018-05-11T16:00:00.000Z</published>
    <updated>2021-02-16T12:40:42.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IOC-描述"><a href="#IOC-描述" class="headerlink" title="IOC 描述"></a>IOC 描述</h2><p>IOC —— Inversion of control，即控制反转。还有个别名叫 DI（Dependency inject 依赖注入）。</p><ul><li>定义</li></ul><p>所谓 IoC ，就是由 IoC 容器来负责对象的生命周期和对象之间的关系。</p><ul><li>最初的时候</li></ul><p>在最早我们使用对象的时候，都是在用到的时候 new 一个，这个会存在一个问题：不灵活。</p><p>即当某个类里依赖着某个 new 出来的对象的时候，在后续的使用中，如果需要换个依赖的对象了，需要去修改类里的代码。</p><h2 id="IOC-的用处"><a href="#IOC-的用处" class="headerlink" title="IOC 的用处"></a>IOC 的用处</h2><p>用 IOC 的用处就是可以避免在类里依赖着某个指定对象时直接使用 new 这样的强耦合情况。</p><p>IOC 容器存放着对象，管理着依赖关系。当某个类需要什么对象时，只要声明好它对应的依赖，IOC 容器就会自动找到其所依赖的对象进行注入。</p><p>所以这就是控制反转：有传统的直接 new 的方式来主动控制到变成由 IOC 容器来控制进行对象的注入</p><h2 id="Spring-里的-IOC-实现"><a href="#Spring-里的-IOC-实现" class="headerlink" title="Spring 里的 IOC 实现"></a>Spring 里的 IOC 实现</h2><h3 id="Spring-的-IOC-容器"><a href="#Spring-的-IOC-容器" class="headerlink" title="Spring 的 IOC 容器"></a>Spring 的 IOC 容器</h3><p>Spring IOC 容器是一个管理 Bean 的容器，Spring 里所有的 IOC 容器都需要实现 BeanFactory 接口，它是一个顶级容器接口。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansExcept 工 on ;</span><br><span class="line"><span class="keyword">import</span> org.springframework . core.ResolvableType ; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前缀</span></span><br><span class="line">String FACTORY BEAN PREFIX = <span class="string">"&amp;”; //多个 getBean 方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Object getBean(String name) throws BeansException;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;T&gt; T getBean(String 口ame, Class&lt;T&gt; requiredType) throws Bea口sExcept工on;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Object getBean(String name, Object . . args) throws BeansException ;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;T&gt; T getBea口( Class&lt;T&gt; requiredType , Object ... args) throws BeansExcept工on;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//是否包含 Bean</span></span><br><span class="line"><span class="string">boolean containsBean (String name); II Bean是否单例</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">boolean isS工ngleton(String name) throws NoSuchBeanDefinitionExcept工on ; II Bean是否原型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">boolean isPrototype(String name) throws NoSuchBeanDefinitionException;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//是否类型匹配</span></span><br><span class="line"><span class="string">bool ean isTypeMatch(String name , ResolvableType typeToMatch) throws NoSuchBeanDefin工tionException;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">boolean isTypeMatch(String name , Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefin工tionException;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//获取 Bean 的类型</span></span><br><span class="line"><span class="string">Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinit工onException ;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//获取 Bean 的别名</span></span><br><span class="line"><span class="string">String[] getAliases(String name);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到上面代码中有多个getBean方法，这也是IoC容器最重要的方法之一， 它的意义是从 IoC 容器中获取 Beano 而从多个 getBean 方法中可 以看到有按类型( by type)获取 Bean 的，也有按 名称( by name)获取 Bean 的，这就意味着在 Spring IoC 容器中 ，允许我们按类型或者名称获取 Bean。</p><p>由于 BeanFactory 的功能还不够强大，因此 Spring在 BeanFactory 的基础上， 还设计了一个更为高级的接口 ApplicationContext。 它是 BeanFactory 的子接口之一 ， 在 Spring 的体 系中 BeanFactory 和 ApplicationContext 是最为重要的接口设计 ，在现实中我们使用的大部分Spring IoC 容器是 ApplicationContext接口的实现类</p><h3 id="装配-bean-至容器中"><a href="#装配-bean-至容器中" class="headerlink" title="装配 bean 至容器中"></a>装配 bean 至容器中</h3><ul><li>通过扫描装配，即使用 @Component 注解和 @ComponentScan </li></ul><ul><li>用 @Bean 注解来实现装配，对某个方法直接使用 @Bean 注解来将其返回的对象注入到容器里</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IOC-描述&quot;&gt;&lt;a href=&quot;#IOC-描述&quot; class=&quot;headerlink&quot; title=&quot;IOC 描述&quot;&gt;&lt;/a&gt;IOC 描述&lt;/h2&gt;&lt;p&gt;IOC —— Inversion of control，即控制反转。还有个别名叫 DI（Dependency
      
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="PHP" scheme="http://www.tenpercent.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.tenpercent.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 泛型总结</title>
    <link href="http://www.tenpercent.top/2018/04/23/%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://www.tenpercent.top/2018/04/23/泛型总结/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2021-02-16T12:40:22.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T testname;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">testfunction</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">test</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需注意点：</p><ul><li>在声明类实现泛型接口时，若泛型参数未传入实参，则实现类也需要声明泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">one</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在声明类实现泛型接口时，若泛型参数有传入实参，则实现类里所有使用泛型的地方都需要声明对应的类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">implements</span> <span class="title">Test</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">one</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">test</span><span class="params">(T name)</span></span>&#123;</span><br><span class="line">System.out.print(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需注意点：</p><ul><li>泛型方法也可以定义在泛型类中，泛型方法里的泛型参数 T 不受泛型类的泛型参数 T 的影响，是独立的。</li><li>\&lt;T>用来声明该方法为泛型方法，\<t>只是一个代表符号，也可以用\<e> 或其他（ K,V 等）表达。</e></t></li><li>有了<t> 才可以在泛型方法的参数里声明参数泛型 T ，符号需保持一致，如<e> 对应 E。</e></t></li></ul><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><h3 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;? extends T&gt;</span><br></pre></td></tr></table></figure><p>需注意点：</p><ul><li>上界通配符只支持从通配类型里 get，而不支持将多种类型的 set 进去, 所以上界描述符Extends适合频繁读取的场景。</li></ul><p>原因是：</p><p>一个Plate&lt;? extends Fruit&gt;的引用，指向的可能是一个Plate类型的盘子，要往这个盘子里放Banana当然是不被允许的。一个理解是：Plate&lt;? extends Fruit&gt;代表某个只能放某种类型水果的盘子，而不是什么水果都能往里放的盘子</p><h3 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;? <span class="keyword">super</span> T&gt;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">需注意点：</span><br><span class="line"></span><br><span class="line">* 下界通配符&lt;? <span class="keyword">super</span> T&gt;不影响往里面存储，但是读取出来的数据只能是Object类型。</span><br><span class="line"></span><br><span class="line">原因是：</span><br><span class="line"></span><br><span class="line">下界通配符规定了元素最小的粒度，必须是T及其基类，那么我往里面存储T及其派生类都是可以的，因为它都可以隐式的转化为T类型。但是往外读就不好控制了，里面存储的都是T及其基类，无法转型为任何一种类型，只有Object基类才能装下。</span><br><span class="line"></span><br><span class="line">### PECS原则</span><br><span class="line"></span><br><span class="line">Effective Java书里的PECS原则。</span><br><span class="line"></span><br><span class="line">* 上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。</span><br><span class="line">* 下界&lt;? <span class="keyword">super</span> T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 无线通配符</span><br><span class="line"></span><br><span class="line">```java </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span>&lt;?&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型的擦除"><a href="#泛型的擦除" class="headerlink" title="泛型的擦除"></a>泛型的擦除</h2><p>泛型参数将会被擦除到它的第一个边界（边界可以有多个，重用 extends 关键字，通过它能给与参数类型添加一个边界）。编译器事实上会把类型参数替换为它的第一个边界的类型。如果没有指明边界，那么类型参数将被擦除到Object。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Test</span>&gt; </span>&#123;</span><br><span class="line">    T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extend关键字后后面的类型信息决定了泛型参数能保留的信息。Java类型擦除只会擦除到 Test 类型。</p><h3 id="泛型擦除的缺陷"><a href="#泛型擦除的缺陷" class="headerlink" title="泛型擦除的缺陷"></a>泛型擦除的缺陷</h3><p>泛型类型不能显式地运用在运行时类型的操作当中，例如：转型、instanceof 和 new。因为在运行时，所有参数的类型信息都丢失了。类似下面的代码都是无法通过编译的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> T) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        T <span class="keyword">var</span> = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        T[] array = (T) <span class="keyword">new</span> Object[SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;泛型类&quot;&gt;&lt;a href=&quot;#泛型类&quot; class=&quot;headerlink&quot; title=&quot;泛型类&quot;&gt;&lt;/a&gt;泛型类&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; T testname;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;testfunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;泛型接口&quot;&gt;&lt;a href=&quot;#泛型接口&quot; class=&quot;headerlink&quot; title=&quot;泛型接口&quot;&gt;&lt;/a&gt;泛型接口&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在声明类实现泛型接口时，若泛型参数未传入实参，则实现类也需要声明泛型&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyTest&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;在声明类实现泛型接口时，若泛型参数有传入实参，则实现类里所有使用泛型的地方都需要声明对应的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyTest&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;meta&quot;&gt;@override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JAVA" scheme="http://www.tenpercent.top/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>为什么hashCode()和equal()方法要一起重写？</title>
    <link href="http://www.tenpercent.top/2018/04/13/%E4%B8%BA%E4%BB%80%E4%B9%88hashCode()%E5%92%8Cequal()%E6%96%B9%E6%B3%95%E8%A6%81%E4%B8%80%E8%B5%B7%E9%87%8D%E5%86%99/"/>
    <id>http://www.tenpercent.top/2018/04/13/为什么hashCode()和equal()方法要一起重写/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2021-02-16T12:49:40.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hashCode-和equal-方法"><a href="#hashCode-和equal-方法" class="headerlink" title="hashCode()和equal()方法"></a>hashCode()和equal()方法</h2><p>可以看到Obejct类中的源码如下，可以看到equals()方法的默认实现是判断两个对象的内存地址是否相同来决定返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>网上很多博客说hashCode的默认实现是返回内存地址，其实不对，以OpenJDK为例，hashCode的默认计算方法有5种，有返回随机数的，有返回内存地址，具体采用哪一种计算方法取决于运行时库和JVM的具体实现。(可以理解Object类hashCode默认实现是对所有对象返回的值都不一样。)</p><p>感兴趣的朋友可以看看这篇博客</p><p><a href="https://blog.csdn.net/xusiwei1236/article/details/45152201" target="_blank" rel="noopener">Java的Object.hashCode()的返回值到底是不是对象内存地址？</a></p><h3 id="hashCode-方法的作用有哪些？"><a href="#hashCode-方法的作用有哪些？" class="headerlink" title="hashCode()方法的作用有哪些？"></a>hashCode()方法的作用有哪些？</h3><ul><li><p>对对象做散列</p><p>为了将一组键值对均匀得存储在一个数组中，HashMap对key的hashCode进行计算得到一个hash值，用hash对数组长度取模，得到数组下标，将键值对存储在数组下标对应的链表下。</p></li><li><p>快速判断对象是否不相等</p><p>因为两个对象hashCode相等，调用equal()方法的结果不一定为true，</p><p>因为两个对象调用equal()方法相等，hashCode一定相等。</p><p>所以hashCode不相等可以作为两个对象不相等的快速判断条件。</p><p>在往HashMap中添加一个键值对时，计算得到数组下标后，会遍历数组下标下存储的链表中，拿key的hashCode与每个节点的hashCode进行比较，相等时，才调用equal()方法进行继续调用，节约时间。（在一些类的equal()方法的自定义实现中也会对hashCode进行判断）。</p></li></ul><h3 id="假如只重写hashCode-方法（结果：HashMap可以存在两个内存地址不相同，但是相等的对象，无法保证去重）"><a href="#假如只重写hashCode-方法（结果：HashMap可以存在两个内存地址不相同，但是相等的对象，无法保证去重）" class="headerlink" title="假如只重写hashCode()方法（结果：HashMap可以存在两个内存地址不相同，但是相等的对象，无法保证去重）"></a>假如只重写hashCode()方法（结果：HashMap可以存在两个内存地址不相同，但是相等的对象，无法保证去重）</h3><p>此时equal()方法的实现是默认实现，也就是当两个对象的内存地址相等时，equal()方法才返回true，假设两个键值对，它们的key类型都是TestObject，的值都是test，但是由于是使用new String()创建而成的字符串对象，key1和key2的内存地址不相等，所以key1==key2的结果会是false，TestObject的equals()方法默认实现是判断两个对象的内存地址，所以 key1.equals(key2)也会是false， 所以两个键值对可以重复地添加到hashMap中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line">    Integer a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestObject</span><span class="params">(Integer a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestObject key1 = <span class="keyword">new</span> TestObject(<span class="number">1</span>);</span><br><span class="line">        TestObject key2 = <span class="keyword">new</span> TestObject(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"key1的hashCode为"</span>+ key1 +<span class="string">"key2的hashCode为"</span> + key2);</span><br><span class="line">        System.out.println(<span class="string">"key1.equals(key2)的结果为"</span>+(key1.equals(key2)));</span><br><span class="line"></span><br><span class="line">        HashMap&lt;TestObject,String&gt; map = <span class="keyword">new</span> HashMap&lt;TestObject,String&gt;();</span><br><span class="line">        map.put(key1,<span class="string">"value1"</span>);</span><br><span class="line">        map.put(key2,<span class="string">"value2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HashMap是"</span>+map.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key1的hashCode为com.test.TestObject@<span class="number">1</span></span><br><span class="line">key2的hashCode为com.test.TestObject@<span class="number">1</span></span><br><span class="line"></span><br><span class="line">key1.equals(key2)的结果为<span class="keyword">false</span></span><br><span class="line">  </span><br><span class="line">HashMap是</span><br><span class="line">&#123;com.test.TestObject@<span class="number">1</span>=value1, </span><br><span class="line">com.test.TestObject@<span class="number">1</span>=value2&#125;</span><br></pre></td></tr></table></figure><h3 id="假如只重写equals-方法（结果：相同的对象hashCode不同，从而映射到不同下标下，HashMap无法保证去重）"><a href="#假如只重写equals-方法（结果：相同的对象hashCode不同，从而映射到不同下标下，HashMap无法保证去重）" class="headerlink" title="假如只重写equals()方法（结果：相同的对象hashCode不同，从而映射到不同下标下，HashMap无法保证去重）"></a>假如只重写equals()方法（结果：相同的对象hashCode不同，从而映射到不同下标下，HashMap无法保证去重）</h3><p>假设只equals()方法，hashCode方法会是默认实现，具体的计算方法取决于JVM，可能会导致两个相等的对象，它们的hashCode却不相同，从而计算得到的数组下标不相同，存储到hashMap中不同数组下标下的链表中，也会导致HashMap中存在重复元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line">    Integer a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestObject</span><span class="params">(Integer a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        TestObject that = (TestObject) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(a, that.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestObject key1 = <span class="keyword">new</span> TestObject(<span class="number">1</span>);</span><br><span class="line">        TestObject key2 = <span class="keyword">new</span> TestObject(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"key1的hashCode为"</span>+ key1 +<span class="string">"key2的hashCode为"</span> + key2);</span><br><span class="line">        System.out.println(<span class="string">"key1.equals(key2)的结果为"</span>+(key1.equals(key2)));</span><br><span class="line"></span><br><span class="line">        HashMap&lt;TestObject,String&gt; map = <span class="keyword">new</span> HashMap&lt;TestObject,String&gt;();</span><br><span class="line">        map.put(key1,<span class="string">"value1"</span>);</span><br><span class="line">        map.put(key2,<span class="string">"value2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HashMap是"</span>+map.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key1的hashCode为<span class="number">1288141870</span> </span><br><span class="line">key2的hashCode为<span class="number">2054881392</span></span><br><span class="line"></span><br><span class="line">key1.equals(key2)的结果为<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">HashMap是</span><br><span class="line">&#123;com.test.TestObject@<span class="number">4</span>cc77c2e=value1, com.test.TestObject@<span class="number">7</span>a7b0070=value2&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hashCode-和equal-方法&quot;&gt;&lt;a href=&quot;#hashCode-和equal-方法&quot; class=&quot;headerlink&quot; title=&quot;hashCode()和equal()方法&quot;&gt;&lt;/a&gt;hashCode()和equal()方法&lt;/h2&gt;&lt;p&gt;可以
      
    
    </summary>
    
      <category term="总结" scheme="http://www.tenpercent.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JAVA" scheme="http://www.tenpercent.top/tags/JAVA/"/>
    
  </entry>
  
</feed>
