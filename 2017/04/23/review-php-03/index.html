<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 重温PHP手册【3】——类与对象（-） · 刻意练习，每日精进</title><meta name="description" content="重温PHP手册【3】——类与对象（-） - Jeffrey"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.tenpercent.top/atom.xml" title="刻意练习，每日精进"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon1.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about-me.html" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">重温PHP手册【3】——类与对象（-）</h1><div class="post-info">Apr 23, 2017</div><div class="post-content"><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><ul>
<li>构造函数</li>
</ul>
<p>具有构造函数的类会在每次创建新对象时先调用此方法，所以适合在使用对象前做一些初始化工作。</p>
<h5 id="Note-如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用-parent-construct-。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承。"><a href="#Note-如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用-parent-construct-。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承。" class="headerlink" title="Note: 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承。"></a>Note: 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承。</h5><a id="more"></a>
<ul>
<li>析构函数</li>
</ul>
<p>析构函数会在某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其自身访问。例子如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Define MyClass</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> $public = <span class="string">'Public'</span>;</div><div class="line">    <span class="keyword">protected</span> $protected = <span class="string">'Protected'</span>;</div><div class="line">    <span class="keyword">private</span> $private = <span class="string">'Private'</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">printHello</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;public;</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;protected;</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;private;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$obj = <span class="keyword">new</span> MyClass();</div><div class="line"><span class="keyword">echo</span> $obj-&gt;public; <span class="comment">// 这行能被正常执行</span></div><div class="line"><span class="keyword">echo</span> $obj-&gt;protected; <span class="comment">// 这行会产生一个致命错误</span></div><div class="line"><span class="keyword">echo</span> $obj-&gt;private; <span class="comment">// 这行也会产生一个致命错误</span></div><div class="line">$obj-&gt;printHello(); <span class="comment">// 输出 Public、Protected 和 Private</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Define MyClass2</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 可以对 public 和 protected 进行重定义，但 private 而不能</span></div><div class="line">    <span class="keyword">protected</span> $protected = <span class="string">'Protected2'</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">printHello</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;public;</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;protected;</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;private;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$obj2 = <span class="keyword">new</span> MyClass2();</div><div class="line"><span class="keyword">echo</span> $obj2-&gt;public; <span class="comment">// 这行能被正常执行</span></div><div class="line"><span class="keyword">echo</span> $obj2-&gt;private; <span class="comment">// 未定义 private</span></div><div class="line"><span class="keyword">echo</span> $obj2-&gt;protected; <span class="comment">// 这行会产生一个致命错误</span></div><div class="line">$obj2-&gt;printHello(); <span class="comment">// 输出 Public、Protected2 和 Undefined</span></div></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>定义为抽象的类不能被实例化。如果某个类里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。</p>
<p>继承一个抽象类时，子类必须定义父类中的所有抽象方法；另外这些方法的访问控制必须和父类中一样（或者更为宽松）</p>
<h3 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h3><p>PHP是单继承语言，trait是为这种单继承语言而准备的一种代码复用机制，Trait使开发人员可以自由的在不同层次结构内独立的类中复用方法。示例如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">trait</span> ezcReflectionReturnInfo &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getReturnType</span><span class="params">()</span> </span>&#123; <span class="comment">/*1*/</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getReturnDescription</span><span class="params">()</span> </span>&#123; <span class="comment">/*2*/</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ezcReflectionMethod</span> <span class="keyword">extends</span> <span class="title">ReflectionMethod</span> </span>&#123;</div><div class="line">    <span class="keyword">use</span> <span class="title">ezcReflectionReturnInfo</span>;</div><div class="line">    <span class="comment">/* ... */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ezcReflectionFunction</span> <span class="keyword">extends</span> <span class="title">ReflectionFunction</span> </span>&#123;</div><div class="line">    <span class="keyword">use</span> <span class="title">ezcReflectionReturnInfo</span>;</div><div class="line">    <span class="comment">/* ... */</span></div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p><strong>优先级</strong><br>从基类继承的成员会被trait插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了trait的方法，而trait则覆盖了被继承的方法。例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">trait</span> HelloWorld &#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">'Hello World!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheWorldIsNotEnough</span> </span>&#123;</div><div class="line">    <span class="keyword">use</span> <span class="title">HelloWorld</span>;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">'Hello Universe!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$o = <span class="keyword">new</span> TheWorldIsNotEnough();</div><div class="line">$o-&gt;sayHello();</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>以上例程会输出：</p>
<p>Hello Universe!</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载是指动态的”创建”类属性和方法。是通过魔术方法来实现的。</p>
<p>当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。</p>
<h4 id="属性重载"><a href="#属性重载" class="headerlink" title="属性重载"></a>属性重载</h4><ul>
<li>在给不可访问（或未定义）属性赋值时，__set()会被调用</li>
<li>在读取不可访问（或未定义）属性时，__get()会被调用</li>
<li>当对不可访问（或未定义）属性调用isset()或empty()时，__isset()会被调用</li>
<li>当对不可访问（或未定义）属性调用unset()时，__unset()会被调用</li>
</ul>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>使用<strong>__call()函数</strong>和<strong>__callStatic()函数</strong></p>
<p>在对象中调用一个不可访问方法时，__call() 会被调用。</p>
<p>在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/05/10/review-php-04/" class="prev">上一篇</a><a href="/2017/04/10/review-php-02/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'jeffrey';
var disqus_identifier = '2017/04/23/review-php-03/';
var disqus_title = '重温PHP手册【3】——类与对象（-）';
var disqus_url = 'http://www.tenpercent.top/2017/04/23/review-php-03/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//jeffrey.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2019 <a href="http://www.tenpercent.top">Jeffrey</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>