<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 代码 | 自由</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.tenpercent.top/atom.xml" title="代码 | 自由"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon-logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about-me.html" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/02/20/为什么并发编程会产生 bug/" class="post-title-link">为什么并发编程会产生 bug</a></h2><div class="post-info">Feb 20, 2019</div><div class="post-content"><h2 id="本文结构"><a href="#本文结构" class="headerlink" title="本文结构"></a>本文结构</h2><p><img src="https://my-blog-cjh.oss-cn-shanghai.aliyuncs.com/20200417233239.png" alt></p></div><a href="/2019/02/20/为什么并发编程会产生 bug/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/01/23/乐观锁与悲观锁/" class="post-title-link">乐观锁与悲观锁</a></h2><div class="post-info">Jan 23, 2019</div><div class="post-content"><blockquote>
<p>乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。</p>
</blockquote>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p></div><a href="/2019/01/23/乐观锁与悲观锁/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/11/23/反射机制/" class="post-title-link">JAVA 的反射机制</a></h2><div class="post-info">Nov 23, 2018</div><div class="post-content"><h2 id="反射机制介绍"><a href="#反射机制介绍" class="headerlink" title="反射机制介绍"></a>反射机制介绍</h2><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p></div><a href="/2018/11/23/反射机制/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/09/23/JDK 代理和 CGLIB 代理/" class="post-title-link">谈谈 JDK 代理和 CGLIB 代理</a></h2><div class="post-info">Sep 23, 2018</div><div class="post-content"><h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h2><p>在讲JDK 代理和 CGLIB 代理前需要先了解代理模式。<br>代理模式是一种比较简单的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p>代理分为静态代理和动态代理两种。</p></div><a href="/2018/09/23/JDK 代理和 CGLIB 代理/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/10/Linux-performance-monitor/" class="post-title-link">Linux 性能监控工具</a></h2><div class="post-info">Jul 10, 2018</div><div class="post-content"><p>最近了解了下 Linux 性能相关的东西，主要是如何查看服务器性能的一些工具，在这里做个记录，以后遇到相关使用场景的时候，方便查看。</p>
<h3 id="Linux-性能指标"><a href="#Linux-性能指标" class="headerlink" title="Linux 性能指标"></a>Linux 性能指标</h3><ul>
<li>CPU</li>
</ul>
<p>CPU利用率、用户时间（表示CPU在用户进程上的时间百分比）、系统时间（表示CPU花在内核操作上的时间百分比）、空闲时间、平均负载、阻塞、上下文切换、中断等</p>
<ul>
<li>内存</li>
</ul>
<p>空闲内存、Swap利用率、缓冲和缓存、活动和非活动内存等</p>
<ul>
<li>磁盘IO</li>
</ul>
<p>IO等待、平均队列长度、每秒传输（TPS）等</p>
<ul>
<li>网络</li>
</ul>
<p>接收和发送的包、每秒碰撞（各个网络接口所连接网络的所发生的冲突数量）、丢包、错误等</p></div><a href="/2018/07/10/Linux-performance-monitor/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/05/19/AOP 学习笔记/" class="post-title-link">AOP 学习总结</a></h2><div class="post-info">May 19, 2018</div><div class="post-content"><h2 id="AOP-简述"><a href="#AOP-简述" class="headerlink" title="AOP 简述"></a>AOP 简述</h2><p>AOP，面向切面编程。其实并不是什么很深奥的理论，就是当你想在做完某个操作后，希望在这个操作的发生前，发生后，返回值后等等场景里，进行一些相应的操作时，不需要每次都要重复的写一遍相应的操作，而是把这些操作定义成一个切面，通过定义好相应的切点后，在操作发生时，由框架帮你把你所定义好的切面织入进来，从而让你再开发的过程中，只需要聚焦于业务即可，而不用每次去处理很多重复的细节。</p>
<h2 id="AOP-的用处"><a href="#AOP-的用处" class="headerlink" title="AOP 的用处"></a>AOP 的用处</h2><p>AOP 最典型的应用是在数据库事务的管控中。比如要保存用户时，需要连同用户的角色一并保存如数据库，此时，用 OOP 无法完成这样的事务操作，而 AOP 可以完成这些事情。</p></div><a href="/2018/05/19/AOP 学习笔记/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/05/12/IOC 学习总结/" class="post-title-link">Spring 的 IOC 学习总结</a></h2><div class="post-info">May 12, 2018</div><div class="post-content"></div><a href="/2018/05/12/IOC 学习总结/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/04/23/泛型总结/" class="post-title-link">JAVA 泛型总结</a></h2><div class="post-info">Apr 23, 2018</div><div class="post-content"><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T testname;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> T <span class="title">testfunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">test</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需注意点：</p>
<ul>
<li>在声明类实现泛型接口时，若泛型参数未传入实参，则实现类也需要声明泛型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">one</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在声明类实现泛型接口时，若泛型参数有传入实参，则实现类里所有使用泛型的地方都需要声明对应的类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">implements</span> <span class="title">Test</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">one</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2018/04/23/泛型总结/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/04/13/为什么hashCode()和equal()方法要一起重写/" class="post-title-link">为什么hashCode()和equal()方法要一起重写？</a></h2><div class="post-info">Apr 13, 2018</div><div class="post-content"></div><a href="/2018/04/13/为什么hashCode()和equal()方法要一起重写/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/29/php7-garbage-collection/" class="post-title-link">浅析 PHP7 的垃圾回收机制</a></h2><div class="post-info">Mar 29, 2018</div><div class="post-content"><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>垃圾回收机制是一种动态存储分配方案。它会自动释放程序不再需要的已分配的内存块。 自动回收内存的过程叫垃圾收集。垃圾回收机制可以让程序员不必过分关心程序内存分配，从而将更多的精力投入到业务逻辑。 在现在的流行各种语言当中，垃圾回收机制是新一代语言所共有的特征。</p></div><a href="/2018/03/29/php7-garbage-collection/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/" class="prev">上一页</a><a href="/page/3/" class="next">下一页</a></div><div class="copyright"><p>© 2017 - 2021 <a href="http://www.tenpercent.top">Jeffrey</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-146782675-1",'auto');ga('send','pageview');</script></body></html>