[{"title":"PHP代码简洁之道——函数部分","date":"2017-09-30T16:00:00.000Z","path":"2017/10/01/clean-code-php-function/","text":"函数参数不要超过两个限制函数的参数数量是非常重要的，因为它使你的函数更容易测试。超过三个参数会导致参数之间的组合过多，你必须对每个单独的参数测试大量不同的情况。 没有参数是最理想的情况，一个或两个参数是可以接受的，三个以上则是应该避免的。这很重要的。如果你有两个以上的参数，那么你的函数可能试图做的太多，如果不是，你可能需要将一个高级别的对象传当做参数传进去。 Bad: 12345function createMenu($title, $body, $buttonText, $cancellable)&#123; // ...&#125; Good： 123456789101112131415161718class MenuConfig&#123; public $title; public $body; public $buttonText; public $cancellable = false;&#125;$config = new MenuConfig();$config-&gt;title = 'Foo';$config-&gt;body = 'Bar';$config-&gt;buttonText = 'Baz';$config-&gt;cancellable = true;function createMenu(MenuConfig $config)&#123; // ...&#125; 一个函数只做一件事这是软件工程中一个重要的原则。这会让你的代码清晰易懂以及易于复用。 Bad： 123456789function emailClients($clients)&#123; foreach ($clients as $client) &#123; $clientRecord = $db-&gt;find($client); if ($clientRecord-&gt;isActive()) &#123; email($client); &#125; &#125;&#125; Good: 1234567891011121314151617function emailClients($clients)&#123; $activeClients = activeClients($clients); array_walk($activeClients, 'email');&#125;function activeClients($clients)&#123; return array_filter($clients, 'isClientActive');&#125;function isClientActive($client)&#123; $clientRecord = $db-&gt;find($client); return $clientRecord-&gt;isActive();&#125; 函数名要能说明它是做什么的Bad: 12345678910111213class Email&#123; //... public function handle() &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// 这是什么？一条消息的句柄？还是要写一个文件？（读者的疑问）$message-&gt;handle(); Good: 12345678910111213class Email &#123; //... public function send() &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// 一目了然$message-&gt;send(); 函数应该只做一层抽象当你有多个层次的抽象时，你的函数就已经做的太多了。拆分这些函数，可以让代码可重用性更高且更易测试。Bad: 123456789101112131415161718192021222324function parseBetterJSAlternative($code)&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; // ... &#125; &#125; $ast = []; foreach ($tokens as $token) &#123; // lex... &#125; foreach ($ast as $node) &#123; // parse... &#125;&#125; Bad too:我们从函数中迁出去了一些工作，但是 parseBetterJSAlternative() 函数还是很复杂，不可测试。 1234567891011121314151617181920212223242526272829303132333435function tokenize($code)&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens;&#125;function lexer($tokens)&#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast;&#125;function parseBetterJSAlternative($code)&#123; $tokens = tokenize($code); $ast = lexer($tokens); foreach ($ast as $node) &#123; // parse... &#125;&#125; Good: 最好的解决方案是移除 parseBetterJSAlternative 函数的依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Tokenizer&#123; public function tokenize($code) &#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens; &#125;&#125;class Lexer&#123; public function lexify($tokens) &#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast; &#125;&#125;class BetterJSAlternative&#123; private $tokenizer; private $lexer; public function __construct(Tokenizer $tokenizer, Lexer $lexer) &#123; $this-&gt;tokenizer = $tokenizer; $this-&gt;lexer = $lexer; &#125; public function parse($code) &#123; $tokens = $this-&gt;tokenizer-&gt;tokenize($code); $ast = $this-&gt;lexer-&gt;lexify($tokens); foreach ($ast as $node) &#123; // parse... &#125; &#125;&#125; 不要使用标志作为函数的参数当你在函数中使用标志来作为参数时，你的函数就不是只做一件事情了，这与我们前面所讲的每个函数只做一件事的原则相违背，所以不要使用标志作为函数的参数。 Bad: 12345678function createFile($name, $temp = false)&#123; if ($temp) &#123; touch('./temp/'.$name); &#125; else &#123; touch($name); &#125;&#125; Good: 12345678910function createFile($name)&#123; touch($name);&#125;function createTempFile($name)&#123; touch('./temp/'.$name);&#125; 避免副作用如果一个函数做了“拿到一个值并返回一个值或者多个值”以外的事情，那么这个函数就有可能产生副作用，副作用可能是意外的写入了文件、修改了全局变量、或者打钱给了陌生人。 现在假如你确实要在函数中做一些有可能产生副作用的事情。 比如要写一个文件，你需要做的是将写文件的操作集中到一处，而不是在几个函数或者类里对同一个文件做操作，实现一个服务（函数或者类）去操作它，有且仅有一个。 关键是要能避免常见的陷阱：像是在没有结构的对象之间共享状态、使用可能被写入任何值的可变数据类型、 不集中处理有可能产生副作用的操作。 如果你能做到这些，你会比绝大多数程序员更快乐。 Bad: 1234567891011121314// Global variable referenced by following function.// If we had another function that used this name, now it'd be an array and it could break it.$name = 'Ryan McDermott';function splitIntoFirstAndLastName()&#123; global $name; $name = explode(' ', $name);&#125;splitIntoFirstAndLastName();var_dump($name); // ['Ryan', 'McDermott']; Good: 1234567891011function splitIntoFirstAndLastName($name)&#123; return explode(' ', $name);&#125;$name = 'Ryan McDermott';$newName = splitIntoFirstAndLastName($name);var_dump($name); // 'Ryan McDermott';var_dump($newName); // ['Ryan', 'McDermott']; 不要修改全局变量在许多编程语言中污染全局是一种糟糕的做法，因为你的库可能会与另一个库冲突，但是你的库的用户却一无所知，直到在生产环境中爆发异常。让我们来考虑一个例子：如果你想要拿到配置数组怎么办？你可以编写全局函数，如config()，但是它可能与另一个试图做同样事情的库冲突。 Bad: 123456function config()&#123; return [ 'foo' =&gt; 'bar', ]&#125; Good: 12345678910111213141516171819class Configuration&#123; private $configuration = []; public function __construct(array $configuration) &#123; $this-&gt;configuration = $configuration; &#125; public function get($key) &#123; return isset($this-&gt;configuration[$key]) ? $this-&gt;configuration[$key] : null; &#125;&#125;$configuration = new Configuration([ 'foo' =&gt; 'bar',]); 避免条件判断人们会问“如果不用 if 语句我该怎么做？”，答案是在许多情况下，你可以用多态来实现同样的效果。那这样做什么好处，还是那句话：“一个函数应该只做一件事”， 当你的类或函数中有了 if 语句，你的函数就不止是只做一件事情了。 Bad: 12345678910111213141516class Airplane&#123; // ... public function getCruisingAltitude() &#123; switch ($this-&gt;type) &#123; case '777': return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); case 'Air Force One': return $this-&gt;getMaxAltitude(); case 'Cessna': return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125; &#125;&#125; Good: 123456789101112131415161718192021222324252627282930313233343536interface Airplane&#123; // ... public function getCruisingAltitude();&#125;class Boeing777 implements Airplane&#123; // ... public function getCruisingAltitude() &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); &#125;&#125;class AirForceOne implements Airplane&#123; // ... public function getCruisingAltitude() &#123; return $this-&gt;getMaxAltitude(); &#125;&#125;class Cessna implements Airplane&#123; // ... public function getCruisingAltitude() &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125;&#125;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"PHP代码简洁之道——变量部分","date":"2017-09-23T16:00:00.000Z","path":"2017/09/24/clean-code-php/","text":"将代码写的简洁并且易读易懂是每一位优秀的coder所应该具备的基本功。 前几天在github上看到clean-code-php这个项目，感觉很有收获，于是在这里记录一下。 使用有意义并且可读的变量名称Bad: 1$ymdstr = $moment-&gt;format('y-m-d'); Good: 1$currentDate = $moment-&gt;format('y-m-d'); 对同一只类型的变量使用同样的词汇Bad: 1234getUserInfo();getUserData();getUserRecord();getUserProfile(); Good: 1getUser(); 使用易于查找的命名Bad: 1234// 这里的4是什么鬼??if ($user-&gt;access &amp; 4) &#123; // ...&#125; Good: 1234567891011class User&#123; const ACCESS_READ = 1; const ACCESS_CREATE = 2; const ACCESS_UPDATE = 4; const ACCESS_DELETE = 8;&#125;if ($user-&gt;access &amp; User::ACCESS_UPDATE) &#123; // do edit ...&#125; 不要让读者猜Bad: 123456789101112$l = ['Austin', 'New York', 'San Francisco'];for ($i = 0; $i &lt; count($l); $i++) &#123; $li = $l[$i]; doStuff(); doSomeOtherStuff(); // ... // ... // ... // $li 变量代表什么？？？ dispatch($li);&#125; Good: 12345678910$locations = ['Austin', 'New York', 'San Francisco'];foreach ($locations as $location) &#123; doStuff(); doSomeOtherStuff(); // ... // ... // ... dispatch($location);&#125; 避免过深的嵌套Bad: 123456789101112131415161718192021function isShopOpen($day)&#123; if ($day) &#123; if (is_string($day)) &#123; $day = strtolower($day); if ($day === 'friday') &#123; return true; &#125; elseif ($day === 'saturday') &#123; return true; &#125; elseif ($day === 'sunday') &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125;&#125; Good: 123456789101112function isShopOpen($day)&#123; if (empty($day) &amp;&amp; ! is_string($day)) &#123; return false; &#125; $openingDays = [ 'friday', 'saturday', 'sunday' ]; return in_array(strtolower($day), $openingDays);&#125; Bad: 12345678910111213141516function fibonacci($n)&#123; if ($n &lt; 50) &#123; if ($n !== 0) &#123; if ($n !== 1) &#123; return fibonacci($n - 1) + fibonacci($n - 2); &#125; else &#123; return 1; &#125; &#125; else &#123; return 0; &#125; &#125; else &#123; return 'Not supported'; &#125;&#125; Good: 12345678910111213141516function fibonacci($n)&#123; if ($n === 0) &#123; return 0; &#125; if ($n === 1) &#123; return 1; &#125; if ($n &gt; 50) &#123; return 'Not supported'; &#125; return fibonacci($n - 1) + fibonacci($n - 2);&#125; 不要添加不必要的上下文如果你的类/对象已经说明了一些信息,不要在你的变量名和属性里重复 Bad: 12345678class Car&#123; public $carMake; public $carModel; public $carColor; //...&#125; Good: 12345678class Car&#123; public $make; public $model; public $color; //...&#125; 参数初始化时设置默认值12345function create($name = null)&#123; $newName = $name ?: 'ABC'; // ...&#125; 设置默认值一个比较明显的好处是，当对一个较早之前已经定义好的函数添加参数时,将新增的参数设置默认值可以省得去修改以前使用该函数的地方。 参考链接","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"通俗易懂的谈谈装饰器模式","date":"2017-09-16T16:00:00.000Z","path":"2017/09/17/Decorator-Pattern/","text":"前言在编码的时候，我们为了扩展一个类经常是使用继承方式来实现，随着扩展功能的增多，子类会越来越膨胀，使系统变得不灵活。 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。它能让我们在扩展类的时候让系统较好的保持灵活性。 那么装饰器模式具体是什么样的呢？ 从一个情景开始我们有一块地，在这块地上，我们要盖一栋有好几间房间的别墅，每间房间的装修费用都不同，现在，我们要对盖别墅的费用进行计算。 先定义一个Land类，表示这块地，Land类定义了在这块地上盖别墅需要花钱这个规则。 1234abstract class Land&#123; abstract function cost();&#125; Land已经定义好了在这块地上盖房需要花钱的这个规则了，但是盖一间房间具体花多少钱呢？此时我们再定义一个Room类，这个类具体的定义了一个房间建造的基本费用（一个最简单房间，里面啥也没有的）。 12345678class Room extends Land&#123; private $money = 1000; public function cost() &#123; return $this-&gt;money; &#125;&#125; 然后开始建造房间，我们建了两个房间，分别是客厅和餐厅，用LivingRoom类和DiningRoom类来表示 12345678910111213141516class LivingRoom extends Room&#123; public function cost() &#123; return parent::cost()+200; //客厅的建造费用在房屋建造费用的基础上多200，比如要买沙发，电视 &#125; &#125;class DiningRoom extends Room&#123; public function cost() &#123; return parent::cost()+100; //餐厅的建造费用在房屋建造费用的基础上多100，比如买餐桌 &#125;&#125; 现在，我们很容易就能得到建造一间客厅所需的花费 12$livingRoomCost = new LivingRoom();echo $livingRoomCost-&gt;cost(); 问题的产生不过，这样的结构并不具备灵活性，虽然我们可以很容易的分别得出建造一间客厅和建造一间餐厅的费用，但是，如果我买的地比较小，只能把餐厅和客厅建在同一个房间里，那要怎么去计算费用？难道还要很麻烦的去创建一个包含客厅和餐厅的LivingDiningRoom类？这样做的话除了麻烦，还会使代码产生重复。 解决问题为了更好的解决这个问题，我们得做一些调整，同样先声明Land类和Room类，不同的是，引入了一个房间的装饰类RoomDecorator，它继承了Land类，因为没有实现Land类的cost()方法，所以需将它声明为抽象类，并且定义了一个以Land类的对象为参数的构造方法，传入的对象会保存在$land属性中，该属性声明为protected，以便子类访问。具体如下。 12345678abstract class RoomDecorator extends Land&#123; protected $land; public function __construct(Land $land) &#123; $this-&gt;land = $land; &#125;&#125; 然后我们再重新定义客厅类和餐厅类 12345678910111213141516class LivingRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+200; &#125;&#125;class DiningRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+100; &#125;&#125; 这两个类都扩展自RoomDecorator类，这意味着它们都拥有指向Land对象的引用。当它们的cost()方法被调用时，都会先调用所引用的Land类对象的cost()方法，然后再执行自己特有的操作。 所以这时候，建造一间客厅所需的费用是这样计算 12$livingRoomCost = new LivingRoom(new Room());echo $livingRoomCost-&gt;cost(); //输出1200 建造一间餐厅所需的费用是这样计算 12$diningRoomCost = new DiningRoom(new Room());echo $diningRoomCost-&gt;cost(); //输出1100 回到刚才的问题，如果我们需计算建造一间包含客厅餐厅的房间所需费用，代码如下 12$livingRoom = new DiningRoom(new LivingRoom(new Room()));echo $livingRoom-&gt;cost(); //输出1300 看，我们现在计算建造费用的思路是：计算出基础房间的费用 –&gt; 在基础房间上装饰成客厅的费用 –&gt; 在客厅的基础上加装饰餐厅的费用 –&gt; 得到包含客厅餐厅的房间费用。已经不需要麻烦的通过创建一个LivingDiningRoom类来计算包含客厅餐厅的房间建造费用了。 这便是装饰模式，通过一层一层的装饰，我们可以灵活的得到我们想要的结果。可以轻松的添加新的装饰器类或者新的组件来创建灵活的结构。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpabstract class Land&#123; abstract function cost();&#125;class Room extends Land&#123; private $money = 1000; public function cost() &#123; return $this-&gt;money; &#125;&#125;//装饰器abstract class RoomDecorator extends Land&#123; protected $land; public function __construct(Land $land) &#123; $this-&gt;land = $land; &#125;&#125;class LivingRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+200; &#125;&#125;class DiningRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+100; &#125;&#125;$livingRoomCost = new LivingRoom(new Room());echo $livingRoomCost-&gt;cost(); //输出1200$diningRoomCost = new DiningRoom(new Room());echo $diningRoomCost-&gt;cost(); //输出1100$livingDining = new DiningRoom(new LivingRoom(new Room()));echo $livingDining-&gt;cost(); //输出1300 the end. happy coding! ^_^","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"外观模式的总结","date":"2017-09-09T16:00:00.000Z","path":"2017/09/10/Facade-pattern/","text":"前言外观模式(Facade Pattern)是一个比较简单的概念，它只是为一个子系统创建一个单一的入口。这样的好处是有助于分离项目中不同的部分，其次，会使得我们在访问代码时变得简洁方便。另外，由于只在一个地方调用子系统，减少了出错的可能性。 外观模式比较简单，这里就不做过多的赘述了，主要是要吸收该模式减少耦合的思想，直接上代码。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass SystemA&#123; public function operationA() &#123; echo \"operationA &lt;br&gt;\"; &#125;&#125;class SystemB&#123; public function operationB() &#123; echo \"operationB &lt;br&gt;\"; &#125;&#125;class SystemC&#123; public function operationC() &#123; echo \"operationC &lt;br&gt;\"; &#125;&#125;class Facade&#123; protected $systemA; protected $systemB; protected $systemC; function __construct() &#123; $this-&gt;systemA = new SystemA(); $this-&gt;systemB = new SystemB(); $this-&gt;systemC = new SystemC(); &#125; public function myOperation() &#123; $this-&gt;systemA-&gt;operationA(); $this-&gt;systemB-&gt;operationB(); $this-&gt;systemC-&gt;operationC(); &#125;&#125;$facade = new Facade();$facade-&gt;myOperation();//只通过一个入口调用 总结使用外观模式最大的优点就是子系统与客户端之间是松耦合的关系，客户端不必知道具体有哪些子系统，也无需知道他们是如何工作的，通过引入一个外观类，提供一个客户端间接访问子系统的高级接口。子系统和外观类可以独立运作，修改某一个子系统的内容，不会影响到其他子系统，也不会影响到外观对象。 不过它的缺点就是它不够灵活，当需要增加一个子系统的时候，需要修改外观类。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"使用 Vagrant 并搭建 LNMP 环境","date":"2017-09-02T16:00:00.000Z","path":"2017/09/03/use-vagrant/","text":"Vagrant介绍 Vagrant 是一个自动化构建虚拟机环境的工具，可以自动化虚拟机的安装和配置流程。 在团队开发的情况下，我们常常需要在多台机器间同步开发时，有的同事用的 wamp ,有的同事是用的 xampp ，可能在某些配置上的些许不同会导致些许不同或者bug，通过使用 Vagrant ，我们只需要同步 Vagrantfile ，就可以保证各台机器拥有一致的开发环境。也可以通过打包好一个Vagrant box ,供团队的同事使用，这样就能最大程度的保证开发环境一致，避免出现一些没必要的问题从而浪费精力去解决。 安装 Vagrant1、安装 VirtualBox ,具体安装包直接从官网下载（要下载顺畅的话需翻墙）：https://www.virtualbox.org/wiki/Downloads 2、安装 Vagrant，下载地址：https://releases.hashicorp.com/vagrant/ 3、下载box镜像，这里我是下载的Ubuntu的box,可以到这个网址上去查找想下载的box：https://app.vagrantup.com/boxes/search 切换到自己的文件夹下，初始化vagrant环境，生成一个vagrantfile文件，命令如下： 用 vagrant 命令加 box 1$ vagrant box add testUbuntu ~/Downloads/ubuntu-14.04-amd64.box 初始化虚拟机 1$ vagrant init testUbuntu 启动虚拟机 1$ vagrant up 进入虚拟机的 Ubuntu 系统 1$ vagrant ssh 接下来还要对虚拟机进行一些配置。 打开 vagrantfile 文件进行配置，我的配置如下： 到这里，利用 vagrant 搭建虚拟机环境就基本完成了。 vagrant 常用命令 123456789vagrant box add 添加box，自动帮你生成vagrantfilevagrant init 初始化vagrantfilevagrant halt 关闭虚拟机vagrant destroy 销毁虚拟机vagrant ssh 连接虚拟机vagrant reload 重新加载vagarntfile文件vagrant suspend 暂时挂起虚拟机vagrant status 查看虚拟机运行状态vagrant package --output 打包导出box 搭建 LNMP 环境使用 vagrant ssh 登录到虚拟机的 Linux 系统上，就可以开始搭建 LNMP 的环境了。 在安装软件之前，需要对 Ubuntu 系统的镜像源文件 source.list 进行修改一下，可以在网上找一下网易的镜像源或者是阿里搜狐等的镜像源，然后写入 source.list 文件夹里（对源文件先进行下备份）。修改完之后还要运行一下 apt-get update 命令来更新一下镜像源。 安装 Nginx使用apt-get install nginx便可以安装nginx。非常简单。安转完之后，可以使用 curl -I &#39;127.0.0.1&#39;访问一下，看看是否安装成功。 安装 MySQL使用 apt-get install mysql-server mysql-cli 安装MySQL的服务端可客户端，安装的时候需要设置一下密码。安装完之后，通过命令 mysql -uroot -ppassword 命令来登录数据库。 安装PHP 7.0在这里，我使用 Ubuntu 的 PPA 源来安装 PHP 7.0。 先介绍一下 PPA源 PPA 全称为 Personal Package（个人软件包档案），是 Ubuntu Launchpad 网站提供的一项服务，当然不仅限于 Launchpad 。它允许个人用户上传软件源代码，通过 Launchpad 进行编译并发布为二进制软件包，作为 apt/新立得源供其他用户下载和更新。在Launchpad网站上的每一个用户和团队都可以拥有一个或多个PPA。通常 PPA 源里的软件是官方源里没有的，或者是最新版本的软件。相对于通过 Deb 包安装来说，使用 PPA 的好处是，一旦软件有更新，通过 sudo apt-get upgrade 这样命令就可以直接升级到新版本。 如何通过 PPA 源来安装软件： 我们可以通过 Google 来搜索一些常用软件的 PPA 源，通常的搜索方法是软件名称关键字 + PPA ，或者也可直接到 launchpad.net 上去搜索，搜索到后我们就可以直接用 sudo apt-add-repository 命令把 PPA 源添加到 Source list 中了。比如 FireFox PPA 源：https://launchpad.net/~ubuntu-mozilla-daily/+archive/ppa ，我们可以在这里找到 ppa:ubuntu-mozilla-daily/ppa 的字样，然后我们通过以下命令把这个源加入到 source list 中。 sudo apt-add-repository ppa:ubuntu-mozilla-daily/ppa 开始安装 PHP 7.0 第一次使用PPA时，需要先安装一下 python-software-properties 和 software-properties-common apt-get install python-software-properties software-properties-common 然后便可以开始安装PHP 7.0 了 123$ add-apt-repository ppa:ondrej/php$ apt-get update 安装PHP的一些扩展 $ apt-get install php7.0-fpm php7.0-mysql php7.0-common php7.0-curl php7.0-cli php7.0-mbstring php7.0-dom 打开 php.ini进行配置 vim /etc/php/7.0/fpm/php.ini 将cgi.fixpathinfo=1 改成cgi.fixpathinfo=0,这个配置是为了避免 nginx 产生某个漏洞。具体参考鸟哥的文章http://www.laruence.com/2010/05/20/1495.html cgi.fix_pathinfo=0 然后重启一下 php-fpm 服务。 到这里就成功搭建好了 LNMP环境了。 happy codding ! ^_^","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.tenpercent.top/tags/Linux/"},{"name":"Vagrant","slug":"Vagrant","permalink":"http://www.tenpercent.top/tags/Vagrant/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://www.tenpercent.top/tags/虚拟机/"}]},{"title":"PSR编程规范摘录","date":"2017-08-26T16:00:00.000Z","path":"2017/08/27/PSR-reference/","text":"这篇文章记录一下PHP的编程代码规范，做一个规范的PHPer。 PSR：即PHP Standards recommendation(PHP推荐标准)。 PSR-1:基本的代码风格 PHP标签： PHP标签只使用&lt;?php ?&gt;和&lt;?= ?&gt;，不得使用其他PHP标签句法。 编码： PHP所有文件都必须使用UTF-8字符集编码。 目的： 一个PHP文件可以定义符号（类、性状、函数和常量），或者执行有副作用的操作（例如，生成结果或处理数据），但是不能同时做这两件事。 自动加载： PHP命名空间和类必须遵守PSR-4自动加载器标准。 类的名称： PHP类的名称必须使用CamelCase这种驼峰式。 常量的名称：PHP常量的名称必须全部使用大写字母。如果需要，可以使用下划线把单词分开。例如：THIS_VARIABLE 方法的命名： PHP方法的名称必须使用camelCase这种驼峰式，首字母是小写的，后续的所有单词的首字母都是大写的。如：phpIsAwesome PSR-2:严格的代码风格PSR-2是在PSR-1的基础上进一步的要求。 缩进 PSR-2推荐的规范要求是使用4个空格缩进（因为空格最可靠，在不同的代码编辑器中渲染的效果基本一致） 文件和代码 PHP文件的最后一行要有一个空行，而且不能使用PHP关闭标签?&gt;，每行末尾都不能有空格。（这些要求大多数编辑器能帮你做好） 注：PHP文件不写关闭标签的目的是能避免意料之外的输出错误。如果加上关闭标签?&gt;，而且在关闭标签后有空行。那么这个空行会被当成输出导致错误。（例如，设定HTTP头部时） 关键字 对于ture,false和null,PSR-2推荐这些关键字都要使用小写字母的形式。 命名空间 每个命名空间声明语句后面必须跟着一个空行。使用use关键字导入命名空间时，在一系列的use声明语句后要加一个空行。 类 PSR-2推荐类定义体的起始括号应该在类名之后新起一行写。如下代码所示： 1234567&lt;?phpclass example &#123; //类的定义&#125; 方法 （直接代码示例如下） 12345678910&lt;?phpnamespace Animals //注意这里的命名空间首字母需要大写class example&#123; public function test($params = 1, $params = 'two')//注意这里起始括号和结束括号两边都没有空格 &#123; //方法的定义 &#125;&#125; 可见性 类中的每个属性和方法都要声明可见性。abstract和final这俩关键字要放在可见性关键字前面。static关键字要放在可见性关键字后面。代码如下 12345678910class example&#123; public static $number = 0; public function __construct() &#123; static::$number++; &#125;&#125; 控制结构 控制结构中如if else switch foreach等这些关键字后面都要有一个空格。示例代码如下 12345&lt;?phpif (a == b)&#123; //注意这里的花括号不用新起一行 &#125; 虽然现在有挺多的编辑器支持根据PSR-1和PSR-2来格式化代码了，不过这些写代码中的规范还是需要记住一下，尽量让自己的代码风格规范一些，这样在日常的工作中也方便团队交流。 PSR-3：日志记录器接口PSR-3与前面得规范不同，它是一个接口，规定PHP日志记录器组件可以实现得方法。 大多数PHP框架都在某种程度上实现了日志功能。为了实现互操作性和专业化，PHP-FIG制定了PSR-3日志记录器接口。若想使用符合PSR-3规范得日志记录器，框架要做到两件重要得事：日志功能委托给第三方库实现；最终用户能选择使用他们喜欢得日志记录器组件。 编写PSR-3日志记录器符合PSR-3推荐规范的PHP日志记录器组件，必须包含一个实现Psr\\Log|LoggerInterface接口得PHP类。PSR-3接口复用了系统日志协议，规定要实现以下九个方法： 123456789101112131415&lt;?phpnamespace Psr\\Log;interface LoggerInterface&#123; public function emergency($message,array $context = array()); public function alert($message,array $context = array()); public function critial($message,array $context = array()); public function error($message,array $context = array()); public function warning($message,array $context = array()); public function notice($message,array $context = array()); public function info($message,array $context = array()); public function debug($message,array $context = array()); public function log($level,$message,array $context = array());&#125; 但是，我们现在已经不需要自己去编写一个日志记录器了，因为已经有了Monolog(可访问packagist这个网站查看介绍)这个十分出色的PHP日志记录器组件了，它几乎提供了开发过程中所有需要的功能。 PSR-4：自动加载器PSR-4描述了一个标准的自动加载器策略。自动加载器策略是指，在运行时按需查找PHP类、接口或者性状，并将其载入PHP解释器。支持PSR-4自动加载器标准的PHP组件和框架，使用同一个自动加载器就能找到相关代码 在PHP-FIG发布PSR-4推荐规范之前，PHP组件和框架的作者使用__autoload()和spl_autoload_register()函数注册自定义的自动加载器策略。可是，每个PHP组件和框架都使用独特的自动加载器，而且每个加载器使用不同的逻辑查找并加载PHP类、性状和接口。使用这些组件和框架的开发者，在引导PHP应用时必须调用每个组件各自的自动加载器时必须调用每个组件各自的自动加载器。这样在开发中很麻烦。 如今，得益于PSR-4，我们只需要使用一个自动加载器就能自动加载应用中的所有PHP组件。大多数现代的PHP组件和框架都符合PSR-4规范。 PSR自动加载策略PSR-4自动加载策略依赖PHP命名空间和文件系统目录结构查找并加载PHP类、接口，性状。 它的精髓是把命名空间的前缀和文件系统中的目录对应起来。例如，\\Oreilly\\ModernPHP\\Chapter1命名空间对应与src/chapter1目录，\\Oreilly\\ModernPHP\\Chapter1\\Example类对应于src/Chapter1/Example。 实现一个PSR-4自动加载器123456789101112131415161718192021222324252627282930313233343536&lt;?php/*** 该代码中，使用SPL注册这个自动加载函数后，遇到下述代码时，这个函数会* 自动尝试从/path/to/project/src/Baz/Qux.php文件中加载* \\Foo\\Bar\\Baz\\Quz类：* new \\Foo\\Bar\\Baz\\Qux;* */spl_autpload_register(function ($class))&#123; //这个项目的命名空间前缀 $prefix = 'Foo\\\\Bar\\\\'; //这个命名空间对应的根目录； $base_url = __DIR__.'/src/'; //参数传入的类使用这个命名空间前缀吗？ $len = strlen($prefix); if(strncmp($prefix, $class, $len) !==0)&#123; //不使用，交给注册的下一个自动加载器处理 return; &#125; //获取去掉前缀后的类名 $relative_class = substr($class, $len); //把命名空间前缀替换成根目录， //去掉前缀的类命中，把命名空间分隔符替换成目录分隔符， //然后再后面加上.php $file = $base_dir.str_replace('\\\\', '/', $relative_class).'.php'; //如果文件存在，将其导入 if(file_exists($file))&#123; require $file; &#125;&#125; 以上代码是一个PSR-4自动加载器的逻辑。不过在现在，我们也无须自己编写一个PSR-4自动加载器了，因为我们可以使用依赖管理器Composer自动生成PSR-4自动加载器。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"PSR","slug":"PSR","permalink":"http://www.tenpercent.top/tags/PSR/"}]},{"title":"记一个问题的解决：Can't connect to MySQL server on 'x.x.x.x' (61)","date":"2017-08-19T16:00:00.000Z","path":"2017/08/20/ubuntu-mysql/","text":"最近在电脑上安装了虚拟机并且使用vagrant配置了基于Ubuntu的LAMP环境，然后在使用本地主机的MySQL客户端连接虚拟机的MySQL时却出现了问题，Google了一圈解决了问题，在此记录下。 遇到的问题是这样Sequel软件提示”Can’t connect to MySQL servet on ‘x.x.x.x’ (61)”错误 搜了一下，找到了这个答案 即Linux系统里的MySQL是默认监听127.0.0.1的，也就是说，只有在这个Linux本身才能访问到。 运行了下netstat -tulpen这个命令，该命令可以查看端口的监听情况，如下图。 这里可以看到3306的端口是绑定着127.0.0.1的。 要更改这个端口绑定，需要修改/etc/mysql/my.cnf 这个MySQL配置文件。 注意：MySQL 7.0以上版本得，该配置文件得路径是/etc/mysql/mysql.conf.d/mysqld.cnf 这个地址 在my.cnf文件中找到 bind-address = 127.0.0.1 这一行，然后将127.0.0.1改成 0.0.0.0 ，0.0.0.0的意思就是指任何ip地址。 修改之后重启一下MySQL，这时我们再看一下端口绑定情况就可以看到3306这个端口已经绑定成0.0.0.0了。 但是，还没有大功告成在本地主机再次尝试连接MySQL，却出现“Host ‘192.168.100.100’ is not allowed to connect to this MySQL server” 这个问题是在本地主机使用的登录账户不被允许远程登录到虚拟机的Linux上。可以先看一下虚拟机里Linux的MySQL用户情况 运行以下命令可以看到： 这里的登录账户都是在localhost的。 所以我们需要手动添加一个可以远程访问的账户。 添加的方法如下： 添加用户root使用password从任何主机连接到MySQL服务器的话。语句如下： GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION; 添加用户root从ip为192.168.1.1的主机连接到mysql服务器，并使用password作为密码 GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;192.168.1.1&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION; 添加用户root从ip为192.168.1.1的主机连接到mysql服务器的dk数据库，并使用password作为密码 GRANT ALL PRIVILEGES ON dk.* TO &#39;root&#39;@&#39;192.168.1.1&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION; 这里我使用的是第一条语句，执行完之后，再查看MySQL的用户情况就可以看到多出了一个root账户，并且其主机ip是任意的。 到这里，就可以在本地主机的MySQL客户端上愉快的访问到虚拟机里的MySQL啦！！ 后记： 最近折腾了一下vagrant配置虚拟机上的开发环境（具体过程后续会再写一篇文章），又配了一遍LAMP的环境，对Linux的系统更加熟悉了一点。虽然期间会被各种问题卡住，不过解决了问题之后，就会又多懂了一些知识。感觉收获满满，哈哈。^_^ 生命的乐趣还是在于折腾呀！！","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"http://www.tenpercent.top/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://www.tenpercent.top/tags/Ubuntu/"}]},{"title":"现代化PHP的标准","date":"2017-08-12T16:00:00.000Z","path":"2017/08/13/php-standard/","text":"在今天，PHP组件和框架的数量很多，可以说是多如牛毛。PHP生态系统是个名副其实的大熔炉，有各种各样的代码，帮助开发者构建强大的应用。为了使这些不同的组件代码、框架能互相通信，共享代码，就诞生了PHP-FIG这个组织，PHP-FIG制定了推荐规范，PHP框架可以自愿实现这些规范，改进与其他框架的通信和共享功能。如今的很多受欢迎的大型PHP框架通常都会实现定案的PHP-FIG推荐规范。 PHP-FIG的使命是实现框架的互操作性。框架的互操作性是指，通过接口、自动加载机制和标准的风格，让框架互相操作。 接口PHP框架之间通过共用的接口合作。框架通过PHP接口假定第三方依赖提供了什么方法，而不关心依赖是如何实现接口的。 例如：假如第三方日志记录器对象实现了alert()，critical()，error()，warning()和debug()等方法，那么框架就可以放心的使用这个记录器对象。至于这些方法是如何实现的无关紧要，框架只关心第三方依赖是否实现了这些方法。 PHP开发者使用接口可以开发、共享并使用专门的组件，而无需使用庞大的框架。 自动加载PHP框架之间通过自动加载机制合作。自动加载是指，PHP解释器在运行时按需自动找到并加载PHP类的过程。 在这些PHP标准出现之前，PHP组件和框架会使用模式方法__autoload（）或最新的spl_autoload_register()方法实现各自特有的自动加载器。因此，我们要学习使用每一个组件和框架各自特有的自动加载器。而如今，多数现代的PHP组件和框架都符合同一个自动加载器标准。这意味着，我们只需使用一个自动加载器就能混合搭配多个PHP组件。 风格PHP框架之间通过标准的代码风格合作。代码风格是指如何使用空格、大小写和括号的位置（等待）。如果PHP框架都使用标准的代码风格，那么每次使用新PHP框架时，PHP开发者已经对框架所用的风格就很熟悉了，就不用适应新的风格。标准的代码风格还能降低项目新贡献者的门槛，让新贡献者把更多的时间用在解决缺陷上，而不用花太多时间学习不熟悉的风格。 标准的代码风格对我们自己的项目也有好处。每个开发者都有一些独特的风格，如果多为开发者在同一个代码基中工作，就会显露问题。使用标准的代码风格，不管作者是谁，团队中的所有成员都能立即理解代码基。 关于代码风格的规范，PHP-FIG退出了PSR，即PHP Standard Recommendation（PHP推荐标准）的简称。它包括PSR-1，PSR-2，PSR-3，PSR-4四个规范，现代的PHP框架基本都会遵守这些规范，这些个规范的具体详细内容就等下一篇总结再介绍吧。今天就先写到这里。 ^_^ happy coding!","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"PHP标准","slug":"PHP标准","permalink":"http://www.tenpercent.top/tags/PHP标准/"}]},{"title":"关于三种工厂模式的总结","date":"2017-07-09T16:00:00.000Z","path":"2017/07/10/factory-pattern/","text":"工厂模式分为简单工厂模式，工厂方法模式和抽象工厂模式，它们都属于设计模式中的创建型模式。其主要功能都是帮助我们把对象的实例化部分抽取了出来，目的是降低系统中代码耦合度，并且增强了系统的扩展性。本文对这三种模式进行了介绍并且分析它们之间的区别。 简单工厂模式简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码逻辑将会非常复杂。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php//简单工厂方法interface People&#123; public function say();&#125;class Man implements People&#123; public function say() &#123; echo 'this is a man '; &#125;&#125;class Women implements People&#123; public function say() &#123; echo 'this is a women'; &#125;&#125;class SimpleFactory&#123; public static function create($name) &#123; if ($name == 'man') &#123; return new Man(); &#125; elseif ($name == 'women') &#123; return new Women(); &#125; &#125; &#125;//具体调用$man = SimpleFactory::create('man');$man-&gt;say();$women = SimpleFactory::create('women');$women-&gt;say(); 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。 工厂方法模式此模式中，通过定义一个抽象的核心工厂类，并定义创建产品对象的接口，创建具体产品实例的工作延迟到其工厂子类去完成。这样做的好处是核心类只关注工厂类的接口定义，而具体的产品实例交给具体的工厂子类去创建。当系统需要新增一个产品是，无需修改现有系统代码，只需要添加一个具体产品类和其对应的工厂子类，使系统的扩展性变得很好，符合面向对象编程的开闭原则。体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php//工厂方法模式interface People&#123; public function say();&#125;class Man implements People&#123; public function say() &#123; echo 'this is a man'; &#125;&#125;class Women implements People&#123; public function say() &#123; echo 'this is a women'; &#125;&#125;//与简单工厂模式相比。区别在于，此处将对象的创建抽象成一个接口interface CreatePeople&#123; public function create();&#125;class FactoryMan implements CreatePeople&#123; public function create() &#123; return new Man(); &#125;&#125;class FactoryWomen implements CreatePeople&#123; public function create() &#123; return new Women(); &#125;&#125;class Client&#123; // 具体生产对象并执行对象方法测试 public function test() &#123; $factory = new FactoryMan(); $man = $factory-&gt;create(); $man-&gt;say(); $factory = new FactoryWomen(); $man = $factory-&gt;create(); $man-&gt;say(); &#125;&#125;// 执行$demo = new Client();$demo-&gt;test(); 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 此模式是对工厂方法模式的进一步扩展。在工厂方法模式中，一个具体的工厂负责生产一类具体的产品，即一对一的关系，但是，如果需要一个具体的工厂生产多种产品对象，那么就需要用到抽象工厂模式了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php interface TV&#123; public function open(); public function watch();&#125;class HaierTv implements TV&#123; public function open() &#123; echo \"Open Haier TV &lt;br&gt;\"; &#125; public function watch() &#123; echo \"I'm watching TV &lt;br&gt;\"; &#125;&#125;interface PC&#123; public function work(); public function play();&#125;class LenovoPc implements PC&#123; public function work() &#123; echo \"I'm working on a Lenovo computer &lt;br&gt;\"; &#125; public function play() &#123; echo \"Lenovo computers can be used to play games &lt;br&gt;\"; &#125;&#125;abstract class Factory&#123; abstract public static function createPc(); abstract public static function createTv();&#125;class ProductFactory extends Factory&#123; public static function createTV() &#123; return new HaierTv(); &#125; public static function createPc() &#123; return new LenovoPc(); &#125;&#125;$newTv = ProductFactory::createTV();$newTv-&gt;open();$newTv-&gt;watch();$newPc = ProductFactory::createPc();$newPc-&gt;work();$newPc-&gt;play(); 在上面的Factory抽象类中，定义了两个抽象方法，这两个抽象方法分别用来生产不同的产品（即由不同类实例化的对象）。 工厂方法模式和抽象工厂模式对比通过以上代码：我们来对比一下工厂方法模式和抽象工厂模式： 工厂方法模式中 当我需要多生产一种新的产品，比如factoryKid这个产品，我需要专门再设一个factoryKid的工厂，即添加如下代码： 1234567891011121314class Kid implements People&#123; public function say() &#123; echo 'this is a kid'; &#125;&#125;class FactoryKid implements CreatePeople&#123; public function create() &#123; return new Kid(); &#125;&#125; 抽象工厂模式中 同样当我需要多生产一种新的产品，比如生产一个iphone,此时我需要修改工厂父类里的接口，并且在具体工厂类ProductFactory这个工厂里增加一条createPhone生产线(即类里面的方法)，所需添加的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041interface Phone&#123; public function work(); public function sms();&#125;class IPhone implements Phone&#123; public function work() &#123; echo \"I'm iphone &lt;br&gt;\"; &#125; public function sms() &#123; echo \"this is an iphone &lt;br&gt;\"; &#125;&#125;//在原来的抽象工厂类中添加方法声明abstract class Factory&#123; abstract public static function createPc(); abstract public static function createTv(); abstract public static function createPhone();&#125;//在原来的工厂类里添加一个方法class ProductFactory extends Factory&#123; public static function createTV() &#123; return new HaierTv(); &#125; public static function createPc() &#123; return new LenovoPc(); &#125; public static function createPhone() &#123; return new IPhone(); &#125;&#125; 从上面的分析可以看出，要生产一个新的产品，抽象工厂模式并不比工厂方法模式更为便捷，那么抽象工厂模式的好处在哪呢?它优点就是在于是增加固定类型产品的不同具体工厂比较方便，比如我要增加一个生产同样类型产品的具体工厂Product2Factory，那么就再建一个Product2Factory类继承Factory就可以了。 最后的最后，总结一下工厂方法模式和抽象工厂模式的核心区别 工厂方法模式利用继承，抽象工厂模式利用组合 工厂方法模式产生一个对象，抽象工厂模式产生一族对象 工厂方法模式利用子类创造对象，抽象工厂模式利用接口的实现创造对象","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"PHP单例模式的总结","date":"2017-06-19T16:00:00.000Z","path":"2017/06/20/Singleton-Pattern/","text":"什么是单例模式含义单例模式是一种对象的创建模式，它用来确保某一个类只有一个实例，而且自行实例化并向整个系统全局的提供这个实例。 单例模式的特点1、有一个保存类的唯一实例的静态成员变量 2、有一个定义为私有的构造函数，表明这个类是不可能形成实例的，防止出现这个类有多个实例的情况出现（有时也可添加个声明为私有的克隆函数）。 3、提供一个能访问这个实例的声明为公共的静态方法（通常为getInstance方法），用来作为返回唯一实例的引用。 具体实现代码： 1234567891011121314151617181920212223242526272829class Preferences &#123; private $props = array(); private static $instance; private function __construct()&#123; &#125; private function __clone()&#123;&#125;; public static function getInstance()&#123; if(empty(self::$instance))&#123; self::$instance = new Preferences(); &#125; return self::$instance; &#125; public function setProperty($key,$val)&#123; $this-&gt;props[$key] = $val; &#125; public function getProperty($key)&#123; return $this-&gt;props[$key]; &#125; &#125;//调用单例 $pref = Preferences::getInstance(); $pref-&gt;setProperty('name','cjhlfy'); unset($pref); $pref2 = Preferences::getInstance(); echo $pref2-&gt;getProperty('name'); //name的属性值不会丢失,因为实例引用 $instance是静态属性 为什么要用单例模式全局变量是面向对象程序员遇到的引发bug的主要原因之一，这是因为全局变量将捆绑于特定的环境，破坏了封装。如果新的应用程序无法保证一开始就定义了相同的全局变量，那么一个依赖于全局变量的类就无法就无法从一个应用程序中提取出来并应用到新的应用程序中。所以单例模式是一种对于全局变量的改进。 不过，单例模式的使用也有不利的地方，它可能导致很难调试的依赖关系。如果改变一个实例，那么所有使用改单例的类可能都会受到影响。当单例被使用时，依赖便会隐藏在方法内部，而且并不会出现在方法声明里。这使得系统中的依赖关系更难以追踪，因此需要谨慎小心的部署单例类 单例模式应用应用场合1、应用程序与数据库的交互 一个应用中会存在大量的数据库操作，比如通过数据库句柄来连接数据库这一行为，使用单例模式可以避免大量的new操作，因为每一次new操作都会消耗内存资源和系统资源。 2、控制配置信息 如果系统中有有一个类来全局控制某些配置信息，那么使用单例模式就可以很方便实现，并且可以对配置进行统一管理。 以数据库操作为例深入理解12345678910111213141516171819202122232425262728293031323334class DB &#123; private $db; private static $instance; private function __construct()&#123; //进行数据库连接 &#125; private function __clone() &#123; &#125;; public static function getInstance()&#123; if(empty(self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; //数据库查询操作 public function select()&#123; //... &#125; //数据库插入操作 public function insert()&#123; //... &#125;&#125; //数据库编辑操作 public function update()&#123; //... &#125;&#125; //获取数据库单例类实例化之后，便可对数据库进行操作$db = DB::getInstance();$db-&gt;select();$db-&gt;insert();$db-&gt;update(); 单例模式的总结就到这里。 参考：《面向对象、模式与实践》","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"数据库查询中的exists与in分析比较","date":"2017-06-07T16:00:00.000Z","path":"2017/06/08/about-exists/","text":"最近在用Laravel的ORM写数据库查询时，用到了whereHas的写法，这个写法的背后实现的SQL语句就是select * from `table1` where exists(select * from `table2` where table1.id = table2.table1_id),于是就查清楚了一下exists的用法和特点，在这里记录一下。 exists的用法以下图的两张表关系作为分析： exists表示存在，它常常和子查询配合使用。例如对于上图，写下下面的SQL语句 SELECT FROM `user` WHERE exists (SELECT FROM `order` WHERE user.id = order.user_id) 在这里，exists用于检查查询子查询语句是否会至少返回一行数据，如果有返回数据，则返回值是true，反之是false。 放子查询返回为true时，则外层的查询语句将进行查询，反之，外层查询语句将不进行查询或者查不出任何记录。 因此：上面的SQL所实现的意义在于，搜索出所有下过单的会员。 exists和in的区别和使用场景除了exitst，in的使用也可以实现上面语句的效果。如下： SELECT * FROM `user` WHERE id in (SELECT user_id FROM `order`) 那么，它们之间有什么区别呢。 in()语句只会执行一次，它查出order表中的所有user_id字段并且缓存起来，之后，检查user表的id是否和order表中的user_id相当，如果相等则加入结果期，直到遍历完user的所有记录。用程序来表示如下： 123456789101112131415161718192021222324252627$result = [];$users = \"SELECT * FROM `user`\";$orders = \"SELECT user_id FROM `order`\";for($i = 0;$i &lt; $users.length;$i++)&#123; for($j = 0;$j &lt; $orders.length;$j++)&#123; // 此过程为内存操作，不涉及数据库查询。 if($users[$i].id == $orders[$j].user_id)&#123; $result[] = $users[$i]; break; &#125; &#125;&#125;``` 从上面的程序可以明显的看出，当order表数据很大的时候不适合用in,因为最多会将order表数据全部遍历一遍。如：user表有10000条记录,order表有1000000条记录,那么最多有可能遍历10000*1000000次,这样的话效率就很差了。* 再看exists，它的查询过程类似如下：```php $result = [];$users = \"SELECT * FROM `user`\";for($i=0;$i&lt;$users.length;$i++)&#123; if(exists($users[$i].id))&#123;// 执行SELECT * FROM `order` WHERE user.id = order.user_id $result[] = $users[$i]; &#125;&#125; 显而易见：当order表比user表大很多的时候，使用exists是再恰当不过了，它没有那么多遍历操作,只需要再执行一次查询就行。查询次数的多少完全取决于user表的记录条数。 但是：如果说user表有10000条记录,order表有100条记录,那么exists()还是执行10000次,反而不如使用in()遍历10000*100次,因为in()是在内存里遍历,而exists()需要查询数据库,我们都知道查询数据库所消耗的性能比较大,而操作内存的话会比较快. 因此，可以得出总结： 若外层查询表小于子查询表，则用exists。 若外层查询表(记录条数很多)远大于子查询表，则考虑用in。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"}]},{"title":"PHP的匿名函数和闭包","date":"2017-05-23T16:00:00.000Z","path":"2017/05/24/php-closure/","text":"匿名函数匿名函数（Anonymous function），也叫闭包函数（closures），允许临时创建一个没有指定名称的函数，最经常用作回调函数（callback）参数的值。 匿名函数的实现匿名函数是目前是通过Closure类来实现，匿名函数会产生这个类的对象。自PHP 5.4起，这个类带有一些方法，允许在匿名函数创建后对其进行更多的控制。 注意：PHP手册特别说明__invoke()这个魔术方法与匿名函数的实现过程无关。 Closure类如下： 12345678910Closure &#123; /* 方法 */ __construct ( void ) public static Closure bind ( Closure $closure , object $newthis [, mixed $newscope = 'static' ] ) public Closure bindTo ( object $newthis [, mixed $newscope = 'static' ] ) &#125;Closure::__construct — 用于禁止实例化的构造函数Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。 匿名函数例子： 1234$func = function($str)&#123; echo $str;&#125;;$func('hello'); 闭包闭包是指在创建时封装周围状态(如变量)的函数，即使闭包所在的环境的不存在了，闭包中封装的状态依然存在。 闭包的实现将匿名函数放在一个普通函数中（也可以将匿名函数返回），就构成了一个闭包。 1234567function closureFunc()&#123; $func = function()&#123; echo 'hello'; &#125; $func();&#125;closureFunc();//输出:hello 闭包的使用在匿名函数中引入局部变量时需要用到use关键字。这是因为PHP中的变量范围只在它的生效范围中。在匿名函数里并没有对变量进行定义，所以需要使用use关键字 123456789function closureFunc1()&#123; $num = 1; $func = function() use($num)&#123; echo $num; &#125;; $func();&#125;closureFunc2();//输出 闭包返回匿名函数并传参 12345678910function closureFunc2()&#123; $num = 1; $func = function($str) use($num)&#123; echo $num; echo $str; &#125;; return $func;&#125;$func = $closureFunc2();$func('hello');//输出 1 hello","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP手册【4】——类与对象（二）","date":"2017-05-09T16:00:00.000Z","path":"2017/05/10/review-php-04/","text":"Final关键字如果父类中的方法被声明为final,则子类无法继承。如果一个类被声明为final，则不能被继承。 NOTE: 属性不能被定义为final,只有类和方法才能被定义为final. 类型约束类型约束即函数的参数可以指定必须为对象、接口、数组或者callable。如果一个类或接口。类型约束不能用于标量类型如int或string。Trait也不允许。例子如下： 1234567891011121314151617181920212223242526272829303132class MyClass&#123; /** * 测试函数 * 第一个参数必须为 OtherClass 类的一个对象 */ public function test(OtherClass $otherclass)&#123; echo $otherclass-&gt;var; &#125; /** * 另一个测试函数 * 第一个参数必须为数组 */ public function test_array(array $input_array) &#123; print_r($input_array); &#125; /** * 第一个参数必须为递归类型 */ public function test_interface(Traversable $iterator) &#123; echo get_class($iterator); &#125; /** * 第一个参数必须为回调类型 */ public function test_callable(callable $callback, $data) &#123; call_user_func($callback, $data); &#125;&#125; 当函数调用的参数与定义的参数类型不一致时，会抛出一个致命的错误。 后期静态绑定这个目前不知道什么用处，先直接看例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Example #1 self:: 用法&lt;?phpclass A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; self::who(); &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test();?&gt;以上例程会输出：AExample #2 static:: 简单用法&lt;?phpclass A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; static::who(); // 后期静态绑定从这里开始 &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test();?&gt;以上例程会输出：B","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP手册【3】——类与对象（-）","date":"2017-04-22T16:00:00.000Z","path":"2017/04/23/review-php-03/","text":"类与对象构造函数和析构函数 构造函数 具有构造函数的类会在每次创建新对象时先调用此方法，所以适合在使用对象前做一些初始化工作。 Note: 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承。 析构函数 析构函数会在某个对象的所有引用都被删除或者当对象被显式销毁时执行。 访问控制被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其自身访问。例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** * Define MyClass */class MyClass&#123; public $public = 'Public'; protected $protected = 'Protected'; private $private = 'Private'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj = new MyClass();echo $obj-&gt;public; // 这行能被正常执行echo $obj-&gt;protected; // 这行会产生一个致命错误echo $obj-&gt;private; // 这行也会产生一个致命错误$obj-&gt;printHello(); // 输出 Public、Protected 和 Private/** * Define MyClass2 */class MyClass2 extends MyClass&#123; // 可以对 public 和 protected 进行重定义，但 private 而不能 protected $protected = 'Protected2'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj2 = new MyClass2();echo $obj2-&gt;public; // 这行能被正常执行echo $obj2-&gt;private; // 未定义 privateecho $obj2-&gt;protected; // 这行会产生一个致命错误$obj2-&gt;printHello(); // 输出 Public、Protected2 和 Undefined 抽象类定义为抽象的类不能被实例化。如果某个类里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。 继承一个抽象类时，子类必须定义父类中的所有抽象方法；另外这些方法的访问控制必须和父类中一样（或者更为宽松） TraitPHP是单继承语言，trait是为这种单继承语言而准备的一种代码复用机制，Trait使开发人员可以自由的在不同层次结构内独立的类中复用方法。示例如下： 1234567891011121314151617&lt;?phptrait ezcReflectionReturnInfo &#123; function getReturnType() &#123; /*1*/ &#125; function getReturnDescription() &#123; /*2*/ &#125;&#125;class ezcReflectionMethod extends ReflectionMethod &#123; use ezcReflectionReturnInfo; /* ... */&#125;class ezcReflectionFunction extends ReflectionFunction &#123; use ezcReflectionReturnInfo; /* ... */&#125;?&gt; 优先级从基类继承的成员会被trait插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了trait的方法，而trait则覆盖了被继承的方法。例： 1234567891011121314151617&lt;?phptrait HelloWorld &#123; public function sayHello() &#123; echo 'Hello World!'; &#125;&#125;class TheWorldIsNotEnough &#123; use HelloWorld; public function sayHello() &#123; echo 'Hello Universe!'; &#125;&#125;$o = new TheWorldIsNotEnough();$o-&gt;sayHello();?&gt; 以上例程会输出： Hello Universe! 重载重载是指动态的”创建”类属性和方法。是通过魔术方法来实现的。 当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。 属性重载 在给不可访问（或未定义）属性赋值时，__set()会被调用 在读取不可访问（或未定义）属性时，__get()会被调用 当对不可访问（或未定义）属性调用isset()或empty()时，__isset()会被调用 当对不可访问（或未定义）属性调用unset()时，__unset()会被调用 方法重载使用__call()函数和__callStatic()函数 在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP手册【2】——变量、常量、函数","date":"2017-04-09T16:00:00.000Z","path":"2017/04/10/review-php-02/","text":"变量变量范围变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的PHP变量只有一个单独的范围。这个单独的范围跨度同样包含了include和require引入的文件。例如： 1234&lt;?php $a = 1; include 'b.php';?&gt; 这里变量$a将会在包含文件b.php中生效。但是，在用户自定义函数中，一个局部函数范围将被引入，任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。例如 123456789&lt;?php $a =1;//全局 function Test() &#123; echo $a; //位于函数内部 &#125; Test()； ?&gt; 这个脚本将不会有任何输出，因为echo语句引用了一个局部版本的变量$a，它并没有被赋值。PHP的全局变量和C语言的有一点点不同，在C语言中，全局变量在函数中自动生效，除非被局部变量覆盖。而PHP中全局变量在函数中使用时必须声明为global。 global关键字例： 1234567891011&lt;？php $a = 1; $b = 2; function sum() &#123; global $a,$b; $b = $a + $b; &#125; sum(); echo $b;?&gt; 以上脚本的输出将是3。 在函数中声明了全局变量 $a 和 $b 之后，对任一变量的所有引用都会指向其全局版本。对于一个函数能够声明的全局变量的最大个数，PHP 没有限制。 在全局范围内访问变量的第二个办法，是用特殊的 PHP 自定义 $GLOBALS 数组。 使用静态变量变量范围的另一个重要特性是静态变量（static variable）。静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不会丢失。例如： 12345678&lt;?php function test() &#123; $a = 0; echo $a; $a++; &#125;?&gt; 该函数没什么用处，因为每次调用时都会将$a的值设为0并输出0。将变量加一的$a++没有作用，因为一旦退出本函数则变量$a就不存在了。要写一个不会丢失本次计数值的技术函数，要将变量$a定义为静态的。如下例子： 12345678&lt;?php function test() &#123; static $a = 0; echo $a; $a++; &#125;?&gt; 现在，变量$a仅在第一次调用test()函数时被初始化，之后每次调用test()函数都会输出$a的值并加一。 静态变量也提供了一种处理递归函数的方法。写递归函数的时候，可能会无穷递归下去。必须确保有充分的方法来终止递归。以下的简单的例子说明使用静态变量来判断何时停止。 12345678910111213&lt;?php function test() &#123; static $count = 0; $count++; echo $count; if($count &lt; 10) &#123; test(); &#125; $count--; &#125;?&gt; 可变变量将变量名再赋予某个变量 可变函数将函数名赋予某个变量，当调用该变量外加括号时，即调用该函数。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"计算机组成","date":"2017-03-21T16:00:00.000Z","path":"2017/03/22/Computer/","text":"冯诺依曼结构的工作原理计算机组成的依据是冯诺依曼结构，它将计算机分为以下五大组成部分： 运算器+控制器（CPU） 存储器（内存） 输入设备 输出设备 数据和指令以二进制形式，不加区别的存放在存储器中。 速度不匹配问题由于CPU的运行速度非常快，与主存储器，磁盘的I/O速度相差非常大（千百倍以上），为了解决这个问题，计算机采用将CPU “忙死” 的方法。对于程序的执行采用以下方案： 同步 =&gt; 异步 即CPU在运行程序时，当某个程序需要它来运行时它才动作，不需要它运行时，CPU去运行别的程序去。 顺序 =&gt; 并发 将多个程序并发执行，CPU在这些程序里进行很快速的切换（由操作系统控制），这样会使人觉得好像每个程序同时运行一样，其实在每个时间点时（极短），CPU只执行一个程序。 增加中间层：缓存 1、当CPU要读取一个数据时，首先从CPU缓存中查找，找到就立刻读取并送给CPU处理；2、没有找到，就从速率相对较慢的内存中读取并送给CPU处理，同时把这个数据所在的数据块调入缓存中，可以使得以后对CPU数据的读取都从缓存中进行，不必在调用内存。 按下电源之后发生了什么 按下电源，主板开始供电 主板向CPU发出RESET信号 当RESET信号撤去后，CPU开始干活，去一个特定的内存地址查找第一条指令（这是一条跳转指令，跳转到系统BIOS中真正的启动代码处） BIOS的代码对系统进行自检：内存，硬盘，显卡..如果硬件出现问题，主板会发出不同含义的蜂鸣，启动终止。如果没有问题，屏幕就会出现CPU、内存、硬盘等信息。 hello world的一生 程序写好了以后，编译成二进制文件（包含机器语言指令），存放在硬盘中。 运行hello world程序，操作系统吧helloworld从硬盘读到内存 CPU开始执行main程序中的机器语言指令 机器语言指令把”helloworld”字符串从内存复制到寄存器 机器语言把寄存器数据复制到显示设备，显示在屏幕上。","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://www.tenpercent.top/tags/计算机基础/"}]},{"title":"重温PHP手册【1】——基础句法和类型","date":"2017-03-10T16:00:00.000Z","path":"2017/03/11/review-php-01/","text":"前言：最近想开始好好提升一下自己的英语水平，因为感觉熟练的英语是每一个优秀软件工程师的基本功，虽然是一枚过了六级的选手，但是感觉英文阅读和写作都还是有些压力。正巧听闻有个PHP高手说他把PHP官方手册读了不下8遍，深以为然，孰能生巧这个道理放在哪里都没有错。所以第一步我打算开始重温PHP手册，在加强自己英语水平的同时来达到温故而知新的目的。 1、PHP tagsWhen PHP parses a file, it look for opening and closing tags, which are &lt;?phpand ?&gt; which tell PHP to start and stop interpreting the code between them.if a file is pure PHP code, it is preferable to omit the PHP closing tag at the end of the file. This prevents accidental whitespace or new lines being added after the PHP closing tag, which may cause unwanted effects because PHP will start output buffering when there is no intention from the programmer to send any output at that point in the script. 12345&lt;?php echo \"hello chenjiehui!\"; //...more code echo \"last statement.\"; // the script ends here with no PHP closing tag 2、Escaping from HTMLEverything outside of a pair of opening and closing tags is ignored by the PHP parser which allows PHP files to have mixed content. This allows PHP to be embedded in HTML documents.But there is one exception that in the middle of a conditional statement in which case the interpreter will determine the outcome of the confitional before making a decision of what to skip over. See the next example. Using structures with conditions. 12345&lt;?php if($expression == true) : ?&gt; This will show if the expression is true.&lt;?php else : ?&gt; Otherwise this will show.&lt;?php endif; ?&gt; In this example PHP will ship the blocks where the condition is not met, even though they are outside of the PHP open/close tags;For outputting large blocks of text, dropping out of PHP parsing mode is generally more effcient than sending all of text through echo or print. Starting with PHP 5.4, short echo tag &lt;?= is always recongnized and vaild, regardless of the short_open_tag setting. 3、CommentsPHP support ‘C’,’C++’ and Unix shell-style(Perl style) comments. For example: 1234567&lt;?php echo 'this is a test'; //this is a one line c++ style comment /* This is a multi line comment yet another line of comment */ echo 'This is yet another test'; echo 'one Final Test'; # This is a one-line shell-style comment?&gt; ##4、typePHP supports eight primitive types(原始数据类型): Four scalar types(标量类型): boolean integer float(aka(又称作) double) string Three compound types: array object callable And finally two special types resource NULL This manual also introduces some pseudo-types(伪类型) for readability reasons： mixed number callback array|object void And the pseudo-variable $…The type of the variable is not usually set by programmer; rather(确切的说), it is decided at runtime by PHP depending on the context in which that variable is used. Note: To check the type and variable of the expression, use the var_dump() function.To get a human-readable representation of a type for debugging, use the gettype() function. To check for a certain type, do not use gettype(), but rather the is_type functions. Some examples: 123456789101112131415&lt;?php $a_bool = TRUE ; $a_str = \"foo\"; $a_str2 = 'foo'; $an_int = 12; echo gettype($a_bool);//print out: boolean echo gettype($a_str);//print out: string if(is_int($an_int))&#123; $an_int+=4; &#125; if (is_string($a_bool)) &#123; echo \"String: $a_bool\"; &#125;?&gt;&gt; To forcibly(强制地) convert a variable to a certain type, either cast(eg: (bool)$a_str) or use the settype() function on it.Note that a variable may be evaluated(被评估) with diffrent values in certain situations, depending on what type it is at the time.","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"操作系统【1】——导论","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/operating-system-01/","text":"操作系统是管理计算机硬件的程序，它还为应用程序提供基础，并充当计算机硬件和计算机用户的中介。大型机的操作系统设计主要目的是为了充分优化硬件的使用率，个人计算机的操作系统是为了能够支持从复杂游戏到商业应用的各种事物，手持计算机的操作系统是为了给用户一个可以与计算机方便的交互并执行程序的环境。因此，有的操作系统设计是为了方便，有的是为了高效，而有的设计目标则是兼而有之。 本章目标 提供对操作系统主要部件的浏览 提供基本的计算机系统体系结构的概述 1.1 操作系统做什么从计算机的角度来看，操作系统是与硬件最为密切的程序。计算机系统可能有许多资源，用来解决CPU时间、内存时间、文件存储空间、I/O设备等问题。操作系统管理这些资源。面对许多甚至冲突的请求，操作系统必须决定如何为各个程序和用户分配资源，以便计算机系统能够有效而公平的运行。众所周知，资源分配对多用户访问主机或微型计算机特别重要。操作系统是控制程序。控制程序管理用户程序的执行以防止计算机资源的错误使用或使用不当。它特别关注I/O设备的操作和控制。 1.1.1 定义操作系统一个比较公认的定义是，操作系统是一直运行在计算机上的程序（通常称之为内核），其他程序为系统程序和应用程序。 1.2 计算机系统组织1.2.1 计算机系统操作当计算机打开电源或重启时，计算机开始运行，它需要运行一个初始化程序，该初始化程序或引导程序（bootstrap program）比较简单，通常位于ROM或EEPROM中，称为计算机硬件中的固件。它初始化系统中的所有部分，包括CPU寄存器、设备控制器和内存内容。引导程序必须知道如何装入操作系统并开始执行系统。为了完成这一目标，引导程序必须定位操作系统内核并把它转入内存，接着，操作系统孔i是执行第一个进程如init，并等待事件的发生。事件的发生通常通过硬件或软件中断（interrupt）。硬件可随时通过系统总线向CPU发出信号，以触发中断。软件通过执行特别操作如系统调用（system call）也称为监视器调用（monitor call））也能触发中断。 1.2.2 存储结构计算机程序必须在内存（或随机访问内存（random access memory）RAM ）中以便于运行。内存是处理器可以直接访问的唯一的大容量存储区域（数兆到数千兆字节）。它通常是用被称为动态随机访问内存（dynamic random access memory,DRAM）的半导体技术来实现的，是一组内存字的数组，每个字都有其地址。通过对特定内存地址执行一系列load或store指令来实现交互。指令load能将内存中的字转移到CPU的寄存器中，而指令store能将寄存器的内容移到内存。除了显式使用load和store外，CPU可自动从内存中装入指令来执行。 一个典型指令执行周期（在冯诺依曼体系结构上执行时）首先从内存中获取指令，并保存在指令寄存器中。接着，指令被解码，并可能导致从内存中获取操作数或将操作数保存在内部寄存器中。在指令完成对操作数的执行，其结果可以存回到内存。注意内存单元只看见内存地址流，它并不知道它们是如何产生，或者它们是什么地址。相应地，可忽视程序如何产生内存地址，只对程序运行所产生的地址序列感兴趣。 由于内存太小以及内存是易失性存储设备，所以绝大多数计算机需要提供辅存，最常用的辅存设备为磁盘，它能存储程序和数据。绝大多数程序（浏览器，编译器，制表软件等）保存在磁盘上，直到要执行时才装入到内存中。许多程序都是使用磁盘来作为它们所处理信息的来源和目的。因此，适当的管理磁盘存储对计算机系统来说十分重要。 存储设备层次 寄存器 =&gt; 高速缓存 =&gt; 主存 =&gt; 电子磁盘 =&gt; 磁盘 =&gt; 光盘 =&gt; 磁带 1.3 计算机系统体系结构 单处理器系统 绝大多数系统采用单处理器，在单处理器系统中，有一个主CPU能够执行一个通用的指令集，包括来自于用户进程的指令。 多处理器系统 多处理器系统有多个紧密通信的CPU，它们共享计算机总线，有时还有时钟、没存和外设等。多处理器系统主要有三个优点： 1、增加吞吐量：通过增加处理器的数量，希望能够在更短的时间内做更多的事情。用N个处理器的加速比不是N，而是比N小。当多个CPU在同一件事情上时，为了使得各部分能正确工作，会产生一定的额外开销。这些开销，加上对共享资源的竞争，会降低因为增加了CPU的期望增益。这与一组N为程序员在一起紧密地工作，并不能完成N倍的单个程序员的工作量类似。 2、规模经济：多处理器系统比单个处理器系统能节省资金。 3、增加可靠性：如果将功能分布在多个处理器上，那么单个处理器的失灵将不会使得整个系统停止，只会使它变慢。如果有一个处理器出现故障，那么剩下的处理器会分担起故障处理器的那部分工作。 1.3.1 集群系统多CPU系统的另一种类型是集群系统（clustered system）。与多处理器系统一样，集群系统将多个CPU集中起来完成计算任务。然而，集群系统与多处理器系统不同，它是由两个或多个独立的系统耦合起来的。集群系统通常用来提供高可用服务，这意味着即使集群中的一个或多个系统出错，服务仍在运行。 集群分为非对称集群和对称集群 非对称集群 一台机器处于热备份模式（hot standby mode），而另一台运行应用程序。热备份主机只监视活动服务器。如果该服务器失效，那么热备份主机会成为现行服务器 对称集群 两个或者多个主机都运行应用程序，它们互相监视。这种模式因为充分使用了现有硬件，所以更为高效。","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://www.tenpercent.top/tags/计算机基础/"}]}]