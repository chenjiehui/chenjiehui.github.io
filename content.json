[{"title":"Redis过期key是怎么清理的","date":"2020-03-27T16:00:00.000Z","path":"2020/03/28/Redis过期key是怎么清理的/","text":"Redis 的 key 清理，也就是内存回收的时候主要分为：过期删除策略与 内存淘汰策略两部分。 过期删除策略删除到达过期时间的 key 。 第一种：定时检查删除对于每一个设置了过期时间的 key 都会创建一个定时器，一旦达到过期时间都会删除。这种方式立即清除过期数据，对内存比较好， 但是有缺点是：占用了大量 CPU 的资源去处理过期数据，会影响 redis 的吞吐量 和 响应时间。 第二种：惰性检查删除当访问一个 key 的时候，才会判断该 key 是否过期，如果过期就删除。该方式能最大限度节省 CPU 的资源。 但是对内存不太好，有一种比较极端的情况：出现大量的过期 key 没有被再次访问，因为不会被清除，导致占用了大量的内存。 第三种：定期检查删除每隔一段时间，扫描redis 中过期key 的字典，并清除部分过期的key。这种方式是前俩种一种折中方法。不同的情况下，调整定时扫描时间间隔，让CPU 与 内存达到最优。 内存淘汰策略Redis 内存淘汰策略是指达到maxmemory极限时，使用某种算法来决定来清理哪些数据，以保证新数据存入。 第一类 不处理，等报错(默认的配置) noeviction，发现内存不够时，不删除key，执行写入命令时直接返回错误信息。（Redis默认的配置就是noeviction） 第二类 从所有结果集中的key中挑选，进行淘汰 allkeys-random 就是从所有的key中随机挑选key，进行淘汰 allkeys-lru 就是从所有的key中挑选最近使用时间距离现在最远的key，进行淘汰 allkeys-lfu 就是从所有的key中挑选使用频率最低的key，进行淘汰。（这是Redis 4.0版本后新增的策略） 第三类 从设置了过期时间的key中挑选，进行淘汰这种就是从设置了expires过期时间的结果集中选出一部分key淘汰，挑选的算法有： volatile-random 从设置了过期时间的结果集中随机挑选key删除。 volatile-lru 从设置了过期时间的结果集中挑选上次使用时间距离现在最久的key开始删除 volatile-ttl 从设置了过期时间的结果集中挑选可存活时间最短的key开始删除(也就是从哪些快要过期的key中先删除) volatile-lfu 从过期时间的结果集中选择使用频率最低的key开始删除（这是Redis 4.0版本后新增的策略）","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"Redis","slug":"Redis","permalink":"http://www.tenpercent.top/tags/Redis/"}]},{"title":"Redis的持久化是怎么实现的","date":"2020-03-22T16:00:00.000Z","path":"2020/03/23/Redis的持久化是怎么实现的/","text":"Redis因为Redis是基于内存的数据库，一旦断电，所有实例都会关机，所有数据都会丢失，在运行期间，可以通过开启Redis的持久化功能，将数据写入磁盘，供实例重启时恢复数据。Redis的持久化主要通过AOF和RDB实现持久化。 AOF持久化AOF持久化主要是Redis在修改相关的命令后，将命令添加到aof_buf缓存区（aof_buf是Redis中的SDS结构，SDS结构可以认为是对C语言中字符串的扩展）的末尾，然后在每次事件循环结束时，根据appendfsync的配置（always是总是写入，everysec是每秒写入，no是根据操作系统来决定何时写入），判断是否需要将aof_buf写入AOF文件。生产环境中一般用默认配置everysec，也就是每秒写入一次，一旦挂机会丢掉1分钟的数据。 12345678910struct redisServer &#123; /* AOF buffer, written before entering the event loop */ sds aof_buf;//aof_buf缓冲区其实就是Redis的一个简单动态字符串 &#125;struct sdshdr &#123; unsigned int len; unsigned int free; char buf[];&#125;; RDB持久化基本定义RDB持久化指的是在满足一定的触发条件时（在一个的时间间隔内执行修改命令达到一定的数量，或者手动执行SAVE和BGSAVE命令），对这个时间点的数据库所有键值对信息生成一个压缩文件dump.rdb，然后将旧的删除，进行替换。（在Redis默认的配置下，RDB是开启的，AOF持久化是关闭的） 实现原理实现原理是fork一个子进程，然后对键值对进行遍历，生成rdb文件，在生成过程中，父进程会继续处理客户端发送的请求，当父进程要对数据进行修改时，会对相关的内存页进行拷贝，修改的是拷贝后的数据。（也就是COPY ON WRITE，写时复制技术，就是当多个调用者同时请求同一个资源，如内存或磁盘上的数据存储，他们会共用同一个指向资源的指针，指向相同的资源，只有当一个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给这个调用者，其他调用者还是使用最初的资源,在CopyOnWriteArrayList的实现中，也有用到，添加或者插入一个新元素时过程是，加锁，对原数组进行复制，然后添加新元素，然后替代旧数组，解锁） 123456789101112131415//CopyOnWriteArrayList的添加元素的方法public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 点击复制代码复制出错复制成功AOF和RDB的区别是什么？AOF因为是保存了所有执行的修改命令，粒度更细，进行数据恢复时，恢复的数据更加完整，但是由于需要对所有命令执行一遍，效率比较低，同样因为是保存了所有的修改命令，同样的数据集，保存的文件会比RDB大，而且随着执行时间的增加，AOF文件可能会越来越大，所有会通过执行BGREWRITEAOF命令来重新生成AOF文件，减小文件大小。Redis服务器故障重启后，默认恢复数据的方式首选是通过AOF文件恢复，其次是通过RDB文件恢复。 RDB是保存某一个时间点的所有键值对信息，所以恢复时可能会丢失一部分数据，但是恢复效率会比较高。 怎么防止AOF文件越来越大？为了防止AOF文件越来越大，可以通过执行BGREWRITEAOF命令进行AOF重写，会fork子进程出来，读取当前数据库的键值对信息，生成所需的写命令，写入新的AOF文件。在生成期间，父进程继续正常处理请求，执行修改命令后，不仅会将命令写入aof_buf缓冲区，还会写入重写aof_buf缓冲区。当新的AOF文件生成完毕后，子进程父进程发送信号，父进程将重写aof_buf缓冲区的修改命令写入新的AOF文件，写入完毕后，对新的AOF文件进行改名，原子地（atomic）地替换旧的AOF文件。 AOF重写命令可以手动执行，在满足一些条件时，Redis也会自动触发。自动触发的条件如下： 没有 BGSAVE 命令在执行。没有 BGREWRITEAOF 在执行。当前AOF文件大小 &gt; server.aof_rewrite_min_size(默认为1MB)。当前AOF文件大小和最后一次AOF重写后的大小之间的比率大于等于指定的增长百分比(默认为1倍，100%，也就是当前AOF文件大小&gt;=上次重写后文件的2倍后)","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"Redis","slug":"Redis","permalink":"http://www.tenpercent.top/tags/Redis/"}]},{"title":"InnoDB 缓冲池(buffer pool) 工作原理","date":"2020-02-15T16:00:00.000Z","path":"2020/02/16/Innodb-buffer-pool/","text":"缓冲池的用处对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引，还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只是 InnoDB 对文件系统上一个或几个实际文件的抽象，也就实际数据说到底还是存储在磁盘上的。 磁盘的速度很慢，怎么能配得上“快如闪电”的CPU 呢？ InnoDB 存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中。 也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。 缓冲池内部组成缓冲池中默认的缓存页大小和在磁盘上默认的页大小是一样的，一般是16KB。 为了更好的管理这些在缓冲池中的缓存页，InnoDB为每一个缓存页都创建了一些所谓的控制信息。 这些控制信息包括该页所属的表空间编号、页号、缓存页在缓冲池中的地址、链表节点信息、一些锁信息。 缓冲池的一些参数：SHOW VARIABLES LIKE ‘innodb_buffer_pool%’;free 链表当最初启动MySQL服务器的时候，此时并没有真实的磁盘页被缓存到缓冲池中，之后随着程序的运行，会不断的有磁盘上的页被缓存到缓冲池中。 从磁盘上读取一个页到缓冲池中的时候该放到哪个缓存页的位置呢？ 思路：区分缓冲池中哪些缓存页是空闲的，哪些已经被使用了。 把所有空闲的缓存页对应的控制块作为节点放到一个链表中，这个链表叫作 free 链表。 flush 链表如果我们修改了缓冲池中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为脏页（dirty page）。 最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能。 所以，Innodb 创建了一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，在未来的某个时间点进行同步。这个链表叫做 flush 链表。 缓存不够的窘境缓冲池对应的内存大小毕竟是有限的，如果需要缓存的页占用的内存大小超过了缓冲池大小，也就是已经没有多余的空闲缓存页的时候怎么办？ 把某些旧的缓存页从缓冲池中移除，然后再把新的页放进来。 移除哪些缓存页？这就需要引入缓存淘汰机制了。 缓存淘汰机制缓存淘汰有以下两个目的： 实现淘汰 使缓存命中率高 缓存淘汰机制比较常用的是用 LRU （Least recently used）算法。 传统LRU LRU 的两种情况： （1）页已经在缓冲池里，那就只做“移至”LRU头部的动作，而没有页被淘汰； （2）页不在缓冲池里，除了做“放入”LRU头部的动作，还要做“淘汰”LRU尾部页的动作； 在 InnoDB 中，传统的 LRU 会遇到两个问题： （1）预读失效； （2）缓冲池污染； 什么是预读失效？ 由于预读 (Read-Ahead)，提前把页放入了缓冲池，但最终 MySQL 并没有从页中读取数据，称为预读失效。 如何对预读失效进行优化？ 要优化预读失效，思路是： （1）让预读失败的页，停留在缓冲池 LRU 里的时间尽可能短； （2）让真正被读取的页，才挪到缓冲池 LRU 的头部； 以保证，真正被读取的热数据留在缓冲池里的时间尽可能长。 具体方法是： （1）将LRU分为两个部分： new 区(new sublist) old 区(old sublist) （2）两个区首尾相连，即：new 区的尾(tail)连接着 old 区的头(head)； （3）新页（例如被预读的页）加入缓冲池时，只加入到 old 区头部：如果数据真正被读取（预读成功），才会加入到 new 区的头部如果数据没有被读取，则会比 new 区里的“热数据页”更早被淘汰出缓冲池 改进版缓冲池LRU能够很好的解决“预读失败”的问题。 查看系统变量 innodb_old_blocks_pct 的值来确定old区域在LRU链表中所占的比例SHOW VARIABLES LIKE ‘innodb_old_blocks_pct’; 什么是 MySQL 缓冲池污染？当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况叫缓冲池污染。 例如，有一个数据量较大的用户表，当执行select * from user where name like “%test%”; 要优化缓冲池污染，思路是： （1）不让批量扫描的大量数据进入到 new 区； （2）让真正被读取的页，才挪到缓冲池 LRU 的头部； 具体实现：加入了一个“old 区停留时间”的机制：在 old 区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，如果后续再次访问的时间与第一次访问的时间在某个时间间隔内（即该缓存页在 old 区的存在时间在某个时间间隔内），那么该页面就不会被从old 区移动到 new 区的头部。 上述的全表扫描执行： (1) 扫描过程中，需要新插入的数据页，都被放到old区 (2) 一个数据页会有多条记录，因此一个数据页会被访问多次 (3) 由于是顺序扫描,数据页的第一次被访问和最后一次被访问的时间间隔不会超过1S，因此还是会留在old区 (4) 继续扫描，之前的数据页再也不会被访问到，因此也不会被移到 new 区，最终很快被淘汰 这个间隔时间是由系统变量 innodb_old_blocks_time 控制的。 SHOW VARIABLES LIKE &#39;innodb_old_blocks_time&#39;; 配置缓冲池时的注意事项innodb_buffer_pool_size innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances 的倍数（这主要是想保证每一个 缓冲池 实例中包含的 chunk 数量相同）。 查看Buffer Pool的状态信息 SHOW ENGINE INNODB STATUS\\G 一些参数如下： Total memory allocated ：代表 Buffer Pool 向操作系统申请的连续内存空间大小，包括全部控制块、缓存页、以及碎片的大小。 Buffer pool size：代表该 Buffer Pool 可以容纳多少缓存页，单位是页 Free buffers：代表当前 Buffer Pool 还有多少空闲缓存页，也就是 free 链表中还有多少个节点。 Database pages：代表 LRU 链表中的页的数量，包含 new 和 old 两个区域的节点数量。 Old database pages：代表 LRU 链表 old 区域的节点数量。 Modified db pages：代表脏页数量，也就是 flush 链表中节点的数量。 总结1、磁盘太慢，用内存作为缓存很有必要。 2、缓冲池本质上是InnoDB向操作系统申请的一段连续的内存空间，可以通过innodb_buffer_pool_size 来调整它的大小。 3、InnoDB 使用了许多链表来管理缓冲池。 4、缓冲池的常见管理算法是 LRU 5、InnoDB 对普通 LRU 进行了优化：分为 new 区和 old 区，加入“停留时间”机制。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"}]},{"title":"MySQL的隔离级别以及 MVCC 的原理","date":"2020-01-16T16:00:00.000Z","path":"2020/01/17/MySQL的隔离级别以及 MVCC 的原理/","text":"隔离级别有哪些？未提交读事务还没有提交的修改，其他事务都可以读取到。可能会有脏读的问题，就是读到一些未提交的脏数据。 提交读其他事务提交的修改，事务在执行过程中可以读取到，如果一个事务在执行过程中需要两次读取同一行数据，可能会不一致。一般发生在UPDATE和DELETE操作。（大部分数据库系统是采用的这个，但是mysql不是） 这个隔离级别下，读是不加锁的，写，更新，删除是加锁的，如果更新的行是可以通过索引查找到，那么是对这些行加行锁，否则会将所有行都加锁，然后返回给MySQL Server，让他来进行过滤，对于不满足条件的行解锁。 但是还是会有幻读的问题发生(幻读就是事务A在读取和写入符合的条件的记录时，其他事务又插入了一条符合条件的记录，此时事务A二次读取时会产生幻行，一般发生在INSERT操作。) 可重复读在事务开始时，记录当时的状态，在第二次读取同一行数据时，除非是本事务做的修改，否则读取的都是事务开始时的数据。可以解决脏读的问题，没法解决幻读的问题。这是MySQL的默认事务隔离级别。（MySQL在可重复读的隔离级别下，通过MVCC机制和Next-key Lock解决了幻读的问题。） 可串行化强制事务串行执行，会让读取每一行都加锁，读用读锁，写用写锁，读写锁互斥，可以解决幻读的问题。并发比较多的话可能会造成大量的超时等待和锁竞争。如果业务并发的特别少或者没有并发，同时又要求数据及时可靠的话 MVCC的实现原理mvcc主要适用于可重复读，可以解决幻读的问题。 innodb在解决幻读的问题主要是通MVVC 多版本并发版本控制来实现的 就是每一行数据中额外保存两个隐藏的列： 插入或上次更新该行的事务ID(删除也被认为是一次更新，只不过在代表删除的更新操作中，行中的特殊位被设置为将其标记为已删除。这个事务ID可以认为是数据行的修改版本号。) 滚动指针(指向undo log中用于事务回滚的日志记录)。 具体流程： 1.插入操作每次开始事务时，会对系统版本号+1作为当前事务的版本号。 插入数据后，将事务的版本号作为数据行的创建版本号。 2.删除操作在使用SQL语句删除行时，并不会立即将其从数据库中物理删除，只会将其标记为删除，并且修改更新该行的事务ID。（InnoDB只会在丢弃为删除而编写的undo log日志记录时，才物理删除相应的行及其索引记录。此删除操作称为purge，它非常快，通常花费与执行删除操作的SQL语句相同的时间顺序。） 4.或更新操作将当前的事务版本号作为数据行的更新版本号。 5.查询操作数据行要被查询出来必须满足两个条件， 数据行没有标记为删除或者标记为删除但是删除的事务ID&gt;当前事务ID的数据（否则数据已经被标记删除了) 更新事务ID&lt;=当前事务ID的数据（否则数据是后面的事务创建出来的，或者是被修改过的，那么需要去undo log中找上次的快照数据。） 如果查询时，该行数据被加了X锁，那么读数据的事务不会进行等待，而是会根据该行数据中的回滚指针undo log日志中读之前版本的数据（这里存储的数据本身是用于回滚的），在可重复读的隔离级别下，从undo log中读取的数据总是事务开始时的快照数据(也就是版本号小于当前事务id的数据)，在提交读的隔离级别下，从undo log中读取的总是最新的快照数据。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"http://www.tenpercent.top/tags/事务/"}]},{"title":"为什么 InnoDB 使用 B+ 树","date":"2019-11-15T16:00:00.000Z","path":"2019/11/16/为什么 InnoDB 使用 B+ 树/","text":"每一种解决方案都是为了解决某一类问题而产生，所以在问为什么使用某种方案的时候，其本质就是在探索该方案是用来满足什么样的需求，解决什么样的问题。 所以探究 InnoDb 为什么使用 B+ 树这个问题，就是要弄清楚 B+ 树是用来满足什么的需求，解决什么样的问题。 要满足什么样的需求我们先看一下一些常用的 SQL 语句 12345678# 根据某个确定值来查询对应的信息select id, name, email from user where id = 1;# 通过区间值查询select id, name, email from user where id &gt; 12 and id &lt; 20# 通过范围查询并进行排序select id, name, email from user where id &lt; 123 order by id desc limit 10; 从以上的几个常用的 SQL 我们可以看到在对数据库进行查找数据的过程中主要有以下三类需求： 根据某个值精确快速查找 根据区间的上下限来快速查找此区间的数据 查询符合条件的记录并根据某些字段进行排序 所以，需要找到一种符合上面所有需求的方案。目前比较常用于查询的数据结构有以下两种： 散列表 树 散列表散列表（哈希表）是根据是一种根据(key, value)直接进行访问的数据结构，它通过哈希函数将 key 值映射到散列表对应的位置上，查找效率非常高。 索引里其中的一种索引类型哈希索引就是基于散列表实现的，假设我们对名字建立哈希索引，则查找过程如下图所示： 对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（上图散列表的位置），散列表里的每个元素指向数据行的指针，由于索引自身只存储对应的哈希值，所以索引的结构十分紧凑，并且可以直接根据键值直接找到对应的数据记录，这让哈希索引查找速度非常快！但是哈希索引也有它的劣势，具体如下： 只有精确匹配索引所有列的查询才有效，比如我在列（name, address）建立哈希索引，如果只查询数据列 name, 则无法使用该索引。 哈希索引不是按照索引值顺序存储的，即 key 经过哈希函数计算后的哈希值不是按顺序的，所以也就无法用于排序，就不能根据区间进行查找。 哈希索引只支持等值比较查询，如 = 和 in()，不支持范围的查找，如 id &gt; 17。 所以，哈希索引只适用于特定场合，在适当的场景使用，的确能带来很大的性能提升。比如在 InnoDB 里，就有一种特殊的功能叫 “自适应哈希索引”，如果 InnoDB 注意到某些索引列值被频繁使用时，它会在内存基于 B+ 树索引之上再创建一个哈希索引，这样就能让 B+ 树也具有哈希索引的优点。 所以散列表结构无法满足上文提到的需求。 ​接着我们来看看树。 树平衡二叉树平衡二叉树可用于查找，且其查找的时间复杂度近似 O(log2n),但是可以用平衡二叉树作为索引的结构吗？ 答案是不能。 因为数据库表的数据通常是很多的，正常都是存放在磁盘上的。而磁盘的速度相比内存的速度是慢很多倍的，所以要尽量减少读取磁盘的次数，通过从内存读取数据来提高速度。 那么，如何将尽量多且有效的索引数据放到内存中呢？ 这里有两个问题要解决： 1、尽量多 读取磁盘数据的时候，都是按磁盘块来读取的（局部性原理与磁盘预读），并不是一条一条的读。在使用树这种结构作为索引的数据结构时，我们每查找一次数据就需要从磁盘中读取一个树节点，也就是对应的一个磁盘块，所以如果我们能把尽量多的数据放到磁盘块中，那么每次读取的数据就会较多。 而平衡二叉树是每个节点只存储一个键值和数据，也就是说，存储的时候，每个磁盘块只存储一个键值和数据。 那如果存储了海量的数据，可以想象平衡二叉树的节点将会非常多，树高也会极其高，在查找数据的时候就会进行很多次磁盘 IO，效率将会极低。 所以平衡二叉树无法解决存储尽量多的索引到内存中这个问题。 2、有效的索引数据 我们所说的平衡二叉树，指的是逻辑结构上的平衡二叉树，其物理实现是数组。所以在逻辑相近的节点上，其物理位置可能相差会很远。因此，每次读取的磁盘页数据，很多可能是用不上的，即有效的索引数据并不多，所以在查找过程中还是要进行许多次的磁盘读取操作。 所以平衡二叉树也无法解决这个问题。 所以，能解决这两个问题的数据结构 —— B 树就被发明出来了。 B 树B 树（Balance Tree），即平衡树的意思。B 树是从平衡二叉树演化而来，B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。B 树的结构示例如下图所示： 由于 B 树的每一个节点，即每一个磁盘块存储的数据较多，所以一定程度上解决了上文提到的存储尽量多的索引的问题。也一定程度上的解决了存储尽量多的有效索引的问题。 但是，B 树只是一定程度上的解决了问题，我们需要更好的解决问题。即能不能的做到存储更多的有效的索引呢？ 答案是可以。这时候就就需要 B+ 树闪亮登场了。 更好的解决了问题的 B+ 树B 树一定程度上的解决了问题，而从 B 树演化而来的 B+ 树能更好的解决问题，所以现实使用中几乎已经没有使用 B 树的情况了。 B + 树的结构示意图如下： 那么 B+ 树和 B 树有哪些不同? 在 B+ 树中，非叶子节点上是不存储数据的，仅存储键值。 因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16 KB，如果不存储数据，那么节点就可以存储更多的键值，相应的树的阶树就会更大，对于同样的数据量来说，需要的树高就会变低，树会更矮胖，如此一来查找数据的时候进行磁盘的 IO 次数就会减少，提升查询效率。 由于 B+ 树的阶数等于键值数量，假设 B+ 树的一个节点可以存储 1000 个键值，那么 3 层的 B+ 树 可以存储 1000 x 1000 x 1000 = 10亿个数据。并且一般根节点是常驻内存的，所以查找 10 亿个数据，只需要 2 次磁盘 IO。 B+ 这个特点很好的解决了上文提到的存储尽量多的索引数据的问题，并且查询效率也高。 B+ 树的叶子节点中的索引数据是按顺序排列的，并且叶子节点间是通过双向链表进行连接的。 这个特点使 B+ 树在实现范围查找，排序查找，分组查找等操作时变得异常简单。而 B 树由于数据分散在各个节点，要实现这些操作很不容易。 由于索引数据是按顺序排序的，即每次读取了数据页的时候，里面的索引数据大部分都是需要用的，所以也很好的解决了上文提到的如何存储尽量多的有效的索引数据的问题。 总结通过上面的分析，我们可以发现，在使用某种解决方案的时候，这种方案一定是用来满足某些需求的，在满足需求的过程中就会遇到一些问题，而最终的解决方案一定是能尽量好的解决问题并满足需求的。 所以，探究清楚某种方案是要满足什么样的需求，解决什么样的问题以及如何的解决了问题，也就明白了为什么使用这个方案。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"}]},{"title":"当我们在谈索引的时候，我们在谈什么","date":"2019-10-16T16:00:00.000Z","path":"2019/10/17/mysql-index-1/","text":"一句话总结：在 InnoDB 里，一个索引就是一棵 B+ 树。 那么这个 B+ 树是什么样子的呢？ 数据存储在叶子节点，中间节点存目录项。 那么， 叶子节点啥样的？ 中间节点啥样的？ 要知道节点的结构，就得先知道 InnoDB 管理存储空间的基本单位 —— 页。 InnoDB 引擎将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，页的大小一般为 16 KB。InnoDB 设计了许多种不同类型的页，比如存放表数据记录的页，存放表空间头部信息的页，存放 Insert Buffer 信息的页，存放 undo 日志的页等等，而这之中存放表中索引数据记录的页即数据页就是 B+ 数的叶子节点。 数据页数据页中由多个部分组成，不同部分有不同的作用，其结构如下图： 其中，各个部分的作用如下： File Header File Header 是各种类型的页都有的部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页分别是谁等信息。通过 File Header 存储的上一页下一页的信息，各个数据页可以组成一种双向链表的结构。 Page Header Page Header 用来存储本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等。 Infimum + Supremum InnoDB 定义的两条分别为最小记录与最大记录的伪记录 User Records User Records 插入数据库的记录存储的地方，一开始生成页的时候，并没有 User Records 这部分，每当插入一条记录后，都会从 Free Space 部分申请一个记录大小的空间划分到 User Records 部分，当插入的记录越来越多导致 Free Space 用完之后，也就意味着这个也使用完了，要再插入新记录，就需要申请新的页了。每条记录通过 next_record 属性记录着下一条记录的地址偏移量，即所有记录实际上是一个单向链表的结构。记录里的 record_type 属性值为 0。 Page Directory 为了便于查找， InnoDB 将 User Records 里的记录划分为多个组，每个组的最后一条记录的地址偏移量取出来放在 Page Directory 中，这个地址偏移量被称为槽（Slot），所以 Page Directory 就是由槽组成的。 所以在页中要查找一条记录的过程是：通过主键值用二分法确定要查找的记录位于哪个槽所对应的组中，在对应的组里遍历（每个组里包含的记录只能是 1 ~ 8 条）找到对应的记录。 File Trailer File Trailer 是用来校验页是否完整的，确保数据在内存和磁盘间同步不会有差错。 以上就是数据页的结构，所以，索引的叶子节点就是存有被设为索引的记录的数据页。 索引的结构上面说到数据页之间是通过 File Header 里记录的信息来找到上一页和下一页的信息，那么如何找到第一页呢？这里就得需要有目录项了，每个目录项包括两个部分：页的用户记录中最小的主键值和页号。因为存储的记录会很多导致目录项也很多，所以为了方便对目录项进行存放和管理，InnoDB 目录项的结构设计是跟数据页一样的，不同的是其中保存记录的部分存放的是目录的信息，即目录的主键和其页号，且记录里的record_type 属性值为 1。 目录指向叶子节点的的示意图如下： 当存储的记录越来越多导致目录项越来越多时，要查找一个目录项就变得越来越不容易，此时，就需要有指向目录项的目录了，于是一直演变下去就会出现多级目录，形成数据的索引，而这个多级目录就是一个树的结构，如下图所示： 在 InnoDB 里这种树叫 B+ 树，所谓的索引就是长这样。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"http://www.tenpercent.top/tags/索引/"}]},{"title":"一条MySQL更新语句的执行过程是什么样的","date":"2019-09-11T16:00:00.000Z","path":"2019/09/12/一条MySQL更新语句的执行过程是什么样的/","text":"一条MySQL更新语句的执行过程是什么样的1.连接验证及解析客户端与MySQL Server建立连接，发送语句给MySQL Server，接收到后如果是查询语句会先去查询缓存中看，有的话就直接返回了，（新版本的MySQL已经废除了查询缓存，命中率太低了），如果是缓存没有或者是非查询语句，会创建一个解析树，然后进行优化，（解析器知道语句是要执行什么，会评估使用各种索引的代价，然后去使用索引，以及调节表的连接顺序）然后调用innodb引擎的接口来执行语句。 2.写undo loginnodb 引擎首先开启事务，获得一个事务ID(是一直递增的)，根据执行的语句生成一个反向的语句，(如果是INSERT会生成一条DELETE语句，如果UPDATE语句就会生成一个UPDATE成旧数据的语句)，用于提交失败后回滚，将这条反向语句写入undo log，得到回滚指针，并且更新这个数据行的回滚指针和事务id。（事务提交后，Undo log并不能立马被删除，而是放入待清理的链表，由purge 线程判断是否有其他事务在使用undo 段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间，简单的说就是看之前的事务是否提交成功，这个事务及之前的事务都提交成功了，这部分undo log才能删除。） 3.从索引中查找数据根据索引去B+树中找到这一行数据（如果是普通索引，查到不符合条件的索引，会把所有数据查找出来，唯一性索引查到第一个数据就可以了） 4.更新数据判断数据页是否在内存中？ 4.1数据页在内存中索引是普通索引还是唯一性索引？ 4.1.1普通索引直接更新内存中的数据页 4.1.2唯一性索引判断更新后是否会数据冲突(不能破坏索引的唯一性)，不会的话就更新内存中的数据页。 4.2 数据页不在内存中索引是普通索引还是唯一性索引？ 4.2.1普通索引将对数据页的更新操作记录到change buffer，暂时不更新到磁盘。change buffer会在空闲时异步更新到磁盘。 4.2.2 唯一性索引因为需要保证更新后的唯一性，所以不能延迟更新，必须把数据页从磁盘加载到内存，然后判断更新后是否会数据冲突，不会的话就更新数据页。 5.写undo log（prepare状态）将对数据页的更改写入到redo log，将redo log设置为prepare状态。 6.写bin log（commit状态）通知MySQL server已经更新操作写入到redo log 了，随时可以提交，将执行的SQL写入到bin log日志，将redo log改成commit状态，事务提交成功。 undo log主要是保证事务的原子性，事务执行失败就回滚，用于在事务执行失败后，对数据回滚。 是逻辑日志，记录的是SQL语句。 在事务提交后，undo log日志不会立即删除，会放到一个待删除的链表中，有purge线程判断是否有其他事务在使用上一个事务之前的版本信息，然后决定是否可以清理，简单的来说就是前面的事务都提交成功了，这些undo才能删除。 change buffer是什么？（change buffer就是将更新数据页的操作缓存下来） 在更新数据时，如果数据行所在的数据页在内存中，直接更新内存中的数据页。 如果不在内存中，为了减少磁盘IO的次数，innodb会将这些更新操作缓存在change buffer中，在下一次查询时需要访问这个数据页时，在执行change buffer中的操作对数据页进行更新。（或者是在MySQL Server空闲时，会将change buffer中所有操作更新到磁盘，也就是俗称的‘刷页’。） 适合写多读少的场景，因为这样即便立即写了，也不太可能会被访问到，延迟更新可以减少磁盘I/O，只有普通索引会用到，因为唯一性索引，在更新时就需要判断唯一性，所以没有必要。 redo log就是为了保证事务的持久性，在做数据更新操作时，先将对数据页的更改记录到redo log，然后再去更新内存中的数据页，在下次查询数据页或者空闲时间，将操作记录更新到磁盘。这样可以将随机I/O改为顺序I/O。 优点是减少磁盘I/O次数，即便发生故障也可以根据redo log来将数据恢复到最新状态。 缺点是会造成内存脏页，后台线程会自动对脏页刷盘，或者是淘汰数据页时刷盘，此时会暂时查询操作，影响查询。 二段提交制更新时，先改内存中的数据页，将更新操作写入redo log日志，此时redo log进入prepare状态，然后通知MySQL Server执行完了，随时可以提交，MySQL Server将更新的SQL写入bin log，然后调用innodb接口将redo log设置为提交状态，更新完成。 如果只是写了bin log就提交，那么忽然发生故障，主节点可以根据redo log恢复数据到最新，但是主从同步时会丢掉这部分更新的数据。 如果只是写binlog，然后写redo log，如果忽然发生故障，主节点根据redo log恢复数据时就会丢掉这部分数据。 崩溃恢复时的判断规则（以redolog是否commit或者binlog是否完整来确定） 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交； 如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：a. 如果是，则提交事务；b. 否则，回滚事务。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"}]},{"title":"深入 Nginx 之架构篇","date":"2019-03-25T16:00:00.000Z","path":"2019/03/26/depth-nginx/","text":"前言最近在读 Nginx 相关的书籍，做一下读书笔记。 Nginx 作为业界知名的高性能服务器，被广泛的应用。它的高性能正是由于其优秀的架构设计，其架构主要包括这几点：模块化设计、事件驱动架构、请求的多阶段异步处理、管理进程与多工作进程设计、内存池的设计，以下内容依次进行说明。 模块化设计高度模块化的设计是 Nginx 的架构基础。在 Nginx 中，除了少量的核心代码，其他一切皆为模块。 所有模块间是分层次、分类别的，Nginx 官方共有五大类型的模块：核心模块、配置模块、事件模块、HTTP 模块、mail 模块。它们之间的关系如下： 在这 5 种模块中，配置模块和核心模块是与 Nginx 框架密切相关的。而事件模块则是 HTTP 模块和 mail 模块的基础。HTTP 模块和 mail 模块的“地位”类似，它们都是更关注于应用层面。 事件驱动架构事件驱动架构，简单的说就是由一些事件发生源来产生事件，由事件收集器来收集、分发事件，然后由事件处理器来处理这些事件（事件处理器需要先在事件收集器里注册自己想处理的事件）。 对于 Nginx 服务器而言，一般由网卡、磁盘产生事件，Nginx 中的事件模块将负责事件的收集、分发操作；而所有的模块都可能是事件消费者，它们首先需要向事件模块注册感兴趣的事件类型，这样，在有事件产生时，事件模块会把事件分发到相应的模块中进行处理。 对于传统 web 服务器（如 Apache）而言，采用的所谓事件驱动往往局限在 TCP 连接建立、关闭事件上，一个连接建立以后，在其关闭之前的所有操作都不再是事件驱动，这时会退化成按顺序执行每个操作的批处理模式，这样每个请求在连接建立后都将始终占用着系统资源，直到关闭才会释放资源。这种请求占用着服务器资源等待处理的模式会造成服务器资源极大的浪费。如下图所示，传统 web 服务器往往把一个进程或线程作为时间消费者，当一个请求产生的事件被该进程处理时，直到这个请求处理结束时，进程资源都将被这一请求所占用。比较典型的例子如 Apache 同步阻塞的多进程模式就是这样的。 传统 web 服务器处理事件的简单模型（矩形代表进程）: Nginx 采用事件驱动架构处理业务的方式与传统的 web 服务器是不同的。它不使用进程或者线程来作为事件消费者，所谓的事件消费者只能是某个模块。只有事件收集、分发器才有资格占用进程资源，它们会在分发某个事件时调用事件消费模块使用当前占用的进程资源，如下图所示，该图中列出了 5 个不同的事件，在事件收集、分发者进程的一次处理过程中，这 5 个事件按照顺序被收集后，将开始使用当前进程分发事件，从而调用相应的事件消费者来处理事件。当然，这种分发、调用也是有序的。 Nginx 处理事件的简单模型： 由上图可以看出，处理请求事件时，Nginx 的事件消费者只是被事件分发者进程短期调用而已，这种设计使得网络性能、用户感知的请求时延都得到了提升，每个用户的请求所产生的事件会及时响应，整个服务器的网络吞吐量都会由于事件的及时响应而增大。当然，这也带来一定的要求，即每个事件消费者都不能有阻塞行为，否则将会由于长时间占用事件分发者进程而导致其他事件得不到及时响应，Nginx 的非阻塞特性就是由于它的模块都是满足这个要求的。 请求的多阶段异步处理多阶段异步处理请求与事件驱动架构是密切相关的，也就是说，请求的多阶段异步处理只能基于事件驱动架构实现。多阶段异步处理就是把一个请求的处理过程按照事件的触发方式划分为多个阶段，每个阶段都可以由事件收集、分发器来触发。 处理获取静态文件的 HTTP 请求时切分的阶段及各阶段的触发事件如下所示： 这个例子中，该请求大致分为 7 个阶段，这些阶段是可以重复发生的，因此，一个下载静态资源请求可能会由于请求数据过大，网速不稳定等因素而被分解为成百上千个上图所列出的阶段。 异步处理和多阶段是相辅相成的，只有把请求分为多个阶段，才有所谓的异步处理。当一个时间被分发到事件消费者中进行处理时，事件消费者处理完这个事件只相当于处理完 1 个请求的阶段。什么时候可以处理下一个阶段呢？这只能等待内核的通知，即当下一次事件出现时，epoll 等事件分发器将会获取到通知，然后去调用事件消费者进行处理。 管理进程、多工作进程设计Nginx 在启动后，会有一个 master 进程和多个 worker 进程。master 进程主要用来管理worker 进程，包括接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态以及启动 worker 进程。 worker 进程是用来处理来自客户端的请求事件。多个 worker 进程之间是对等的，它们同等竞争来自客户端的请求，各进程互相独立，一个请求只能在一个 worker 进程中处理。worker 进程的个数是可以设置的，一般会设置与机器 CPU 核数一致，这里面的原因与事件处理模型有关。Nginx 的进程模型，可由下图来表示： 在服务器上查看 Nginx 进程： 这种设计带来以下优点： 1） 利用多核系统的并发处理能力 现代操作系统已经支持多核 CPU 架构，这使得多个进程可以分别占用不同的 CPU 核心来工作。Nginx 中所有的 worker 工作进程都是完全平等的。这提高了网络性能、降低了请求的时延。 2） 负载均衡 多个 worker 工作进程通过进程间通信来实现负载均衡，即一个请求到来时更容易被分配到负载较轻的 worker 工作进程中处理。这也在一定程度上提高了网络性能、降低了请求的时延。 3） 管理进程会负责监控工作进程的状态，并负责管理其行为 管理进程不会占用多少系统资源，它只是用来启动、停止、监控或使用其他行为来控制工作进程。首先，这提高了系统的可靠性，当 worker 进程出现问题时，管理进程可以启动新的工作进程来避免系统性能的下降。其次，管理进程支持 Nginx 服务运行中的程序升级、配置项修改等操作，这种设计使得动态可扩展性、动态定制性较容易实现。 内存池的设计为了避免出现内存碎片，减少向操作系统申请内存的次数、降低各个模块的开发复杂度，Nginx 设计了简单的内存池，它的作用主要是把多次向系统申请内存的操作整合成一次，这大大减少了 CPU 资源的消耗，同时减少了内存碎片。 因此，通常每一个请求都有一个简易的独立内存池（如每个 TCP 连接都分配了一个内存池），而在请求结束时则会销毁整个内存池，把曾经分配的内存一次性归还给操作系统。这种设计大大提高了模块开发的简单些，因为在模块申请内存后不用关心它的释放问题；而且因为分配内存次数的减少使得请求执行的时延得到了降低。同时，通过减少内存碎片，提高了内存的有效利用率和系统可处理的并发连接数，从而增强了网络性能。","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.tenpercent.top/tags/Nginx/"},{"name":"架构","slug":"架构","permalink":"http://www.tenpercent.top/tags/架构/"}]},{"title":"深入 Nginx 之配置篇","date":"2019-03-14T16:00:00.000Z","path":"2019/03/15/learn-nginx-configuration/","text":"常用配置项在工作中，我们与 Nginx 打交道更多的是通过其配置文件来进行。那么掌握这些配置项各自的作用就很有必要了。 首先，nginx.conf 的内容通常是这样的： 12345678910111213141516171819202122232425262728293031323334... ... #核心摸块events &#123; #事件模块 ...&#125;http &#123; # http 模块 server &#123; # server块 location [PATTERN] &#123; # location块 ... &#125; location [PATTERN] &#123; ... &#125; &#125; server &#123; ... &#125; &#125;mail &#123; # mail 模块 server &#123; # server块 ... &#125;&#125; 我们依次看一下每个模块一般有哪些配置项： 核心模块1234567user admin; #配置用户或者组。worker_processes 4; #允许生成的进程数，默认为1 pid /nginx/pid/nginx.pid; #指定 nginx 进程运行文件存放地址 error_log log/error.log debug; #错误日志路径，级别。 事件模块123456789events &#123; accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off use epoll; #事件驱动模型select|poll|kqueue|epoll|resig worker_connections 1024; #最大连接数，默认为512&#125; http 模块1234567891011121314151617181920212223242526272829303132333435363738http &#123; include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型，默认为text/plain access_log off; #取消服务日志 sendfile on; #允许 sendfile 方式传输文件，默认为off，可以在http块，server块，location块。 sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 keepalive_timeout 65; #连接超时时间，默认为75s，可以在http，server，location块。 server &#123; keepalive_requests 120; #单连接请求上限次数。 listen 80; #监听端口 server_name 127.0.0.1; #监听地址 index index.html index.htm index.php; root your_path; #根目录 location ~ \\.php$ &#123; fastcgi_pass unix:/var/run/php/php7.1-fpm.sock; #fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; &#125; &#125;&#125; 配置项解析 worker_processes worker_processes 用来设置 Nginx 服务的进程数。该值推荐使用 CPU 内核数。 worker_cpu_affinity worker_cpu_affinity 用来为每个进程分配CPU的工作内核，参数有多个二进制值表示，每一组代表一个进程，每组中的每一位代表该进程使用CPU的情况，1代表使用，0代表不使用。所以我们使用 worker_cpu_affinity 0001 0010 0100 1000;来让进程分别绑定不同的核上。默认情况下worker进程不绑定在任何一个CPU上。 worker_rlimit_nofile 设置毎个进程的最大文件打开数。如果不设的话上限就是系统的 ulimit –n的数字，一般为65535。 worker_connections 设置一个进程理论允许的最大连接数，理论上越大越好，但不可以超过 worker_rlimit_nofile 的值。 use epoll 设置事件驱动模型使用 epoll。epoll 是 Nginx 支持的高性能事件驱动库之一。是公认的非 常优秀的事件驱动模型。 accept_mutex off 关闭网络连接序列化，当其设置为开启的时候，将会对多个 Nginx 进程接受连接进行序列化，防止多个进程对连接的争抢。当服务器连接数不多时，开启这个参数会让负载有一定程度的降低。但是当服务器的吞吐量很大时，为了效率，请关闭这个参数；并且关闭这个参数的时候也可以让请求在多个 worker 间的分配更均衡。所以我们设置 accept_mutex off; multi_accept on 设置一个进程可同时接受多个网络连接 Sendfile on Sendfile是 Linux2.0 以后的推出的一个系统调用,它能简化网络传输过程中的步骤，提高服务器性能。不用 sendfile的传统网络传输过程：硬盘 &gt;&gt; kernel buffer &gt;&gt; user buffer &gt;&gt; kernel socket buffer &gt;&gt; 协议栈 用 sendfile()来进行网络传输的过程：硬盘 &gt;&gt; kernel buffer (快速拷贝到 kernelsocket buffer) &gt;&gt; 协议栈 tcp_nopush on 设置数据包会累积一下再一起传输，可以提高一些传输效率。 tcp_nopush 必须和 sendfile 搭配使用。 tcp_nodelay on 小的数据包不等待直接传输。默认为on。看上去是和 tcp_nopush 相反的功能，但是两边都为 on 时 nginx 也可以平衡这两个功能的使用。 keepalive_timeout HTTP 连接的持续时间。设的太长会使无用的线程变的太多。这个根据服务器访问数量、处理速度以及网络状况方面考虑。 send_timeout 设置 Nginx 服务器响应客户端的超时时间，这个超时时间只针对两个客户端和服务器建立连接后，某次活动之间的时间，如果这个时间后，客户端没有任何活动，Nginx服务器将关闭连接 gzip on 启用 gzip，对响应数据进行在线实时压缩,减少数据传输量。 gzip_disable “msie6” Nginx服务器在响应这些种类的客户端请求时，不使用 Gzip 功能缓存应用数据，gzip_disable “msie6”对IE6浏览器的数据不进行 GZIP 压缩。 常用的配置项大致这些，对于不同的业务场景，有的需要额外的其他配置项，这里不做展开。 其他http 配置里有 location 这一项，它是用来根据请求中的 uri 来为其匹配相应的处理规则。 location 查找规则1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950location = / &#123; # 精确匹配 / ，主机名后面不能带任何字符串 [ config A ]&#125;location / &#123; # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求 # 但是正则和最长字符串会优先匹配 [ config B ]&#125;location /documents/ &#123; # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ config C ]&#125;location ~ /documents/Abc &#123; # 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ config CC ]&#125;location ^~ /images/ &#123; # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。 [ config D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; # 匹配所有以 gif,jpg或jpeg 结尾的请求 # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则 [ config E ]&#125;location /images/ &#123; # 字符匹配到 /images/，继续往下，会发现 ^~ 存在 [ config F ]&#125;location /images/abc &#123; # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在 # F与G的放置顺序是没有关系的 [ config G ]&#125;location ~ /images/abc/ &#123; # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用 [ config H ]&#125; 正则查找优先级从高到低依次如下： “ = ” 开头表示精确匹配，如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。 “ ^~ ” 开头表示uri以某个常规字符串开头，不是正则匹配 “ ~ ” 开头表示区分大小写的正则匹配; “ ~* ”开头表示不区分大小写的正则匹配 “ / ” 通用匹配, 如果没有其它匹配,任何请求都会匹配到 负载均衡配置Nginx 的负载均衡需要用到 upstream 模块，可通过以下配置来实现： 1234567891011121314upstream test-upstream &#123; ip_hash; # 使用 ip_hash 算法分配 server 192.168.1.1; # 要分配的 ip server 192.168.1.2;&#125;server &#123; location / &#123; proxy_pass http://test-upstream; &#125; &#125; 上面的例子定义了一个 test-upstream 的负载均衡配置，通过 proxy_pass 反向代理指令将请求转发给该模块进行分配处理。","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.tenpercent.top/tags/Nginx/"},{"name":"配置","slug":"配置","permalink":"http://www.tenpercent.top/tags/配置/"}]},{"title":"Java 如何解决可见性和有序性","date":"2019-02-26T16:00:00.000Z","path":"2019/02/27/Java如何解决可见性和有序性/","text":"我们都知道导致可见性的原因是缓存，导致有序性的原因是编译优化。那解决可见性和有序性的办法就是禁用缓存和禁用编译优化了，不过我们都知道缓存和编译优化的目的是为了提高 CPU 的效率从而提高程序的性能，所以不能完全禁止，折中的方案就是按需禁用缓存和编译优化。 那么，如何进行按需禁用呢？ 对于这个问题，Java 提供了 Java 内存模型（JMM）这个方案来解决。 Java 内存模型的抽象结构在 Java 中，所有实例域，静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。方法定义参数和异常处理器参数以及方法内定义的变量这些局部变量则存在调用栈里。由于每个线程与自己的调用栈是一一对应的，所以局部变量不会在线程之间共享，它们不会有内存可见性问题。 Java 线程间的通信由 Java 内存模型（JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系，其示意图如下： 即线程间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程所读写的共享变量的副本。 本地内存是 JMM 的一个抽象概念，并不是真实的存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。 从上图看，如果线程 A 与线程B之间要通信的话，必须要经历下面2个步骤。 1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。 2）线程B到主内存中去读取线程A之前已更新过的共享变量。 示例过程如下所示： 从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要 经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 Java 程序员提供内存可见性保证。 volatile、synchronized 关键字的语义以及 Happens-Before 规则有了 JMM 后，如何让程序员在编程中根据 Java 给出的“约定”来实现遵循 JMM 机制的程序呢？就是通过 volatile、synchronized 和 final 这三个关键字原语来实现，以及与之配套的 Happens-Before 规则。 volatile 的内存语义当一个变量被设为 volatile 后，线程对该变量的写会及时的刷新到主内存中，而当另一个线程读取该变量的时候，JMM 会把该线程对应的本地内存置为无效而从主内存中读取最新的变量正确值。从而实现线程间的通信。（注：线程写 volatile 变量后刷新到内存的操作是对线程自身整个本地内存的刷新，不仅仅是只对 volatile 变量进行刷新，所以如果该线程在写 volatile 变量前也对其他变量做了修改，则其他变量也会一并被刷新到主内存中，这个体现在 Happens-Before 规则里） synchronized 的内存语义synchronized 即锁，锁是 Java 并发中最重要的同步机制。其内存语义其实与 volatile 是有点类似的，当线程释放锁的时候，JMM 会把该线程对应的本地内存中的所有共享变量刷新到主内存中（与线程写 volatile 变量类似）。当线程获取锁时，JMM 会把该线程对应的本地内存置为无效，并从主内存中获取所需共享变量的值（与读 volatile 变量类似），从而实现线程间通信。 Happens-Before 规则 程序顺序规则 一个线程中的每个操作，happens-before 于该线程中的任意后续操作。这是是遵循顺序一致性规则，比较好理解。 监视器锁规则 对一个锁的解锁，happens-before 于随后对这个锁的加锁。由上面 synchronized 的内存语义可知，当对一个锁解锁的时候，该线程会将本地内存里的共享变量刷新到主内存里，随后加锁时，线程会从主内存读取最新的数据，所以解锁后的共享变量是对后面进行加锁的线程是可见的。 volatile变量规则 对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。这个根据上面 volatile 的内存语义也是很好理解。 传递性： 如果A happens-before B，且B happens-before C，那么A happens-before C。 start()规则 如果线程 A 执行操作 ThreadB.start()（启动线程B），那么A线程的 ThreadB.start() 操作 happens-before 于线程B中的任意操作。这条规则怎么理解呢？我们可以参考上面 volatile 和 synchronized 内存语义的本质，就是及时的将本地内存的共享变量刷新到主内存里，而其他线程从主内存进行读数据。 所以本条规则的本质我的理解是当线程调用 ThreadB.start()去启动别的线程时，线程会先将本地内存的共享变量刷新到主内存里，被 start 的线程则会将自己本地内存置为无效，从主内存里获取最新共享变量。 join()规则 如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的所有操作完成后，线程 A 都能看到。 与上一条类似，这条规则可以这么理解：当主线程调用了子线程的 join 后，子线程在执行完成后，会将自己本地内存刷新到主内存里，而主线程则会将自己本地内存置为无效，从主内存里获取最新的共享变量。从而实现了子线程的所有操作对主线程可见。 总结对于如何解决可见性和有序性的问题上，Java 使用内存模型（JMM）这个解决方案，通过内存模型来进行按需的禁用缓存和编译优化，JMM 屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为程序员呈现了一个一致的内存模型。同时，Java 也提供了相应的原语和 Happens-Before 规则来让程序员可以按照它的规定进行编写满足要求的程序。","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.tenpercent.top/tags/JAVA/"},{"name":"并发","slug":"并发","permalink":"http://www.tenpercent.top/tags/并发/"}]},{"title":"为什么并发编程会产生 bug","date":"2019-02-19T16:00:00.000Z","path":"2019/02/20/为什么并发编程会产生 bug/","text":"本文结构 为什么需要并发编程我们都知道计算机的核心组成 CPU，内存，I/O 设备的运行速度差异是很大的，它们间的速度是 CPU &gt;&gt; 内存 &gt;&gt; I/O，CPU 和内存的速度差异就如同天上一天和地上一年的差别。而内存和 I/O 设备的速度差异就更大了，相当于天上一天与地上十年的区别。 而程序里大部分语句都要访问内存和 I/O，所以一段程序执行的性能是取决于最慢的那部分的执行速度——即读写 I/O 设备。 所以，如何合理的平衡这三者的速度差异来使程序运行的最快呢？ 这就需要从计算机体系结构，操作系统，编译程序这些方面进行优化了。目前计算机科学界的大佬们对在这些方面做出的优化主要有以下几点： 1、 CPU 增加了缓存，用来缓存常用的内存数据或地址，以均衡与内存的速度差异； 2、操作系统增加了进程、线程，用来对 CPU 进行分时复用，进而均衡 CPU 与 I/O 设备的速度差异； 3、编译程序优化指定执行次序，使得缓存能够得到更加合理的利用。 这几点的优化在一定程度上大大提升了程序的运行速度，但是相应的也产生了并发程序的一些问题，也就是并发编程可能会出现的 bug。 为什么会产生 bug首先，我们需要定义一下这个 bug 是什么样的 bug。 并发编程，所引起的问题，其本质 bug 就是对某个资源的操作没有 原因一：CPU 缓存带来可见性问题在单核的 CPU 中，所有的线程都是在一颗 CPU 上执行，因为所有线程都是操作同一块缓存和内存，所以不同线程对缓存的写，是互相透明的。 但是在多核时代，每个 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就不容易保证了。当多个线程在不同的 CPU 上执行时，这些线程操作的是不同 CPU 的缓存，如下图： 线程 A 操作的是 CPU-1 上缓存，而线程 B 操作的是 CPU-2 上的缓存，这个时候，线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。举个例子，假设变量 V 初始值为 0，线程 A 从内存读取变量 V 到 CPU 中并缓存起来，随后线程 A 对变量 V + 1 并更新缓存，而此时，线程 B 也从 内存读取变量 V，然后也开始执行 +1 操作并进行更新缓存；这样当线程 A 把变量 V 的值从缓存写入到内存里后，变量 V 的值为 1，而当线程 B 也将变量 V 写入到缓存时，变量 V 的值也是 1，最终就是变量 V 虽然被两个线程分别执行了两次 +1 操作，但是其最终的值却是 1，而不是我们期望的正确值 2。这就是可见性引起的问题。 原因二：线程切换带来的原子性问题我们都知道 Unix 采用分时复用的方式，即通过对线程进行调度切换来提高 CPU 的利用率 由于我们现在编程基本都是使用高级语言，高级语言里的一条语句往往需要多条 CPU 指令完成。例如 count += 1, 至少需要三条 CPU 指令。 指令 1： 将变量 count 从内存加载到 CPU 的寄存器； 指令 2： 在寄存器中执行 +1 操作 指令 3： 将结果写入缓存 而操作系统在线程切换时，可以发送在任何一条 CPU 指令 执行完，而高级语言里的一条语句。对于上面的三条指令来说，假设 count 为 0, 如果线程 A 在指令 1 执行完后做线程切换，线程 B 开始执行三条指令后，即将 count 的值 +1 并写入了缓存了，这时再切换回线程 A，由于线程 A 在前面已经执行了指令 1，线程 A 里的 count 值是 0，此时再去执行指令 2 和指令 3，最后线程 A 执行完后，count 的值依然为 1。即 count 变量分别被两个线程获取并进行了 +1 的操作，但是最终的结果是 1 而不是我们所期望的正确值 2。这就是线程切换引起的问题。 上述过程示意图如下： 原因三：编译优化带来的有序性问题编译优化是指当我们的程序进行编译后，编译器为了优化性能，有时候会改变程序中语句的先后顺序。例如 “a = 1; b = 2;” 编译器优化后可能变成“b = 2, a = 1”。 在 Java 领域一个经典的案例就是利用双重检查创建单例对象。在实现单例的时候，首先判断 instance 是不是为空，如果为空进入同步代码块初始化 instance，否而直接返回 instance。初始化 instance 时再次判断 instance 是否为空，避免了在进入同步代码块这段时间有线程抢先一步完成了 instance 初始化。代码如下： 1234567891011121314151617public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 这种单例的实现方式，看似在提高效率的同时，做到了天衣无缝。其实不然，因为 instance = new Singleton (); 这一行代码会被编译为三条指令，正常指令顺序如下： 1、为 instance 分配一块内存 A 2、在分配的内存 A 上初始化 instance 实例 3、把内存 A 的地址赋值给 instance 变量 而编译器优化后可能会变成： 1、为 instance 分配一块内存 A 2、把内存 A 的地址赋值给 instance 变量 3、在分配的内存 A 上初始化 instance 实例 上面的顺序调换在单线程环境下是没有问题的，但是在多线程的情况下，假如线程 A 正在初始化 instance，此时执行完第 2 步，正在执行第三步。而线程 B 执行到 if (instance == null) 的判断，那么线程 B 就会直接得到未初始化好的 instance，而此时线程 B 使用此 instance 显然是有问题的。 要解决本例的有序性问题很简单，我们只需要为 instance 声明时增加 volatile 关键字，volatile 修饰的变量是会保证读操作一定能读到写完的值。 总结要写好并发程序，首先要知道并发程序的问题在哪，是因为什么引起的。并发程序问题的产生主要是由可见性，原子性，有序性这三方面引起。 此外，上面所提到的缓存，线程，编译优化的目的与我们写并发程序的目的是相同的，都是提高程序性能。但是，从这里我们可以看到，技术在解决一个问题的时候，很难有完美的解决方案，往往是解决了问题的同时也会带来另外的问题。所以在采用一项新技术的同时，一定要清楚它能解决什么问题，可能带来什么问题，以及如何进行规避。","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.tenpercent.top/tags/JAVA/"},{"name":"并发","slug":"并发","permalink":"http://www.tenpercent.top/tags/并发/"}]},{"title":"乐观锁与悲观锁","date":"2019-01-22T16:00:00.000Z","path":"2019/01/23/乐观锁与悲观锁/","text":"乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。 乐观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。 悲观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。 两种锁的使用场景从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。 乐观锁常见的两种实现方式 乐观锁一般会使用版本号机制或CAS算法实现。 1. 版本号机制一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。 举一个简单的例子：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。 在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。 操作员 A 完成了修改工作，将数据版本号（ version=1 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。 操作员 B 完成了操作，也将版本号（ version=1 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。 这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。 2. CAS算法即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数 需要读写的内存值 V 进行比较的值 A 拟写入的新值 B 当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。 关于自旋锁，大家可以看一下这篇文章，非常不错：《面试必备之深入理解自旋锁》 乐观锁的缺点 ABA 问题是乐观锁一个常见的问题 1 ABA 问题如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。 JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 2 循环时间长开销大自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 3 只能保证一个共享变量的原子操作CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。 CAS与 synchronized 的使用情景 简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多） 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.tenpercent.top/tags/JAVA/"}]},{"title":"JAVA 的反射机制","date":"2018-11-22T16:00:00.000Z","path":"2018/11/23/反射机制/","text":"反射机制介绍JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。 获取 Class 对象的四种方式如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象: 1.知道具体类的情况下可以使用： 1Class alunbarClass = TargetObject.class; 但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取Class对象不会进行初始化 2.通过 Class.forName()传入类的路径获取： 1Class alunbarClass1 = Class.forName(\"cn.javaguide.TargetObject\"); Class.forName(className)方法，内部实际调用的是一个native方法 forName0(className, true, ClassLoader.getClassLoader(caller), caller); 第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。 一旦初始化，就会触发目标对象的 static块代码执行，static参数也会被再次初始化。 3.通过对象实例instance.getClass()获取：12Employee e = new Employee();Class alunbarClass2 = e.getClass(); 4.通过类加载器xxxClassLoader.loadClass()传入类路径获取1class clazz = ClassLoader.LoadClass(\"cn.javaguide.TargetObject\"); 通过类加载器获取Class对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行 代码实例简单用代码演示一下反射的一些操作! 1.创建一个我们要使用反射操作的类 TargetObject： 1234567891011121314151617package cn.javaguide;public class TargetObject &#123; private String value; public TargetObject() &#123; value = \"JavaGuide\"; &#125; public void publicMethod(String s) &#123; System.out.println(\"I love \" + s); &#125; private void privateMethod() &#123; System.out.println(\"value is \" + value); &#125;&#125; 2.使用反射操作这个类的方法以及参数 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.javaguide;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException &#123; /** * 获取TargetObject类的Class对象并且创建TargetObject类实例 */ Class&lt;?&gt; tagetClass = Class.forName(\"cn.javaguide.TargetObject\"); TargetObject targetObject = (TargetObject) tagetClass.newInstance(); /** * 获取所有类中所有定义的方法 */ Method[] methods = tagetClass.getDeclaredMethods(); for (Method method : methods) &#123; System.out.println(method.getName()); &#125; /** * 获取指定方法并调用 */ Method publicMethod = tagetClass.getDeclaredMethod(\"publicMethod\", String.class); publicMethod.invoke(targetObject, \"JavaGuide\"); /** * 获取指定参数并对参数进行修改 */ Field field = tagetClass.getDeclaredField(\"value\"); //为了对类中的参数进行修改我们取消安全检查 field.setAccessible(true); field.set(targetObject, \"JavaGuide\"); /** * 调用 private 方法 */ Method privateMethod = tagetClass.getDeclaredMethod(\"privateMethod\"); //为了调用private方法我们取消安全检查 privateMethod.setAccessible(true); privateMethod.invoke(targetObject); &#125;&#125; 输出内容： 1234publicMethodprivateMethodI love JavaGuidevalue is JavaGuide 注意 : 有读者提到上面代码运行会抛出 ClassNotFoundException 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 TargetObject 所在的包 。 1Class&lt;?&gt; tagetClass = Class.forName(\"cn.javaguide.TargetObject\"); 静态编译和动态编译 静态编译： 在编译时确定类型，绑定对象 动态编译： 运行时确定类型，绑定对象 反射机制优缺点 优点： 运行期类型的判断，动态加载类，提高代码灵活度。 缺点： 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。 反射的应用场景反射是框架设计的灵魂。 在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。 举例： 我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序； Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系； 动态配置实例的属性； ……","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.tenpercent.top/tags/JAVA/"}]},{"title":"谈谈 JDK 代理和 CGLIB 代理","date":"2018-09-22T16:00:00.000Z","path":"2018/09/23/JDK 代理和 CGLIB 代理/","text":"1. 代理模式在讲JDK 代理和 CGLIB 代理前需要先了解代理模式。代理模式是一种比较简单的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。 代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。 代理分为静态代理和动态代理两种。 2. 静态代理静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。 上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。 静态代理实现步骤: 定义一个接口及其实现类； 创建一个代理类同样实现这个接口 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。 下面通过代码展示！ 1.定义发送短信的接口 123public interface SmsService &#123; String send(String message);&#125; 2.实现发送短信的接口 123456public class SmsServiceImpl implements SmsService &#123; public String send(String message) &#123; System.out.println(\"send message:\" + message); return message; &#125;&#125; 3.创建代理类并同样实现发送短信的接口 123456789101112131415161718public class SmsProxy implements SmsService &#123; private final SmsService smsService; public SmsProxy(SmsService smsService) &#123; this.smsService = smsService; &#125; @Override public String send(String message) &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(\"before method send()\"); smsService.send(message); //调用方法之后，我们同样可以添加自己的操作 System.out.println(\"after method send()\"); return null; &#125;&#125; 4.实际使用 1234567public class Main &#123; public static void main(String[] args) &#123; SmsService smsService = new SmsServiceImpl(); SmsProxy smsProxy = new SmsProxy(smsService); smsProxy.send(\"java\"); &#125;&#125; 运行上述代码之后，控制台打印出： 123before method send()send message:javaafter method send() 可以输出结果看出，我们已经增加了 SmsServiceImpl 的send()方法。 3. 动态代理相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)。 从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。 说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。 动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。 就 Java 来说，动态代理的实现方式比较常见的就是 JDK 动态代理、CGLIB 动态代理。 3.1. JDK 动态代理机制3.1.1. 介绍在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。 Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。 1234567public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; ......&#125; 这个方法一共有 3 个参数： loader :类加载器，用于加载代理对象。 interfaces : 被代理类实现的一些接口； h : 实现了 InvocationHandler 接口的对象； 要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。 12345678public interface InvocationHandler &#123; /** * 当你使用代理对象调用方法的时候实际会调用到这个方法 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; invoke() 方法有下面三个参数： proxy :动态生成的代理类 method : 与代理类对象调用的方法相对应 args : 当前 method 方法的参数 也就是说：你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。 3.1.2. JDK 动态代理类使用步骤 定义一个接口及其实现类； 自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象； 3.1.3. 代码示例这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！ 1.定义发送短信的接口 123public interface SmsService &#123; String send(String message);&#125; 2.实现发送短信的接口 123456public class SmsServiceImpl implements SmsService &#123; public String send(String message) &#123; System.out.println(\"send message:\" + message); return message; &#125;&#125; 3.定义一个 JDK 动态代理类 12345678910111213141516171819202122232425262728import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @author shuang.kou * @createTime 2020年05月11日 11:23:00 */public class DebugInvocationHandler implements InvocationHandler &#123; /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(\"before method \" + method.getName()); Object result = method.invoke(target, args); //调用方法之后，我们同样可以添加自己的操作 System.out.println(\"after method \" + method.getName()); return result; &#125;&#125; invoke() 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 invoke() 方法，然后 invoke() 方法代替我们去调用了被代理对象的原生方法。 4.获取代理对象的工厂类 123456789public class JdkProxyFactory &#123; public static Object getProxy(Object target) &#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), // 目标类的类加载 target.getClass().getInterfaces(), // 代理需要实现的接口，可指定多个 new DebugInvocationHandler(target) // 代理对象对应的自定义 InvocationHandler ); &#125;&#125; getProxy() ：主要通过Proxy.newProxyInstance（）方法获取某个类的代理对象 5.实际使用 12SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());smsService.send(\"java\"); 运行上述代码之后，控制台打印出： 123before method sendsend message:javaafter method send 3.2. CGLIB 动态代理机制3.2.1. 介绍JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。 为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。 CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。 在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。 你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。 123456public interface MethodInterceptorextends Callback&#123; // 拦截被代理类中的方法 public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable;&#125; obj :被代理的对象（需要增强的对象） method :被拦截的方法（需要增强的方法） args :方法入参 methodProxy :用于调用原始方法 你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。 3.2.2. CGLIB 动态代理类使用步骤 定义一个类； 自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似； 通过 Enhancer 类的 create()创建代理类； 3.2.3. 代码示例不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 1.实现一个使用阿里云发送短信的类 12345678package github.javaguide.dynamicProxy.cglibDynamicProxy;public class AliSmsService &#123; public String send(String message) &#123; System.out.println(\"send message:\" + message); return message; &#125;&#125; 2.自定义 MethodInterceptor（方法拦截器） 12345678910111213141516171819202122232425262728import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * 自定义MethodInterceptor */public class DebugMethodInterceptor implements MethodInterceptor &#123; /** * @param o 被代理的对象（需要增强的对象） * @param method 被拦截的方法（需要增强的方法） * @param args 方法入参 * @param methodProxy 用于调用原始方法 */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(\"before method \" + method.getName()); Object object = methodProxy.invokeSuper(o, args); //调用方法之后，我们同样可以添加自己的操作 System.out.println(\"after method \" + method.getName()); return object; &#125;&#125; 3.获取代理类 1234567891011121314151617import net.sf.cglib.proxy.Enhancer;public class CglibProxyFactory &#123; public static Object getProxy(Class&lt;?&gt; clazz) &#123; // 创建动态代理增强类 Enhancer enhancer = new Enhancer(); // 设置类加载器 enhancer.setClassLoader(clazz.getClassLoader()); // 设置被代理类 enhancer.setSuperclass(clazz); // 设置方法拦截器 enhancer.setCallback(new DebugMethodInterceptor()); // 创建代理类 return enhancer.create(); &#125;&#125; 4.实际使用 12AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);aliSmsService.send(\"java\"); 运行上述代码之后，控制台打印出： 123before method sendsend message:javaafter method send 3.3. JDK 动态代理和 CGLIB 动态代理对比 JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。 4. 静态代理和动态代理的对比 灵活性 ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！ JVM 层面 ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.tenpercent.top/tags/JAVA/"}]},{"title":"Linux 性能监控工具","date":"2018-07-09T16:00:00.000Z","path":"2018/07/10/Linux-performance-monitor/","text":"最近了解了下 Linux 性能相关的东西，主要是如何查看服务器性能的一些工具，在这里做个记录，以后遇到相关使用场景的时候，方便查看。 Linux 性能指标 CPU CPU利用率、用户时间（表示CPU在用户进程上的时间百分比）、系统时间（表示CPU花在内核操作上的时间百分比）、空闲时间、平均负载、阻塞、上下文切换、中断等 内存 空闲内存、Swap利用率、缓冲和缓存、活动和非活动内存等 磁盘IO IO等待、平均队列长度、每秒传输（TPS）等 网络 接收和发送的包、每秒碰撞（各个网络接口所连接网络的所发生的冲突数量）、丢包、错误等 监测工具以下是对 Linux 的性能进行监控的常用工具： 工具 简介 top 查看进程活动状态以及一些系统状况 vmstat 查看系统状态、硬件和系统信息等 iostat 查看 CPU 负载、硬盘状况 sar 综合工具，查看系统状况 mpstat 查看多处理器状况 netstat 查看网络状况 iptraf 实时网络状态监测 tcpdump 抓取网络数据包，详细分析 tcptrace 网络包分析工具 netperf 网络带宽工具 dstat 综合了 vmstat、iostat、ifstat、netstat 等多个信息 这里介绍其中几个。 top 工具top是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。 PID：进程的ID USER：进程所有者 PR：进程的优先级别，越小越优先被执行 NI：nice值 VIRT：进程占用的虚拟内存 RES：进程占用的物理内存 SHR：进程使用的共享内存 S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数 %CPU：进程占用CPU的使用率 %MEM：进程使用的物理内存和总内存的百分比 TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。 COMMAND：进程启动命令名称 vmstat 工具vmstat 是个查看系统整体性能的小工具，小巧，即使在机器负载很高的情况下也运行良好，并且可以用时间间隔采集得到连续的性能数据。 参数介绍： r，可运行队列的线程数，这些线程都是可运行状态，只不过 CPU 暂时不可用 b，被 blocked 的进程数，正在等待 IO 请求 in，被处理过的中断数 cs，系统上正在做上下文切换的数目 us，用户占用 CPU 的百分比 sys，内核和中断占用 CPU 的百分比 wa，所有可运行的线程被 blocked 以后都在等待 IO，这时候 CPU 空闲的百分比 id，CPU 完全空闲的百分比 举两个例子来分析一下 12345678$ vmstat 1procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------ r b swpd free buff cache si so bi bo in cs us sy id wa st 4 0 140 2915476 341288 3951700 0 0 0 0 1057 523 89 21 0 0 0 4 0 140 2915724 341296 3951700 0 0 0 0 1048 546 79 11 0 0 0 4 0 140 2915848 341296 3951700 0 0 0 0 1044 514 88 22 0 0 0 4 0 140 2915848 341296 3951700 0 0 0 24 1044 564 80 20 0 0 0 4 0 140 2915848 341296 3951700 0 0 0 0 1060 546 78 12 0 0 0 从上面的数据可以看出几点： interrupts(in) 非常高，context switch(cs) 比较低，说明这个 CPU 一直在不停的请求资源 user time(us) 一直保持在 80% 以上，而且上下文切换较低 (cs)，说明某个进程可能一直霸占着 CPU run queue(r) 刚好在 4 个 12345678$ vmstat 1procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------ r b swpd free buff cache si so bi bo in cs us sy id wa st14 0 140 2904316 341912 3952308 0 0 0 460 1106 9593 36 64 1 0 017 0 140 2903492 341912 3951780 0 0 0 0 1037 9614 35 65 1 0 020 0 140 2902016 341912 3952000 0 0 0 0 1046 9739 35 64 1 0 017 0 140 2903904 341912 3951888 0 0 0 76 1044 9879 37 63 0 0 016 0 140 2904580 341912 3952108 0 0 0 0 1055 9808 34 65 1 0 0 从上面的数据可以看出几点： context switch(cs) 比 interrupts(in) 要高的多，说明内核不得不来回切换进程 进一步观察发现 system time(sy) 很高而 user time(us) 很低，而且加上高频度的上下文切换 (cs)，说明正在运行的应用程序调用了大量的系统调用 run queue(r) 在 14 个线程以上，而这个机器的硬件配置 (4 核），应该保持在 12 以内。 iostat 工具iostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。iostat属于sysstat软件包。可以用yum install sysstat 直接安装。 cpu属性值说明： %user：CPU处在用户模式下的时间百分比。 %nice：CPU处在带NICE值的用户模式下的时间百分比。 %system：CPU处在系统模式下的时间百分比。 %iowait：CPU等待输入输出完成时间的百分比。 %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。 %idle：CPU空闲时间百分比。 如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。 disk属性值说明： rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/s wrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/s r/s: 每秒完成的读 I/O 设备次数。即 rio/s w/s: 每秒完成的写 I/O 设备次数。即 wio/s rsec/s: 每秒读扇区数。即 rsect/s wsec/s: 每秒写扇区数。即 wsect/s rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。 wkB/s: 每秒写K字节数。是 wsect/s 的一半。 avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。 avgqu-sz: 平均I/O队列长度。 await: 平均每次设备I/O操作的等待时间 (毫秒)。 svctm: 平均每次设备I/O操作的服务时间 (毫秒)。 %util: 一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比 如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。 如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间； 如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。 如果avgqu-sz比较大，也表示有大量io在等待。 sar 工具 sar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。 查看 cpu使用率 sar -u %user 用户模式下消耗的CPU时间的比例； %nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例 %system 系统模式下消耗的CPU时间的比例； %iowait CPU等待磁盘I/O导致空闲状态消耗的时间比例； %steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例； %idle CPU空闲时间比例； 查看平均负载 sar -q runq-sz：运行队列的长度（等待运行的进程数） plist-sz：进程列表中进程（processes）和线程（threads）的数量 ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载 ldavg-15：过去15分钟的系统平均负载 查看内存使用状况 sar -r kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间. kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间. %memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比. kbbuffers和kbcached：这两个值就是free命令中的buffer和cache. kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap). %commit：这个值是kbcommit与内存总量(包括swap)的一个百分比. sar参数说明 -A 汇总所有的报告 -a 报告文件读写使用情况 -B 报告附加的缓存的使用情况 -b 报告缓存的使用情况 -c 报告系统调用的使用情况 -d 报告磁盘的使用情况 -g 报告串口的使用情况 -h 报告关于buffer使用的统计数据 -m 报告IPC消息队列和信号量的使用情况 -n 报告命名cache的使用情况 -p 报告调页活动的使用情况 -q 报告运行队列和交换队列的平均长度 -R 报告进程的活动情况 -r 报告没有使用的内存页面和硬盘块 -u 报告CPU的利用率 -v 报告进程、i节点、文件和锁表状态 -w 报告系统交换活动状况 -y 报告TTY设备活动状况","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.tenpercent.top/tags/Linux/"},{"name":"工具","slug":"工具","permalink":"http://www.tenpercent.top/tags/工具/"}]},{"title":"AOP 学习总结","date":"2018-05-18T16:00:00.000Z","path":"2018/05/19/AOP 学习笔记/","text":"AOP 简述AOP，面向切面编程。其实并不是什么很深奥的理论，就是当你想在做完某个操作后，希望在这个操作的发生前，发生后，返回值后等等场景里，进行一些相应的操作时，不需要每次都要重复的写一遍相应的操作，而是把这些操作定义成一个切面，通过定义好相应的切点后，在操作发生时，由框架帮你把你所定义好的切面织入进来，从而让你再开发的过程中，只需要聚焦于业务即可，而不用每次去处理很多重复的细节。 AOP 的用处AOP 最典型的应用是在数据库事务的管控中。比如要保存用户时，需要连同用户的角色一并保存如数据库，此时，用 OOP 无法完成这样的事务操作，而 AOP 可以完成这些事情。 AOP 开发细节确定连接点AOP 需要有连接点，即在什么时候触发。在 Spring 中就是某个类里的某个方法。 开发切面切面用来描述各个过程中需要做什么，用 @Aspect 注解来定义切面。用 @Before、@After、@AfterReturning、@AfterThrowing 等注解来表示各个过程。 定义切点Spring 里 定义了切点（Pointcut）的概念，切点的作用就是向 Spring 描述哪个类的哪个方法需要启用 AOP 编程。在切面里，切点的代码如下： 123@Pointcut(\"execution(* com.xxx.xxx.xxxImpl.xxxfunction(..))\")public void pointCut()&#123;&#125;; 代码中，用 @Pointcut 来定义切点，标注在 pointcut 方法上。 切点里的正则式含义如下： execution 表示在执行的时候，拦截里面的正则匹配方法 号表示任意返回类型的方法 com.xxx.xxx.xxxImpl 指定目标对象类的全限定名称 xxxfunction 指定目标对象类里的方法 (..)表示任意参数进行匹配 引入，增加切面加入某个切面非自己提供的，不能修改它，而想对它进行补充的时候，Spring 允许通过为这个切面引入新的接口来增强这个切面的功能。步骤如下： 1、 先定义需要引入的新接口 2、在切面里，通过 @DeclareParents 注解来引入，它有两个必须配置的属性 value 和 defaultImpl。 value: 指向你要增强功能的目标对象类 defaultImpl: 引入增强功能的类，即引入的接口的实现类。 多个切面spring 支持多个切面的运行。在组织多个切面时，需要指定各个切面运行的顺序。 SPring 提供了 @Order 注解 和 Orderd 接口两种方式来指定切面的顺序。 实际使用中，用 @Order 比较方便，使用方式如下： 12345678910111213@Aspect@Order(1)public class MyAspect1 &#123; &#125;@Aspect@Order(2)public class MyAspect2 &#123; &#125;","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.tenpercent.top/tags/JAVA/"}]},{"title":"Spring 的 IOC 学习总结","date":"2018-05-11T16:00:00.000Z","path":"2018/05/12/IOC 学习总结/","text":"IOC 描述IOC —— Inversion of control，即控制反转。还有个别名叫 DI（Dependency inject 依赖注入）。 定义 所谓 IoC ，就是由 IoC 容器来负责对象的生命周期和对象之间的关系。 最初的时候 在最早我们使用对象的时候，都是在用到的时候 new 一个，这个会存在一个问题：不灵活。 即当某个类里依赖着某个 new 出来的对象的时候，在后续的使用中，如果需要换个依赖的对象了，需要去修改类里的代码。 IOC 的用处用 IOC 的用处就是可以避免在类里依赖着某个指定对象时直接使用 new 这样的强耦合情况。 IOC 容器存放着对象，管理着依赖关系。当某个类需要什么对象时，只要声明好它对应的依赖，IOC 容器就会自动找到其所依赖的对象进行注入。 所以这就是控制反转：有传统的直接 new 的方式来主动控制到变成由 IOC 容器来控制进行对象的注入 Spring 里的 IOC 实现Spring 的 IOC 容器Spring IOC 容器是一个管理 Bean 的容器，Spring 里所有的 IOC 容器都需要实现 BeanFactory 接口，它是一个顶级容器接口。其源码如下： 12345678910111213141516171819202122232425262728293031323334353637package org.springframework.beans.factory;import org.springframework.beans.BeansExcept 工 on ;import org.springframework . core.ResolvableType ; public interface BeanFactory &#123; //前缀 String FACTORY BEAN PREFIX = \"&amp;”; //多个 getBean 方法 Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String 口ame, Class&lt;T&gt; requiredType) throws Bea口sExcept工on; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object . . args) throws BeansException ; &lt;T&gt; T getBea口( Class&lt;T&gt; requiredType , Object ... args) throws BeansExcept工on; //是否包含 Bean boolean containsBean (String name); II Bean是否单例 boolean isS工ngleton(String name) throws NoSuchBeanDefinitionExcept工on ; II Bean是否原型 boolean isPrototype(String name) throws NoSuchBeanDefinitionException; //是否类型匹配 bool ean isTypeMatch(String name , ResolvableType typeToMatch) throws NoSuchBeanDefin工tionException; boolean isTypeMatch(String name , Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefin工tionException; //获取 Bean 的类型 Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinit工onException ; //获取 Bean 的别名 String[] getAliases(String name);&#125; 可以看到上面代码中有多个getBean方法，这也是IoC容器最重要的方法之一， 它的意义是从 IoC 容器中获取 Beano 而从多个 getBean 方法中可 以看到有按类型( by type)获取 Bean 的，也有按 名称( by name)获取 Bean 的，这就意味着在 Spring IoC 容器中 ，允许我们按类型或者名称获取 Bean。 由于 BeanFactory 的功能还不够强大，因此 Spring在 BeanFactory 的基础上， 还设计了一个更为高级的接口 ApplicationContext。 它是 BeanFactory 的子接口之一 ， 在 Spring 的体 系中 BeanFactory 和 ApplicationContext 是最为重要的接口设计 ，在现实中我们使用的大部分Spring IoC 容器是 ApplicationContext接口的实现类 装配 bean 至容器中 通过扫描装配，即使用 @Component 注解和 @ComponentScan 用 @Bean 注解来实现装配，对某个方法直接使用 @Bean 注解来将其返回的对象注入到容器里","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"JAVA 泛型总结","date":"2018-04-22T16:00:00.000Z","path":"2018/04/23/泛型总结/","text":"泛型类12345678public class Test&lt;T&gt; &#123; private T testname; private T testfunction()&#123; &#125; &#125; 泛型接口12345public interface Test&lt;T&gt; &#123; public T test()&#123;&#125;;&#125; 需注意点： 在声明类实现泛型接口时，若泛型参数未传入实参，则实现类也需要声明泛型 123class MyTest&lt;T&gt; implements Test&lt;T&gt; &#123; public T one()&#123;&#125;;&#125; 在声明类实现泛型接口时，若泛型参数有传入实参，则实现类里所有使用泛型的地方都需要声明对应的类型 1234class MyTest implements Test&lt;String&gt; &#123; @override public String one()&#123;&#125;;&#125; 泛型方法1234public &lt;T&gt; T test(T name)&#123; System.out.print(name);&#125; 需注意点： 泛型方法也可以定义在泛型类中，泛型方法里的泛型参数 T 不受泛型类的泛型参数 T 的影响，是独立的。 \\&lt;T>用来声明该方法为泛型方法，\\只是一个代表符号，也可以用\\ 或其他（ K,V 等）表达。 有了 才可以在泛型方法的参数里声明参数泛型 T ，符号需保持一致，如 对应 E。 泛型通配符上界通配符1&lt;? extends T&gt; 需注意点： 上界通配符只支持从通配类型里 get，而不支持将多种类型的 set 进去, 所以上界描述符Extends适合频繁读取的场景。 原因是： 一个Plate&lt;? extends Fruit&gt;的引用，指向的可能是一个Plate类型的盘子，要往这个盘子里放Banana当然是不被允许的。一个理解是：Plate&lt;? extends Fruit&gt;代表某个只能放某种类型水果的盘子，而不是什么水果都能往里放的盘子 下界通配符1234567891011121314151617181920212223242526&lt;? super T&gt;``` 需注意点：* 下界通配符&lt;? super T&gt;不影响往里面存储，但是读取出来的数据只能是Object类型。原因是：下界通配符规定了元素最小的粒度，必须是T及其基类，那么我往里面存储T及其派生类都是可以的，因为它都可以隐式的转化为T类型。但是往外读就不好控制了，里面存储的都是T及其基类，无法转型为任何一种类型，只有Object基类才能装下。### PECS原则Effective Java书里的PECS原则。* 上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。* 下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。### 无线通配符```java public class test&lt;?&gt; &#123;&#125; 泛型的擦除泛型参数将会被擦除到它的第一个边界（边界可以有多个，重用 extends 关键字，通过它能给与参数类型添加一个边界）。编译器事实上会把类型参数替换为它的第一个边界的类型。如果没有指明边界，那么类型参数将被擦除到Object。 1234567891011121314public interface Test &#123; void f();&#125;public class Manipulator&lt;T extends Test&gt; &#123; T obj; public T getObj() &#123; return obj; &#125; public void setObj(T obj) &#123; this.obj = obj; &#125;&#125; extend关键字后后面的类型信息决定了泛型参数能保留的信息。Java类型擦除只会擦除到 Test 类型。 泛型擦除的缺陷泛型类型不能显式地运用在运行时类型的操作当中，例如：转型、instanceof 和 new。因为在运行时，所有参数的类型信息都丢失了。类似下面的代码都是无法通过编译的： 123456789101112131415public class Erased&lt;T&gt; &#123; private final int SIZE = 100; public static void f(Object arg) &#123; //编译不通过 if (arg instanceof T) &#123; &#125; //编译不通过 T var = new T(); //编译不通过 T[] array = new T[SIZE]; //编译不通过 T[] array = (T) new Object[SIZE]; &#125;&#125;","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.tenpercent.top/tags/JAVA/"}]},{"title":"为什么hashCode()和equal()方法要一起重写？","date":"2018-04-12T16:00:00.000Z","path":"2018/04/13/为什么hashCode()和equal()方法要一起重写/","text":"hashCode()和equal()方法可以看到Obejct类中的源码如下，可以看到equals()方法的默认实现是判断两个对象的内存地址是否相同来决定返回结果。 1234 public native int hashCode();public boolean equals(Object obj) &#123; return (this == obj); &#125; 网上很多博客说hashCode的默认实现是返回内存地址，其实不对，以OpenJDK为例，hashCode的默认计算方法有5种，有返回随机数的，有返回内存地址，具体采用哪一种计算方法取决于运行时库和JVM的具体实现。(可以理解Object类hashCode默认实现是对所有对象返回的值都不一样。) 感兴趣的朋友可以看看这篇博客 Java的Object.hashCode()的返回值到底是不是对象内存地址？ hashCode()方法的作用有哪些？ 对对象做散列 为了将一组键值对均匀得存储在一个数组中，HashMap对key的hashCode进行计算得到一个hash值，用hash对数组长度取模，得到数组下标，将键值对存储在数组下标对应的链表下。 快速判断对象是否不相等 因为两个对象hashCode相等，调用equal()方法的结果不一定为true， 因为两个对象调用equal()方法相等，hashCode一定相等。 所以hashCode不相等可以作为两个对象不相等的快速判断条件。 在往HashMap中添加一个键值对时，计算得到数组下标后，会遍历数组下标下存储的链表中，拿key的hashCode与每个节点的hashCode进行比较，相等时，才调用equal()方法进行继续调用，节约时间。（在一些类的equal()方法的自定义实现中也会对hashCode进行判断）。 假如只重写hashCode()方法（结果：HashMap可以存在两个内存地址不相同，但是相等的对象，无法保证去重）此时equal()方法的实现是默认实现，也就是当两个对象的内存地址相等时，equal()方法才返回true，假设两个键值对，它们的key类型都是TestObject，的值都是test，但是由于是使用new String()创建而成的字符串对象，key1和key2的内存地址不相等，所以key1==key2的结果会是false，TestObject的equals()方法默认实现是判断两个对象的内存地址，所以 key1.equals(key2)也会是false， 所以两个键值对可以重复地添加到hashMap中去。 12345678910111213141516171819202122public class TestObject &#123; Integer a; public TestObject(Integer a) &#123; this.a = a; &#125; @Override public int hashCode() &#123; return a; &#125; public static void main(String[] args) &#123; TestObject key1 = new TestObject(1); TestObject key2 = new TestObject(1); System.out.println(\"key1的hashCode为\"+ key1 +\"key2的hashCode为\" + key2); System.out.println(\"key1.equals(key2)的结果为\"+(key1.equals(key2))); HashMap&lt;TestObject,String&gt; map = new HashMap&lt;TestObject,String&gt;(); map.put(key1,\"value1\"); map.put(key2,\"value2\"); System.out.println(\"HashMap是\"+map.toString()); &#125;&#125; 输出结果： 12345678key1的hashCode为com.test.TestObject@1key2的hashCode为com.test.TestObject@1key1.equals(key2)的结果为false HashMap是&#123;com.test.TestObject@1=value1, com.test.TestObject@1=value2&#125; 假如只重写equals()方法（结果：相同的对象hashCode不同，从而映射到不同下标下，HashMap无法保证去重）假设只equals()方法，hashCode方法会是默认实现，具体的计算方法取决于JVM，可能会导致两个相等的对象，它们的hashCode却不相同，从而计算得到的数组下标不相同，存储到hashMap中不同数组下标下的链表中，也会导致HashMap中存在重复元素。 12345678910111213141516171819202122232425public class TestObject &#123; Integer a; public TestObject(Integer a) &#123; this.a = a; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; TestObject that = (TestObject) o; return Objects.equals(a, that.a); &#125; public static void main(String[] args) &#123; TestObject key1 = new TestObject(1); TestObject key2 = new TestObject(1); System.out.println(\"key1的hashCode为\"+ key1 +\"key2的hashCode为\" + key2); System.out.println(\"key1.equals(key2)的结果为\"+(key1.equals(key2))); HashMap&lt;TestObject,String&gt; map = new HashMap&lt;TestObject,String&gt;(); map.put(key1,\"value1\"); map.put(key2,\"value2\"); System.out.println(\"HashMap是\"+map.toString()); &#125;&#125; 输出结果如下： 1234567key1的hashCode为1288141870 key2的hashCode为2054881392key1.equals(key2)的结果为trueHashMap是&#123;com.test.TestObject@4cc77c2e=value1, com.test.TestObject@7a7b0070=value2&#125;","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.tenpercent.top/tags/JAVA/"}]},{"title":"浅析 PHP7 的垃圾回收机制","date":"2018-03-28T16:00:00.000Z","path":"2018/03/29/php7-garbage-collection/","text":"垃圾回收机制垃圾回收机制是一种动态存储分配方案。它会自动释放程序不再需要的已分配的内存块。 自动回收内存的过程叫垃圾收集。垃圾回收机制可以让程序员不必过分关心程序内存分配，从而将更多的精力投入到业务逻辑。 在现在的流行各种语言当中，垃圾回收机制是新一代语言所共有的特征。 垃圾的产生PHP7 中复杂类型，像字符串、数组、对象等的数据结构中，头部都有一个 gc, 这个 gc 的作用就是用来对垃圾回收的支持。当变量赋值、传递时，会增加 value 的引用数， unset、return 等释放变量时再减掉引用数，减掉后如果发现 refcount 变为 0 则直接释放 value，这是变量的基本回收过程。 不过有一种问题是这个机制无法解决的，就是循环引用的问题。 什么是循环引用呢？ 简单说就是变量的内部里存的 value 又引用了变量自身。 这种比较经常发生在数组和对象类型的变量上。 这里先讲一下引用，即 zend_reference 这个类型，这个是 PHP7 新增的变量类型，当对变量使用 “&amp;” 操作时，会创建新的中间结构体 zend_reference，这个结构体会真正的指向对应的 value 结构。 举个例子： 1234// 当进行如下赋值操作时$a = 'hello'; // $a -&gt; zend_string$b = $a; // $b,$a -&gt; zend_string$c = &amp;$b; // $c,$b -&gt; zval(type = IS_REFERENCE, refcount = 2) -&gt; zend_string 最终会变成如下这样： 即 $b 和 $c 的 zval 是通过中间结构体 zend_reference 再指向最终的 zend_string。 回到循环引用的问题，举个数组循环引用例子： 1234$a = [1];$a[] = &amp;$a;unset($a); 使用 &amp; 操作之后，变量 a 就变成了引用类型且引用计数 refcount 为 2，而又赋值给自己里面的元素，即变量 a 变成了自己引用自己。 具体如下如所示： 当 unset 之后就变成下图这样： 即 $a 所在的 zval 类型已经变成了 IS_UNDEF 了，zend_reference 结构体的引用计数减 1，但是仍然大于 0，这时候，这部分结构体就变成了垃圾，对此不处理的话，就可能会造成内存泄露。这里就需要垃圾收集器将这部分收集到缓冲区，之后进行回收处理。 回收过程如果当变量的 refcount 减小后大于 0，PHP 并不会立即对这个变量进行垃圾鉴定和回收，而是放入一个缓冲区中，等这个缓冲区满了以后(10000 个值)再统一进行处理，加入缓冲区的是变量 zend_value 里的 gc，目前垃圾只会出现在数组和对象两种类型中，数组的情况上面已经介绍了，对象的情况则是成员属性引用对象本身导致的，其它类型不会出现这种变量中的成员引用变量自身的情况，所以垃圾回收只会处理这两种类型的变量。 gc 的结构 zend_refcounted_h 具体如下: 123456789101112typedef struct _zend_refcounted_h &#123; uint32_t refcount; // 记录 zend_value 的引用数 union &#123; struct &#123; zend_uchar type, // zend_value的类型, 与zval.u1.type一致 zend_uchar flags, uint16_t gc_info // GC信息，记录在 gc 池中的位置和颜色，垃圾回收的过程会用到 &#125; v; uint32_t type_info; &#125; u;&#125; zend_refcounted_h; 一个变量只能加入一次缓冲区，为了防止重复加入，变量加入后会把 zend_refcounted_h.gc_info 置为 GC_PURPLE，即标为紫色，后续不会重复插入。 垃圾缓冲区是一个双向链表，等到缓存区满了以后则启动垃圾检查过程：遍历缓冲区，对当前变量的所有成员进行遍历，然后把成员的 refcount 减 1 (如果成员还包含子成员则也进行递归遍历，即深度优先遍历)，最后再检查当前变量的引用，如果减为了 0 则为垃圾。这个算法的原理核心是：垃圾是由于成员引用自身导致的，那么就对所有的成员减一遍引用，如果发现最后变量本身的 refcount 变为了 0 则就表明其引用全部来自自身成员，即其他任何地方都不再使用它，那么它就是垃圾，需要被回收掉。反之说明不是垃圾，需要将其从缓冲区移出去。具体的过程如下： (1) 从缓冲区链表的 roots 开始遍历，把当前 value 标为灰色 (zend_refcounted_h.gc_info 置为 GC_GREY)，然后对当前 value 的成员进行深度优先遍历，把成员 value 的 refcount 减 1，并且也标为灰色； (2) 重复遍历缓冲区链表，检查当前 value 引用是否为 0，为 0 则表示确实是垃圾，把它标为白色(GC_WHITE)，如果不为 0 则排除了引用全部来自自身成员的可能，表示还有外部的引用，并不是垃圾，这时候因为步骤(1)对成员进行了 refcount 减 1 操作，需要再还原回去，对所有成员进行深度遍历，把成员 refcount 加 1，同时标为黑色； (3) 再次遍历缓冲区链表，将非 GC_WHITE 的节点从 roots 链表中移出（移到待释放的列表），最终 roots 链表中全部为真正的垃圾，最后将这些垃圾清除。 参考资料 《PHP7 底层设计与源码解析》 php7-internal","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"底层","slug":"底层","permalink":"http://www.tenpercent.top/tags/底层/"}]},{"title":"PHP7 数组的底层实现","date":"2018-03-22T16:00:00.000Z","path":"2018/03/23/PHP7-Array/","text":"PHP 数组具有的特性PHP 的数组是一种非常强大灵活的数据类型，在讲它的底层实现之前，先看一下 PHP 的数组都具有哪些特性。 可以使用数字或字符串作为数组健值 12$arr = [1 =&gt; 'ok', 'one' =&gt; 'hello']; 可按顺序读取数组 1234foreach($arr as $key =&gt; $value)&#123; echo $arr[$key];&#125; 可随机读取数组中的元素 12345$arr = [1 =&gt; 'ok', 'one' =&gt; 'hello', 'a' =&gt; 'world'];echo $arr['one'];echo current($arr); 数组的长度是可变的 123456$arr = [1, 2, 3];$arr[] = 4;array_push($arr, 5); 正是基于这些特性，我们可以使用 PHP 中的数组轻易的实现集合、栈、列表、字典等多种数据结构。那么这些特性在底层是如何实现的呢？ 这就得从数据结构说起了。 数据结构 PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。 PHP 数组的底层实现是散列表（也叫 hashTable )，散列表是根据键（Key）直接访问内存存储位置的数据结构，它的key - value 之间存在一个映射函数，可以根据 key 通过映射函数得到的散列值直接索引到对应的 value 值，无需通过关键字比较，在理想情况下，不考虑散列冲突，散列表的查找效率是非常高的，时间复杂度是 O(1)。 从源码中我们可以看到 zend_array 的结构如下： 123456789101112131415161718192021222324typedef struct _zend_array zend_array;typedef struct _zend_array hashTable;struct _zend_array &#123; zend_refcounted_h gc; union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar flags, zend_uchar nApplyCount, zend_uchar nIteratorsCount, zend_uchar reserve) &#125; v; uint32_t flags; &#125; u; uint32_t nTableMask; // 哈希值计算掩码，等于nTableSize的负值(nTableMask = -nTableSize) Bucket *arData; // 存储元素数组，指向第一个Bucket uint32_t nNumUsed; // 已用Bucket数（含失效的 Bucket） uint32_t nNumOfElements; // 哈希表有效元素数 uint32_t nTableSize; // 哈希表总大小，为2的n次方（包括无效的元素） uint32_t nInternalPointer; // 内部指针，用于遍历 zend_long nNextFreeElement; // 下一个可用的数值索引,如:arr[] = 1;arr[\"a\"] = 2;arr[] = 3; 则nNextFreeElement = 2; dtor_func_t pDestructor;&#125;; 该结构中的 Bucket 即储存元素的数组，arData 指向数组的起始位置，使用映射函数对 key 值进行映射后可以得到偏移值，通过内存起始位置 + 偏移值即可在散列表中进行寻址操作。 Bucket 的数据结构如下： 12345typedef struct _Bucket &#123; zval val; // 存储的具体 value，这里是一个 zval，而不是一个指针 zend_ulong h; // 数字 key 或字符串 key 的哈希值。用于查找时 key 的比较 zend_string *key; // 当 key 值为字符串时，指向该字符串对应的 zend_string（使用数字索引时该值为 NULL），用于查找时 key 的比较&#125; Bucket; 到这里有个问题出现了：存储在散列表里的元素是无序的，PHP 数组如何做到按顺序读取的呢？ 答案是中间映射表，为了实现散列表的有序性，PHP 为其增加了一张中间映射表，该表是一个大小与 Bucket 相同的数组，数组中储存整形数据，用于保存元素实际储存的 Value 在 Bucekt 中的下标。Bucekt 中的数据是有序的，而中间映射表中的数据是无序的。 而通过映射函数映射后的散列值要在中间映射表的区间内，这就对映射函数提出了要求。 映射函数PHP7 数组采用的映射方式： 1nIndex = h | ht-&gt;nTableMask; 将 key 经过 time33 算法生成的哈希值 h 和 nTableMask 进行或运算即可得出映射表的下标，其中 nTableMask 数值为 nTableSize 的负数。并且由于 nTableSize 的值为 2 的幂次方，所以 nTableMask 二进制位右侧全部为 0，保证了 h | ht-&gt;nTableMask 的取值范围会在 [-nTableSize, -1] 之间，正好在映射表的下标范围内。另外，用按位或运算的方法和其他方法如取余的方法相比运算速度较高，这个映射函数可以说设计的非常巧妙了。 散列（哈希）冲突不同键名的通过映射函数计算得到的散列值有可能相同，此时便发生了散列冲突。 对于散列冲突有以下 4 种常用方法： 1.将散列值放到相邻的最近地址里 2.换个散列函数重新计算散列值 3.将冲突的散列值统一放到另一个地方 4.在冲突位置构造一个单向链表，将散列值相同的元素放到相同槽位对应的链表中。这个方法叫链地址法，PHP 数组就是采用这个方法解决散列冲突的问题。 其具体实现是：将冲突的 Bucket 串成链表，这样中间映射表映射出的就不是某一个元素，而是一个 Bucket 链表，通过散列函数定位到对应的 Bucket 链表时，需要遍历链表，逐个对比 Key 值，继而找到目标元素。而每个 Bucket 之间的链接则是将原 value 的下标保存到新 value 的 zval.u2.next 里，新 value 放在当前位置上，从而形成一个单向链表。 举个例子： 当我们访问 $arr[‘key’] 的过程中，假设首先通过散列运算得出映射表下标为 -2 ，然后访问映射表发现其内容指向 arData 数组下标为 1 的元素。此时我们将该元素的 key 和要访问的键名相比较，发现两者并不相等，则该元素并非我们所想访问的元素，而元素的 zval.u2.next 保存的值正是另一个具有相同散列值的元素对应 arData 数组的下标，所以我们可以不断通过 zval.u2.next 的值遍历直到找到键名相同的元素。 扩容PHP 的数组在底层实现了自动扩容机制，当插入一个元素且没有空闲空间时，就会触发自动扩容机制，扩容后再执行插入。 扩容的过程为： 如果已删除元素所占比例达到阈值，则会移除已被逻辑删除的 Bucket，然后将后面的 Bucket 向前补上空缺的 Bucket，因为 Bucket 的下标发生了变动，所以还需要更改每个元素在中间映射表中储存的实际下标值。 如果未达到阈值，PHP 则会申请一个大小是原数组两倍的新数组，并将旧数组中的数据复制到新数组中，因为数组长度发生了改变，所以 key-value 的映射关系需要重新计算，这个步骤为重建索引。 重建散列表在删除某一个数组元素时，会先使用标志位对该元素进行逻辑删除，即在删除 value 时只是将 value 的 type 设置为 IS_UNDEF，而不会立即删除该元素所在的 Bucket，因为如果每次删除元素立刻删除 Bucket 的话，每次都需要进行排列操作，会造成不必要的性能开销。 所以，当删除元素达到一定数量或扩容后都需要重建散列表，即移除被标记为删除的 value。因为 value 在 Bucket 位置移动了或哈希数组 nTableSize 变化了导致 key 与 value 的映射关系改变，重建过程就是遍历 Bucket 数组中的 value，然后重新计算映射值更新到散列表。 关于 PHP7 的数组底层实现就总结这么些了，因为水平有限也无法研究的十分详尽清楚，如果有疑问或者不足之处欢迎提出~~ 参考资料 《PHP7 的底层设计与源码实现》 php7-internal","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"底层","slug":"底层","permalink":"http://www.tenpercent.top/tags/底层/"}]},{"title":"PHP7 的基本变量","date":"2018-03-14T16:00:00.000Z","path":"2018/03/15/php-zval-struct/","text":"变量的基础结构我们都知道PHP的变量是弱类型的，声明的时候无需指定类型。那么这里面具体是怎么实现的呢？这就得从变量的基础结构说起了。 zval的实现在源码文件 zend_type.h 中，可以看到 zval 的定义： 1234567891011121314151617181920212223242526typedef struct _zval_struct zval;struct _zval_struct &#123; zend_value value; /* value */ union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar type, /* active type */ zend_uchar type_flags, zend_uchar const_flags, zend_uchar reserved) /* call info for EX(This) */ &#125; v; uint32_t type_info; &#125; u1; union &#123; uint32_t next; /* hash collision chain */ uint32_t cache_slot; /* literal cache slot */ uint32_t lineno; /* line number (for ast nodes) */ uint32_t num_args; /* arguments number for EX(This) */ uint32_t fe_pos; /* foreach position */ uint32_t fe_iter_idx; /* foreach iterator index */ uint32_t access_flags; /* class constant access flags */ uint32_t property_guard; /* single property guard */ uint32_t extra; /* not further specified */ &#125; u2;&#125; zval 的结构由一个保存变量类型的值或指针的 union 联合体 zend_value 以及两个 union 联合体 u1 和 u2 组成 u1 u1的作用是用来保存变量类型及其信息，其里面的字段用处如下： type：记录变量类型。 即可通过 u2.v.type 来访问到 type_flags：对应变量特有类型的标记（如常量类型，需引用计数类型，不可变类型），不同类型的变量对应的 flag 不一样。 const_flags：常量类型的标记 reserved：保留字段 u2 u2 主要是辅助作用，由于结构体的内存对齐，所以 u2 的的这块空间有或者没有 u2 都是已经占据空间了，所以就利用起来。u2的辅助字段里面记录了很多类型信息，这些信息对内部功能有很大的好处，或提升缓存友好性或减少了内存寻址的操作。这里介绍其中部分字段。 next：用来解决哈希冲突问题（哈希冲突这个目前还不懂），记录冲突的下一个元素位置。 cache_slot：运行时缓存。在执行函数时会优先去缓存中查找，若缓存中没有，再去全局的 function 表中查找。 num_args：函数调用时传入参数的个数 access_flags：对象类的访问标识，如public protected private 这些。 zend_value 12345678910111213141516171819typedef union _zend_value &#123; zend_long lval; /* 整型*/ double dval; /* 浮点型 */ zend_refcounted *counted; zend_string *str; zend_array *arr; zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; zval *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct &#123; uint32_t w1; uint32_t w2; &#125; ww;&#125; zend_value; 从 zend__value 中可以看出，long、double 类型直接存储值，而其它类型都为指针，指向各自的结构。所以，由于 zval 这样的结构，PHP 变量在声明的时候不用显示的指定其类型，因为不管你赋给变量什么类型的值，它都能帮你找到对应的存储结构。 以值为字符串的变量为例，其结构是这样的： PHP5 与 PHP7 的 zval 结构对比 PHP5 PHP7 可以看到 php7 的 zval 总的只占 16 个字节，相比 PHP5 的 zval 所占用的 48 个字节节省了很大的内存。 此外，在 PHP5 中，所有的变量都在堆中申请，但是对于临时变量来说，没有必要在堆中申请。所以在 PHP7 中对此做了优化，临时变量是直接在栈中申请的。 常见变量类型下面介绍几个常见类型的变量结构，其他更多的类型，可自行查看源码。 整型和浮点型对于整型和浮点型，由于其占用空间小，在 zval 中是直接存储的 整型的值是存在 lval 里，浮点型值则是存储在 dval 里。 12345typedef union _zend_value &#123; zend_long lval; /* 整型*/ double dval; /* 浮点型 */ ... &#125; 字符串PHP 7 中定义了新的字符串结构体。结构如下： 123456struct _zend_string &#123; zend_refcounted_h ; zend_ulong h; /* hash value */ size_t len; char val[1];&#125;; 上面各个字段的意思： gc： 变量引用信息，所有用到引用计数的变量类型都会有这个结构。 h： 哈希值，数组中计算索引时会用到。（据说这个操作为 PHP7 提高了 5% 的性能） len： 字符串长度，通过这个值保证二进制安全 val： 字符串内容，变长struct，分配时按len长度申请内存数组 array 是 PHP 中非常强大的一个数据结构，它的底层实现就是普通的有序HashTable，这里简单看下它的结构。后续再具体深入。 123456789101112131415161718192021222324typedef struct _zend_array HashTable;struct _zend_array &#123; zend_refcounted_h gc; union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar flags, zend_uchar nApplyCount, zend_uchar nIteratorsCount, zend_uchar consistency) &#125; v; uint32_t flags; &#125; u; uint32_t nTableMask; Bucket *arData; uint32_t nNumUsed; uint32_t nNumOfElements; uint32_t nTableSize; uint32_t nInternalPointer; zend_long nNextFreeElement; dtor_func_t pDestructor;&#125; ###对象 PHP7 的对象结构也是重新设计了，和 PHP5 的实现有了很大的不同。 12345678struct _zend_object &#123; zend_refcounted_h gc; uint32_t handle; zend_class_entry *ce; const zend_object_handlers *handlers; HashTable *properties; zval properties_table[1];&#125;; 这里介绍下其中几个字段： gc：gc头部 *ce：对象对应的 class 类 *properties ：HashTable结构，key 为对象的属性名，value 是属性值在properties_tables数组中的偏移量，通过偏移量在 properties_talbe 找到对应的属性值。 properties_talbe[1]：存储对象的属性值 ok，先写这到这里。 参考资料 《PHP7 底层设计与源码实现》","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"底层","slug":"底层","permalink":"http://www.tenpercent.top/tags/底层/"}]},{"title":"浅析 PHP7 底层运行机制","date":"2018-03-08T16:00:00.000Z","path":"2018/03/09/PHP-internal-learning/","text":"PHP7 代码执行过程PHP 是解释型语言，其执行过程需先编译成中间代码，再经由特定的虚拟机，翻译成特定的指令被执行。其执行过程如下： 1PHP 代码 =&gt; Token =&gt; 抽象语法树 =&gt; Opcodes =&gt; 执行 各个步骤内容如下： 源代码通过词法分析得到 Token Token 是 PHP 代码被切割成的有意义的标识。PHP7 一共有 137 种 Token，在zend_language_parser.h 文件中做了定义。 基于语法分析器将 Token 转换成抽象语法树（AST） Token 就是一个个的词块，但是单独的词块不能表达完整的语义，还需要借助一定的规则进行组织串联。所以就需要语法分析器根据语法匹配Token，将 Token 进行串联。语法分析器串联完 Token 后的产物就是抽象语法树（AST，Abstract Syntax Tree）。AST 是 PHP7 版本的新特性，之前版本的 PHP 代码的执行过程中是没有生成 AST 这一步的。它的作用主要是实现了PHP编译器和解释器的解耦，提升了可维护性。 将语法树转换成 Opcode 需要将语法树转换成Opcode，才能被引擎直接执行。 执行 Opcodes opcodes 是 opcode 的集合形式，是 PHP 执行过程中的中间代码。PHP工程优化措施中有一个比较常见的“开启 opcache”，指的技术这里将 opcodes 进行缓存。通过省去从源码到 opcode 的阶段，引擎直接执行缓存好的 opacode，以提升性能。 PHP7 内核架构 要把这张图印在脑海里 zend引擎 词法/语法分析、AST编译和 opcodes 的执行均在 Zend 引擎中实现。此外，PHP的变量设计、内存管理、进程管理等也在引擎层实现。 PHP层 zend 引擎为 PHP 提供基础能力，而来自外部的交互则需要通过 PHP 层来处理。 SAPI server API 的缩写，其中包含了场景的 cli SAPI 和 fpm SAPI。只要遵守定义好的 SAPI 协议，外部模块便可与PHP完成交互。 扩展部分 依据 zend 引擎提供的核心能力和接口规范，可以进行开发扩展。 PHP 7 源码结构php 7 的源码主要目录有：sapi 、Zend、main、ext 和 TSRM 这几个。 sapi目录 sapi目录是对输入和输出层的抽象，是PHP提供对外服务的规范。 几种常用的 SAPI： 1）apache2handler: Apache 扩展，编译后生成动态链接库，配置到Apache下。当有 http 请求到 Apache 时，根据配置会调用此动态链接库来执行PHP代码，完成与PHP的交互。 2）cgi-fcgi: 编译后生成支持 CGI 协议的可执行程序，webserver（如NGINX）通过 CGI 协议把请求传给CGI进程，CGI 进程根据请求执行相应代码后将执行结果返回给 webserver。 3）fpm-fcgi: fpm是 FastCGI 进程管理器。以 NGINX 服务器为例，当有请求发送到 NGINX 服务器，NGINX 按照 FastCGI 协议把请求交给 php-fpm 进程处理。 4）cli: PHP的命令行交互接口 Zend 目录 Zend 目录是 PHP 的核心代码。PHP中的内存管理，垃圾回收、进程管理、变量、数组实现等均在该目录的源码里。 main 目录 main目录是SAPI层和Zend层的黏合剂。Zend 层实现了 PHP 脚本的编译和执行，sapi 层实现了输入和输出的抽象，main目录则在它们中间起着承上启下的作用。承上，解析 SAPI 的请求，分析要执行的脚本文件和参数；启下，调用 zend 引擎之前，完成必要的模块初始化等工作。 ext目录 ext 是 PHP 扩展相关的目录，常用的 array、str、pdo 等系列函数都在这里定义。 TSRM TSRM（Thread Safe Resource Manager）——线程安全资源管理器， 是用来保证资源共享的安全。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"底层","slug":"底层","permalink":"http://www.tenpercent.top/tags/底层/"}]},{"title":"深入解析 composer 的自动加载原理","date":"2018-02-26T16:00:00.000Z","path":"2018/02/27/composer-autoload/","text":"前言PHP 自5.3的版本之后，已经重焕新生，命名空间、性状（trait）、闭包、接口、PSR 规范、以及 composer 的出现已经让 PHP 变成了一门现代化的脚本语言。PHP 的生态系统也一直在演进，而 composer 的出现更是彻底的改变了以往构建 PHP 应用的方式，我们可以根据 PHP 的应用需求混合搭配最合适的 PHP 组件。当然这也得益于 PSR 规范的提出。 掌握 composer 自动加载原理的好处 更好的运用 composer 来构建我们的 PHP 应用程序 对 PSR 规范有进一步的了解 当需要用到没有 composer 化的第三方库时，可以将其 composer 化来提高工程效率 学习比较严谨、高深的编码技巧 大纲 PHP 自动加载功能 PSR 规范 comoposer 的自动加载过程 composer 源码分析 一、PHP 自动加载功能PHP 自动加载功能的由来在 PHP 开发过程中，如果希望从外部引入一个 Class ，通常会使用 include 和 require 方法，去把定义这个 Class 的文件包含进来。这个在小规模开发的时候，没什么大问题。但在大型的开发项目中，使用这种方式会带来一些隐含的问题：如果一个 PHP 文件需要使用很多其它类，那么就需要很多的 require/include 语句，这样有可能会 造成遗漏 或者 包含进不必要的类文件。如果大量的文件都需要使用其它的类，那么要保证每个文件都包含正确的类文件肯定是一个噩梦， 况且 require或 incloud 的性能代价很大。 PHP5 为这个问题提供了一个解决方案，这就是 类的自动加载(autoload)机制。autoload机制 可以使得 PHP 程序有可能在使用类时才自动包含类文件，而不是一开始就将所有的类文件include进来，这种机制也称为 Lazy loading (惰性加载)。 总结起来，自动加载功能带来了几处优点： 使用类之前无需 include / require 使用类的时候才会 include / require 文件，实现了 lazy loading ，避免了 include / require 多余文件。 无需考虑引入 类的实际磁盘地址 ，实现了逻辑和实体文件的分离。 PHP 自动加载函数 __autoload() 通常 PHP5 在使用一个类时，如果发现这个类没有加载，就会自动运行 __autoload() 函数，这个函数是我们在程序中自定义的，在这个函数中我们可以加载需要使用的类。下面是个简单的示例： 12345&lt;?phpfunction __autoload($classname) &#123; require_once ($classname . \".class.php\");&#125; 在我们这个简单的例子中，我们直接将类名加上扩展名 .class.php 构成了类文件名，然后使用 require_once 将其加载。 从这个例子中，我们可以看出 __autoload 至少要做三件事情： 根据类名确定类文件名； 确定类文件所在的磁盘路径； 将类从磁盘文件中加载到系统中。 第三步最简单，只需要使用 include / require 即可。要实现第一步，第二步的功能，必须在开发时约定类名与磁盘文件的映射方法，只有这样我们才能根据类名找到它对应的磁盘文件。 当有大量的类文件要包含的时候，我们只要确定相应的规则，然后在 __autoload() 函数中，将类名与实际的磁盘文件对应起来，就可以实现 lazy loading 的效果 。 如果想详细的了解关于 autoload 自动加载的过程，可以查看手册资料：PHP autoload函数说明 __autoload() 函数存在的问题 如果在一个系统的实现中，如果需要使用很多其它的类库，这些类库可能是由不同的开发人员编写的， 其类名与实际的磁盘文件的映射规则不尽相同。这时如果要实现类库文件的自动加载，就必须 在 __autoload() 函数中将所有的映射规则全部实现，这样的话 __autoload() 函数有可能会非常复杂，甚至无法实现。最后可能会导致 __autoload() 函数十分臃肿，这时即便能够实现，也会给将来的维护和系统效率带来很大的负面影响。 那么问题出现在哪里呢？问题出现在 __autoload() 是全局函数只能定义一次 ，不够灵活，所以所有的类名与文件名对应的逻辑规则都要在一个函数里面实现，造成这个函数的臃肿。那么如何来解决这个问题呢？答案就是使用一个 __autoload调用堆栈 ，不同的映射关系写到不同的 __autoload函数 中去，然后统一注册统一管理，这个就是 PHP5 引入的 SPL Autoload 。 SPL Autoload SPL是 Standard PHP Library(标准PHP库)的缩写。它是 PHP5 引入的一个扩展标准库，包括 spl autoload 相关的函数以及各种数据结构和迭代器的接口或类。spl autoload 相关的函数具体可见 php中spl_autoload 123456789101112131415161718192021222324252627282930313233343536&lt;?php// __autoload 函数//// function __autoload($class) &#123;// include 'classes/' . $class . '.class.php';// &#125;function my_autoloader($class) &#123; include 'classes/' . $class . '.class.php';&#125;spl_autoload_register('my_autoloader');// 定义的 autoload 函数在 class 里// 静态方法class MyClass &#123; public static function autoload($className) &#123; // ... &#125;&#125;spl_autoload_register(array('MyClass', 'autoload'));// 非静态方法class MyClass &#123; public function autoload($className) &#123; // ... &#125;&#125;$instance = new MyClass();spl_autoload_register(array($instance, 'autoload')); spl_autoload_register() 就是我们上面所说的__autoload调用堆栈，我们可以向这个函数注册多个我们自己的 autoload() 函数，当 PHP 找不到类名时，PHP就会调用这个堆栈，然后去调用自定义的 autoload() 函数，实现自动加载功能。如果我们不向这个函数输入任何参数，那么就会默认注册 spl_autoload() 函数。 二、PSR 规范与自动加载相关的规范是 PSR4，在说 PSR4 之前先介绍一下PSR标准。PSR 标准的发明和推出组织是：PHP-FIG，它的网站是：www.php-fig.org。由几位开源框架的开发者成立于 2009 年，从那开始也选取了很多其他成员进来，虽然不是 “官方” 组织，但也代表了社区中不小的一块。组织的目的在于：以最低程度的限制，来统一各个项目的编码规范，避免各家自行发展的风格阻碍了程序员开发的困扰，于是大伙发明和总结了 PSR，PSR是 PHP Standards Recommendation 的缩写，截止到目前为止，总共有 14 套 PSR 规范，其中有 7 套PSR规范已通过表决并推出使用，分别是： PSR-0 自动加载标准（已废弃，一些旧的第三方库还有在使用） PSR-1 基础编码标准 PSR-2 编码风格向导 PSR-3 日志接口 PSR-4 自动加载的增强版，替换掉了 PSR-0 PSR-6 缓存接口规范 PSR-7 HTTP 消息接口规范 具体详细的规范标准可以查看PHP 标准规范 PSR4 标准2013 年底，PHP-FIG 推出了第 5 个规范——PSR-4。 PSR-4 规范了如何指定文件路径从而自动加载类定义，同时规范了自动加载文件的位置。 1）一个完整的类名需具有以下结构：\\&lt;命名空间&gt;\\&lt;子命名空间&gt;\\&lt;类名&gt; 完整的类名必须要有一个顶级命名空间，被称为 “vendor namespace”； 完整的类名可以有一个或多个子命名空间； 完整的类名必须有一个最终的类名； 完整的类名中任意一部分中的下滑线都是没有特殊含义的； 完整的类名可以由任意大小写字母组成； 所有类名都必须是大小写敏感的。 2）根据完整的类名载入相应的文件 完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为「命名空间前缀」，其必须与至少一个「文件基目录」相对应； 紧接命名空间前缀后的子命名空间 必须 与相应的「文件基目录」相匹配，其中的命名空间分隔符将作为目录分隔符。 末尾的类名必须与对应的以 .php 为后缀的文件同名。 自动加载器（autoloader）的实现一定不可抛出异常、一定不可触发任一级别的错误信息以及不应该有返回值。 3) 例子PSR-4风格 类名：\\Zend\\Abc命名空间前缀：Zend文件基目录：/usr/includes/Zend/文件路径：/usr/includes/Zend/Abc.php 类名：\\Symfony\\Core\\Request命名空间前缀：Symfony\\Core文件基目录：./vendor/Symfony/Core/文件路径：./vendor/Symfony/Core/Request.php 目录结构 1234567-vendor/| -vendor_name/| | -package_name/| | | -src/| | | | -ClassName.php # Vendor_Name\\Package_Name\\ClassName| | | -tests/| | | | -ClassNameTest.php # Vendor_Name\\Package_Name\\ClassNameTest Composer自动加载过程Composer 做了哪些事情 你有一个项目依赖于若干个库。 其中一些库依赖于其他库。 你声明你所依赖的东西。 Composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。 例如，你正在创建一个项目，需要做一些单元测试。你决定使用 phpunit 。为了将它添加到你的项目中，你所需要做的就是在 composer.json 文件里描述项目的依赖关系。 12345&#123; \"require\": &#123; \"phpunit/phpunit\":\"~6.0\", &#125;&#125; 然后在 composer require 之后我们只要在项目里面直接 use phpunit 的类即可使用。 执行 composer require 时发生了什么 composer 会找到符合 PR4 规范的第三方库的源 将其加载到 vendor 目录下 初始化顶级域名的映射并写入到指定的文件里（如：&#39;PHPUnit\\\\Framework\\\\Assert&#39; =&gt; __DIR__ . &#39;/..&#39; . &#39;/phpunit/phpunit/src/Framework/Assert.php&#39;） 写好一个 autoload 函数，并且注册到 spl_autoload_register()里 题外话：现在很多框架都已经帮我们写好了顶级域名映射了，我们只需要在框架里面新建文件，在新建的文件中写好命名空间，就可以在任何地方 use 我们的命名空间了。 Composer 源码分析下面我们通过对源码的分析来看看 composer 是如何实现 PSR4标准 的自动加载功能。 很多框架在初始化的时候都会引入 composer 来协助自动加载的，以 Laravel 为例，它入口文件 index.php 第一句就是利用 composer 来实现自动加载功能。 启动1234&lt;?php define('LARAVEL_START', microtime(true)); require __DIR__ . '/../vendor/autoload.php'; 去 vendor 目录下的 autoload.php ： 1234&lt;?php require_once __DIR__ . '/composer' . '/autoload_real.php'; return ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29::getLoader(); 这里就是 Composer 真正开始的地方了 Composer自动加载文件首先，我们先大致了解一下Composer自动加载所用到的源文件。 autoload_real.php: 自动加载功能的引导类。 composer 加载类的初始化(顶级命名空间与文件路径映射初始化)和注册(spl_autoload_register())。 ClassLoader.php : composer 加载类。 composer 自动加载功能的核心类。 autoload_static.php : 顶级命名空间初始化类， 用于给核心类初始化顶级命名空间。 autoload_classmap.php : 自动加载的最简单形式， 有完整的命名空间和文件目录的映射； autoload_files.php : 用于加载全局函数的文件， 存放各个全局函数所在的文件路径名； autoload_namespaces.php : 符合 PSR0 标准的自动加载文件， 存放着顶级命名空间与文件的映射； autoload_psr4.php : 符合 PSR4 标准的自动加载文件， 存放着顶级命名空间与文件的映射； autoload_real 引导类 在 vendor 目录下的 autoload.php 文件中我们可以看出，程序主要调用了引导类的静态方法 getLoader() ，我们接着看看这个函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php public static function getLoader() &#123; if (null !== self::$loader) &#123; return self::$loader; &#125; spl_autoload_register( array('ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader'), true, true ); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister( array('ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader') ); $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION'); if ($useStaticLoader) &#123; require_once __DIR__ . '/autoload_static.php'; call_user_func( \\Composer\\Autoload\\ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::getInitializer($loader) ); &#125; else &#123; $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; /***********************注册自动加载核心类对象********************/ $loader-&gt;register(true); /***********************自动加载全局函数********************/ if ($useStaticLoader) &#123; $includeFiles = Composer\\Autoload\\ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$files; &#125; else &#123; $includeFiles = require __DIR__ . '/autoload_files.php'; &#125; foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file); &#125; return $loader; &#125; 我把自动加载引导类分为 5 个部分。 第一部分——单例第一部分很简单，就是个最经典的单例模式，自动加载类只能有一个。 1234&lt;?php if (null !== self::$loader) &#123; return self::$loader; &#125; 第二部分——构造ClassLoader核心类第二部分 new 一个自动加载的核心类对象。 1234567891011&lt;?php /***********************获得自动加载核心类对象********************/ spl_autoload_register( array('ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader'), true, true ); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister( array('ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader') ); loadClassLoader()函数： 1234567&lt;?phppublic static function loadClassLoader($class)&#123; if ('Composer\\Autoload\\ClassLoader' === $class) &#123; require __DIR__ . '/ClassLoader.php'; &#125;&#125; 从程序里面我们可以看出，composer 先向 PHP 自动加载机制注册了一个函数，这个函数 require 了 ClassLoader 文件。成功 new 出该文件中核心类 ClassLoader() 后，又销毁了该函数。 第三部分 —— 初始化核心类对象12345678910111213141516171819202122232425&lt;?php /***********************初始化自动加载核心类对象********************/ $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION'); if ($useStaticLoader) &#123; require_once __DIR__ . '/autoload_static.php'; call_user_func( \\Composer\\Autoload\\ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::getInitializer($loader) ); &#125; else &#123; $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; 这一部分就是对自动加载类的初始化，主要是给自动加载核心类初始化顶级命名空间映射。 初始化的方法有两种： 1. 使用 autoload_static 进行静态初始化； 2. 调用核心类接口初始化。 autoload_static 静态初始化 ( PHP &gt;= 5.6 )静态初始化只支持 PHP5.6 以上版本并且不支持 HHVM 虚拟机。我们深入 autoload_static.php 这个文件发现这个文件定义了一个用于静态初始化的类，名字叫 ComposerStaticInit7b790917ce8899df9af8ed53631a1c29，仍然为了避免冲突而加了 hash 值。这个类很简单： 12345678910111213141516171819202122232425&lt;?php class ComposerStaticInit7b790917ce8899df9af8ed53631a1c29&#123; public static $files = array(...); public static $prefixLengthsPsr4 = array(...); public static $prefixDirsPsr4 = array(...); public static $prefixesPsr0 = array(...); public static $classMap = array (...); public static function getInitializer(ClassLoader $loader) &#123; return \\Closure::bind(function () use ($loader) &#123; $loader-&gt;prefixLengthsPsr4 = ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$prefixLengthsPsr4; $loader-&gt;prefixDirsPsr4 = ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$prefixDirsPsr4; $loader-&gt;prefixesPsr0 = ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$prefixesPsr0; $loader-&gt;classMap = ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$classMap; &#125;, null, ClassLoader::class); &#125; 这个静态初始化类的核心就是 getInitializer() 函数，它将自己类中的顶级命名空间映射给了 ClassLoader 类。值得注意的是这个函数返回的是一个匿名函数，为什么呢？原因就是 ClassLoader类 中的 prefixLengthsPsr4 、prefixDirsPsr4等等变量都是 private的。利用匿名函数的绑定功能就可以将这些 private 变量赋给 ClassLoader 类 里的成员变量。 关于匿名函数的绑定功能。 接下来就是命名空间初始化的关键了。 classMap（命名空间映射）1234567891011121314151617&lt;?php public static $classMap = array ( 'App\\\\Console\\\\Kernel' =&gt; __DIR__ . '/../..' . '/app/Console/Kernel.php', 'App\\\\Exceptions\\\\Handler' =&gt; __DIR__ . '/../..' . '/app/Exceptions/Handler.php', 'App\\\\Http\\\\Controllers\\\\Auth\\\\ForgotPasswordController' =&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/ForgotPasswordController.php', 'App\\\\Http\\\\Controllers\\\\Auth\\\\LoginController' =&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/LoginController.php', 'App\\\\Http\\\\Controllers\\\\Auth\\\\RegisterController' =&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/RegisterController.php', ...) 直接命名空间全名与目录的映射，简单粗暴，也导致这个数组相当的大。 PSR4 标准顶级命名空间映射数组：1234567891011121314151617181920212223242526&lt;?php public static $prefixLengthsPsr4 = array( 'p' =&gt; array ( 'phpDocumentor\\\\Reflection\\\\' =&gt; 25, ), 'S' =&gt; array ( 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; 26, 'Symfony\\\\Component\\\\Yaml\\\\' =&gt; 23, 'Symfony\\\\Component\\\\VarDumper\\\\' =&gt; 28, ... ), ...); public static $prefixDirsPsr4 = array ( 'phpDocumentor\\\\Reflection\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-common/src', 1 =&gt; __DIR__ . '/..' . '/phpdocumentor/type-resolver/src', 2 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src', ), 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring', ), 'Symfony\\\\Component\\\\Yaml\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/symfony/yaml', ), ...) PSR4 标准顶级命名空间映射用了两个数组，第一个是用命名空间第一个字母作为前缀索引，然后是 顶级命名空间，但是最终并不是文件路径，而是 顶级命名空间的长度。为什么呢？ 因为 PSR4 标准是用顶级命名空间目录替换顶级命名空间，所以获得顶级命名空间的长度很重要。 具体说明这些数组的作用： 假如我们找 Symfony\\Polyfill\\Mbstring\\example 这个命名空间，通过前缀索引和字符串匹配我们得到了 12&lt;?php 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; 26, 这条记录，键是顶级命名空间，值是命名空间的长度。拿到顶级命名空间后去 $prefixDirsPsr4数组 获取它的映射目录数组：(注意映射目录可能不止一条) 1234&lt;?php 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring', ) 然后我们就可以将命名空间 Symfony\\\\Polyfill\\\\Mbstring\\\\example 前26个字符替换成目录 __DIR__ . &#39;/..&#39; . &#39;/symfony/polyfill-mbstring ，我们就得到了__DIR__ . &#39;/..&#39; . &#39;/symfony/polyfill-mbstring/example.php，先验证磁盘上这个文件是否存在，如果不存在接着遍历。如果遍历后没有找到，则加载失败。 ClassLoader 接口初始化（ PHP &lt; 5.6 ） 如果PHP版本低于 5.6 或者使用 HHVM 虚拟机环境，那么就要使用核心类的接口进行初始化。 1234567891011121314151617&lt;?php // PSR0 标准 $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; // PSR4 标准 $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; PSR4 标准的映射autoload_psr4.php 的顶级命名空间映射 123456789101112131415161718&lt;?php return array( 'XdgBaseDir\\\\' =&gt; array($vendorDir . '/dnoegel/php-xdg-base-dir/src'), 'Webmozart\\\\Assert\\\\' =&gt; array($vendorDir . '/webmozart/assert/src'), 'TijsVerkoyen\\\\CssToInlineStyles\\\\' =&gt; array($vendorDir . '/tijsverkoyen/css-to-inline-styles/src'), 'Tests\\\\' =&gt; array($baseDir . '/tests'), 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; array($vendorDir . '/symfony/polyfill-mbstring'), ... ) PSR4 标准的初始化接口: 12345678910111213141516&lt;?php public function setPsr4($prefix, $paths) &#123; if (!$prefix) &#123; $this-&gt;fallbackDirsPsr4 = (array) $paths; &#125; else &#123; $length = strlen($prefix); if ('\\\\' !== $prefix[$length - 1]) &#123; throw new \\InvalidArgumentException( \"A non-empty PSR-4 prefix must end with a namespace separator.\" ); &#125; $this-&gt;prefixLengthsPsr4[$prefix[0]][$prefix] = $length; $this-&gt;prefixDirsPsr4[$prefix] = (array) $paths; &#125; &#125; PSR4初始化接口也很简单。如果没有顶级命名空间，就直接保存目录。如果有命名空间的话，要保证顶级命名空间最后是 \\ ，然后分别保存。 总结下上面的顶级命名空间映射过程： ( 前缀 -&gt; 顶级命名空间，顶级命名空间 -&gt; 顶级命名空间长度 ) ( 顶级命名空间 -&gt; 目录 ) 这两个映射数组。具体形式也可以查看下面的 autoload_static 的 prefixLengthsPsr4 、 $prefixDirsPsr4 。 命名空间映射autoload_classmap： 123456789&lt;?phppublic static $classMap = array ( 'App\\\\Console\\\\Kernel' =&gt; __DIR__ . '/../..' . '/app/Console/Kernel.php', 'App\\\\Exceptions\\\\Handler' =&gt; __DIR__ . '/../..' . '/app/Exceptions/Handler.php', ...) addClassMap: 123456789&lt;?php public function addClassMap(array $classMap) &#123; if ($this-&gt;classMap) &#123; $this-&gt;classMap = array_merge($this-&gt;classMap, $classMap); &#125; else &#123; $this-&gt;classMap = $classMap; &#125; &#125; 自动加载核心类 ClassLoader 的静态初始化到这里就完成了！ 其实说是5部分，真正重要的就两部分——初始化与注册。初始化负责顶层命名空间的目录映射，注册负责实现顶层以下的命名空间映射规则。 第四部分 —— 注册 讲完了 Composer 自动加载功能的启动与初始化，经过启动与初始化，自动加载核心类对象已经获得了顶级命名空间与相应目录的映射，也就是说，如果有命名空间 ‘App\\Console\\Kernel，我们已经可以找到它对应的类文件所在位置。那么，它是什么时候被触发去找的呢？ 这就是 composer 自动加载的核心了，我们先回顾一下自动加载引导类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 public static function getLoader() &#123; /***************************经典单例模式********************/ if (null !== self::$loader) &#123; return self::$loader; &#125; /***********************获得自动加载核心类对象********************/ spl_autoload_register(array('ComposerAutoloaderInit 7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader'), true, true); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInit 7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader')); /***********************初始化自动加载核心类对象********************/ $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION'); if ($useStaticLoader) &#123; require_once __DIR__ . '/autoload_static.php'; call_user_func(\\Composer\\Autoload\\ComposerStaticInit 7b790917ce8899df9af8ed53631a1c29::getInitializer($loader)); &#125; else &#123; $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; /***********************注册自动加载核心类对象********************/ $loader-&gt;register(true); /***********************自动加载全局函数********************/ if ($useStaticLoader) &#123; $includeFiles = Composer\\Autoload\\ComposerStaticInit 7b790917ce8899df9af8ed53631a1c29::$files; &#125; else &#123; $includeFiles = require __DIR__ . '/autoload_files.php'; &#125; foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire 7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file); &#125; return $loader;&#125; 现在我们开始引导类的第四部分：注册自动加载核心类对象。我们来看看核心类的 register() 函数： 1234public function register($prepend = false)&#123; spl_autoload_register(array($this, 'loadClass'), true, $prepend);&#125; 一行代码实现自动加载！ 其实奥秘都在自动加载核心类 ClassLoader 的 loadClass() 函数上： 12345678public function loadClass($class) &#123; if ($file = $this-&gt;findFile($class)) &#123; includeFile($file); return true; &#125; &#125; 这个函数负责按照 PSR 标准将顶层命名空间以下的内容转为对应的目录，也就是上面所说的将 ‘App\\Console\\Kernel 中’ Console\\Kernel 这一段转为目录，至于怎么转的在下面 “运行”的部分讲。核心类 ClassLoader 将 loadClass() 函数注册到PHP SPL中的 spl_autoload_register() 里面去。这样，每当PHP遇到一个不认识的命名空间的时候，PHP会自动调用注册到 spl_autoload_register 里面的 loadClass() 函数，然后找到命名空间对应的文件。 全局函数的自动加载 Composer 不止可以自动加载命名空间，还可以加载全局函数。怎么实现的呢？把全局函数写到特定的文件里面去，在程序运行前挨个 require就行了。这个就是 composer 自动加载的第五步，加载全局函数。 12345678if ($useStaticLoader) &#123; $includeFiles = Composer\\Autoload\\ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$files;&#125; else &#123; $includeFiles = require __DIR__ . '/autoload_files.php';&#125;foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file);&#125; 跟核心类的初始化一样，全局函数自动加载也分为两种：静态初始化和普通初始化，静态加载只支持PHP5.6以上并且不支持HHVM。 静态初始化： ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$files： 12345public static $files = array ('0e6d7bf4a5811bfa5cf40c5ccd6fae6a' =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring/bootstrap.php','667aeda72477189d0494fecd327c3641' =&gt; __DIR__ . '/..' . '/symfony/var-dumper/Resources/functions/dump.php',...); 普通初始化autoload_files: 12345678$vendorDir = dirname(dirname(__FILE__));$baseDir = dirname($vendorDir); return array('0e6d7bf4a5811bfa5cf40c5ccd6fae6a' =&gt; $vendorDir . '/symfony/polyfill-mbstring/bootstrap.php','667aeda72477189d0494fecd327c3641' =&gt; $vendorDir . '/symfony/var-dumper/Resources/functions/dump.php', ....); 其实跟静态初始化区别不大。 加载全局函数123456789101112131415161718class ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29&#123; public static function getLoader()&#123; ... foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file); &#125; ... &#125;&#125;function composerRequire7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file) &#123; if (empty(\\$GLOBALS['__composer_autoload_files'][\\$fileIdentifier])) &#123; require $file; $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true; &#125;&#125; 第五部分 —— 运行到这里，终于来到了核心的核心—— composer 自动加载的真相，命名空间如何通过 composer 转为对应目录文件的奥秘就在这一章。前面说过，ClassLoader 的 register() 函数将 loadClass() 函数注册到 PHP 的 SPL 函数堆栈中，每当 PHP 遇到不认识的命名空间时就会调用函数堆栈的每个函数，直到加载命名空间成功。所以 loadClass() 函数就是自动加载的关键了。 看下 loadClass() 函数: 1234567891011121314151617181920212223242526272829303132333435363738public function loadClass($class)&#123; if ($file = $this-&gt;findFile($class)) &#123; includeFile($file); return true; &#125;&#125;public function findFile($class)&#123; // work around for PHP 5.3.0 - 5.3.2 https://bugs.php.net/50731 if ('\\\\' == $class[0]) &#123; $class = substr($class, 1); &#125; // class map lookup if (isset($this-&gt;classMap[$class])) &#123; return $this-&gt;classMap[$class]; &#125; if ($this-&gt;classMapAuthoritative) &#123; return false; &#125; $file = $this-&gt;findFileWithExtension($class, '.php'); // Search for Hack files if we are running on HHVM if ($file === null &amp;&amp; defined('HHVM_VERSION')) &#123; $file = $this-&gt;findFileWithExtension($class, '.hh'); &#125; if ($file === null) &#123; // Remember that this class does not exist. return $this-&gt;classMap[$class] = false; &#125; return $file;&#125; 我们看到 loadClass() ，主要调用 findFile() 函数。findFile() 在解析命名空间的时候主要分为两部分：classMap 和 findFileWithExtension() 函数。classMap 很简单，直接看命名空间是否在映射数组中即可。麻烦的是 findFileWithExtension() 函数，这个函数包含了 PSR0 和 PSR4 标准的实现。还有个值得我们注意的是查找路径成功后 includeFile() 仍然是外面的函数，并不是 ClassLoader 的成员函数，原理跟上面一样，防止有用户写 $this 或 self。还有就是如果命名空间是以\\开头的，要去掉\\然后再匹配。 看下 findFileWithExtension 函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private function findFileWithExtension($class, $ext)&#123; // PSR-4 lookup $logicalPathPsr4 = strtr($class, '\\\\', DIRECTORY_SEPARATOR) . $ext; $first = $class[0]; if (isset($this-&gt;prefixLengthsPsr4[$first])) &#123; foreach ($this-&gt;prefixLengthsPsr4[$first] as $prefix =&gt; $length) &#123; if (0 === strpos($class, $prefix)) &#123; foreach ($this-&gt;prefixDirsPsr4[$prefix] as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) &#123; return $file; &#125; &#125; &#125; &#125; &#125; // PSR-4 fallback dirs foreach ($this-&gt;fallbackDirsPsr4 as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) &#123; return $file; &#125; &#125; // PSR-0 lookup if (false !== $pos = strrpos($class, '\\\\')) &#123; // namespaced class name $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1) . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR); &#125; else &#123; // PEAR-like class name $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext; &#125; if (isset($this-&gt;prefixesPsr0[$first])) &#123; foreach ($this-&gt;prefixesPsr0[$first] as $prefix =&gt; $dirs) &#123; if (0 === strpos($class, $prefix)) &#123; foreach ($dirs as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123; return $file; &#125; &#125; &#125; &#125; &#125; // PSR-0 fallback dirs foreach ($this-&gt;fallbackDirsPsr0 as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123; return $file; &#125; &#125; // PSR-0 include paths. if ($this-&gt;useIncludePath &amp;&amp; $file = stream_resolve_include_path($logicalPathPsr0)) &#123; return $file; &#125;&#125; 最后小结我们通过举例来说下上面代码的流程： 如果我们在代码中写下 new phpDocumentor\\Reflection\\Element()，PHP 会通过 SPL_autoload_register 调用 loadClass -&gt; findFile -&gt; findFileWithExtension。步骤如下： 将 \\ 转为文件分隔符/，加上后缀php，变成 $logicalPathPsr4, 即 phpDocumentor/Reflection//Element.php; 利用命名空间第一个字母p作为前缀索引搜索 prefixLengthsPsr4 数组，查到下面这个数组： 12345p' =&gt; array ( 'phpDocumentor\\\\Reflection\\\\' =&gt; 25, 'phpDocumentor\\\\Fake\\\\' =&gt; 19, ) 遍历这个数组，得到两个顶层命名空间 phpDocumentor\\Reflection\\ 和 phpDocumentor\\Fake\\ 在这个数组中查找 phpDocumentor\\Reflection\\Element，找出 phpDocumentor\\Reflection\\ 这个顶层命名空间并且长度为25。 在prefixDirsPsr4 映射数组中得到phpDocumentor\\Reflection\\ 的目录映射为： 123456'phpDocumentor\\\\Reflection\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-common/src', 1 =&gt; __DIR__ . '/..' . '/phpdocumentor/type-resolver/src', 2 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src', ), 遍历这个映射数组，得到三个目录映射； 查看 “目录+文件分隔符//+substr(\\$logicalPathPsr4, \\$length)”文件是否存在，存在即返回。这里就是&#39;__DIR__/../phpdocumentor/reflection-common/src + substr(phpDocumentor/Reflection/Element.php,25)&#39; 如果失败，则利用 fallbackDirsPsr4 数组里面的目录继续判断是否存在文件 The end. Thanks!","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"composer","slug":"composer","permalink":"http://www.tenpercent.top/tags/composer/"}]},{"title":"PHP-FPM 与 Nginx 的通信机制总结","date":"2018-02-07T16:00:00.000Z","path":"2018/02/08/php-fpm and nginx /","text":"PHP-FPM 介绍CGI 协议与 FastCGI 协议每种动态语言（ PHP,Python 等）的代码文件需要通过对应的解析器才能被服务器识别，而 CGI 协议就是用来使解释器与服务器可以互相通信。PHP 文件在服务器上的解析需要用到 PHP 解释器，再加上对应的 CGI 协议，从而使服务器可以解析到 PHP 文件。 由于 CGI 的机制是每处理一个请求需要 fork 一个 CGI 进程，请求结束再kill掉这个进程，在实际应用上比较浪费资源，于是就出现了CGI 的改良版本 FastCGI，FastCGI 在请求处理完后，不会 kill 掉进程，而是继续处理多个请求，这样就大大提高了效率。 PHP-FPM 是什么PHP-FPM 即 PHP-FastCGI Process Manager， 它是 FastCGI 的实现，并提供了进程管理的功能。进程包含 master 进程和 worker 进程两种；master 进程只有一个，负责监听端口，接收来自服务器的请求，而 worker 进程则一般有多个（具体数量根据实际需要进行配置），每个进程内部都会嵌入一个 PHP 解释器，是代码真正执行的地方。 Nginx 与 php-fpm 通信机制当我们访问一个网站（如 www.test.com）的时候，处理流程是这样的： 12345678910111213141516171819 www.test.com | | Nginx | |路由到 www.test.com/index.php | |加载 nginx 的 fast-cgi 模块 | |fast-cgi 监听 127.0.0.1:9000 地址 | |www.test.com/index.php 请求到达 127.0.0.1:9000 | | 等待处理... Nginx 与 php-fpm 的结合在 Linux 上，nginx 与 php-fpm 的通信有 tcp socket 和 unix socket 两种方式。 tcp socket 的优点是可以跨服务器，当 nginx 和 php-fpm 不在同一台机器上时，只能使用这种方式。 Unix socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信，这种方式需要在 nginx配置文件中填写 php-fpm 的 socket 文件位置。 两种方式的数据传输过程如下图所示： 二者的不同： 由于 Unix socket 不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。所以其效率比 tcp socket 的方式要高，可减少不必要的 tcp 开销。不过，unix socket 高并发时不稳定，连接数爆发时，会产生大量的长时缓存，在没有面向连接协议的支撑下，大数据包可能会直接出错不返回异常。而 tcp 这样的面向连接的协议，可以更好的保证通信的正确性和完整性。 Nginx 与 php-fpm 结合只需要在各自的配置文件中做设置即可： 1） Nginx 中的配置 以 tcp socket通信为例 12345678910111213141516171819server &#123; listen 80; #监听 80 端口，接收http请求 server_name www.test.com; #就是网站地址 root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径 #路由到网站根目录 www.test.com 时候的处理 location / &#123; index index.php; #跳转到 www.test.com/index.php autoindex on; &#125; #当请求网站下 php 文件的时候，反向代理到 php-fpm location ~ \\.php$ &#123; include /usr/local/etc/nginx/fastcgi.conf; #加载 nginx 的 fastcgi 模块 fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; # tcp 方式，php-fpm 监听的 IP 地址和端口 # fasrcgi_pass /usr/run/php-fpm.sock # unix socket 连接方式 &#125;&#125; 2) php-fpm 的配置 123listen = 127.0.0.1:9000# 或者下面这样listen = /var/run/php-fpm.sock 注意，在使用 unix socket 方式连接时，由于 socket 文件本质上是一个文件，存在权限控制的问题，所以需要注意 nginx 进程的权限与 php-fpm 的权限问题，不然会提示无权限访问。（在各自的配置文件里设置用户） 通过以上配置即可完成 php-fpm 与 nginx 的通信。 在应用中的选择如果是在同一台服务器上运行的 nginx 和 php-fpm，且并发量不高（不超过1000），选择unix socket，以提高 nginx 和 php-fpm 的通信效率。如果是面临高并发业务，则考虑选择使用更可靠的 tcp socket，以负载均衡、内核优化等运维手段维持效率。 若并发较高但仍想用 unix socket 时，可通过以下方式提高 unix socket 的稳定性。 1）将sock文件放在 /dev/shm 目录下，此目录下将 sock 文件放在内存里面，内存的读写更快。 2）提高 backlog backlog 默认位 128，1024 这个值最好换算成自己正常的 QPS，配置如下。 nginx.conf 文件中 123server &#123; listen 80 default backlog = 1024; &#125; php-fpm.conf 文件中 1listen.backlog = 1024 3）增加 sock 文件和 php-fpm 实例 在 /dev/shm 新建一个 sock 文件，在 nginx 中通过 upstream 模块将请求负载均衡到两个 sock 文件，并且将两个 sock 文件分别对应到两套 php-fpm 实例上。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"Nginx","slug":"Nginx","permalink":"http://www.tenpercent.top/tags/Nginx/"},{"name":"PHP-FPM","slug":"PHP-FPM","permalink":"http://www.tenpercent.top/tags/PHP-FPM/"}]},{"title":"对PHP 后期静态绑定的理解","date":"2018-01-15T16:00:00.000Z","path":"2018/01/16/late-static-bindings/","text":"什么是后期静态绑定在看一些框架源码或者是某个项目的代码时，经常能看到后期静态绑定的用法。比如下面这段： 1234567public static function getInstance()&#123; if (is_null(static::$instance)) &#123; static::$instance = new static; &#125; return static::$instance;&#125; 这里用到的就是后期静态绑定。那么，什么是后期静态绑定？ “后期绑定”的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。 这里要先说两个概念，一个是转发调用，另一个是非转发调用。 转发调用所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：self::, parent::, static:: 以及 forward_ static _call()。即在进行静态调用时未指名类名的调用属于转发调用。 非转发调用非转发调用其实就是明确指定类名的静态调用（foo::bar()）和非静态调用($foo-&gt;bar())。即明确地指定类名的静态调用和非静态调用。 顾名思义，非转发调用前面有类名所以调用的函数一定是属于“这个类的”，不需要转到别的类。转发调用就是由于前期的静态绑定导致在后面调用静态方法时可能“转发到其他的类” 在PHP的官方文档里，对于后期静态绑定是这样说的：后期静态绑定工作原理是存储了在上一个“非转发调用”（non-forwarding call）中的类名。意思是当我们调用一个转发调用的静态调用时，实际调用的类是上一个非转发调用的类。 来看两个例子： 例1： 1234567891011121314class A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; static::who(); // 后期静态绑定从这里开始 &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test(); 以上代码会输出 1B 例2： 12345678910111213141516171819202122232425262728class A &#123; public static function foo() &#123; static::who(); &#125; public static function who() &#123; echo __CLASS__.\"\\n\"; &#125;&#125;class B extends A &#123; public static function test() &#123; A::foo(); parent::foo(); self::foo(); &#125; public static function who() &#123; echo __CLASS__.\"\\n\"; &#125;&#125;class C extends B &#123; public static function who() &#123; echo __CLASS__.\"\\n\"; &#125;&#125;C::test(); 以上代码会输出 123ACC 在这里主要分析下例2。 1.C::test()，这是一个非转发调用，因为::前面有类名C。 2.进入test()方法，有三个静态调用 A::foo(),parent::foo(),self::foo(),对于这三个静态调用来说，他们的非转发调用类就是 C。 3.现在执行A::foo(),这是一个非转发调用。A::foo()中的代码是 static::who(),这是一个转发调用，对于这个转发调用来说他的非转发调用类就是不再是C而是A（因为之前执行了A::foo()）。因此执行的结果为A 4.现在执行 parent::foo(),这是一个转发调用，转发到哪里呢？就是它的上一个非转发调用的类，也就是类C（在步骤2中提到的）。在这里一定要注意虽然在这之前执行了 A::foo(),但是 parent::foo()的上一个非转发调用的类任然是类C。因此执行的结果是 C. 5.现在执行 self::foo(),这个和 parent::foo()一样都是转发调用，因此也输出 C。 使用后期静态绑定的好处后期静态绑定目前我看到较多的是用于对象实例化中，在实例化对象时，static 会根据运行时调用的类来决定实例化对象，而 self 则是根据所在位置的类来决定实例化对象。当我们只想实例化子类，并且不希望后续在对子类的使用中由于父类的变化对子类产生影响时，后期静态绑定就能发挥它的作用了。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"PHP代码简洁之道——SOLID原则","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/clean-code-solid/","text":"SOLID 是Michael Feathers推荐的便于记忆的首字母简写，它代表了Robert Martin命名的最重要的五个面对对象编码设计原则 S: 单一职责原则 (SRP) O: 开闭原则 (OCP) L: 里氏替换原则 (LSP) I: 接口隔离原则 (ISP) D: 依赖反转原则 (DIP) 单一职责原则 Single Responsibility Principle (SRP)“修改一个类应该只为一个理由”。人们总是易于用一堆方法塞满一个类，如同我们在飞机上只能携带一个行李箱（把所有的东西都塞到箱子里）。这样做的问题是：从概念上这样的类不是高内聚的，并且留下了很多理由去修改它。将你需要修改类的次数降低到最小很重要。这是因为，当有很多方法在类中时，修改其中一处，你很难知晓在代码库中哪些依赖的模块会被影响到。 Bad: 123456789101112131415161718192021class UserSettings&#123; private $user; public function __construct($user) &#123; $this-&gt;user = $user; &#125; public function changeSettings($settings) &#123; if ($this-&gt;verifyCredentials()) &#123; // ... &#125; &#125; private function verifyCredentials() &#123; // ... &#125;&#125; Good: 123456789101112131415161718192021222324252627282930313233class UserAuth &#123; private $user; public function __construct($user) &#123; $this-&gt;user = $user; &#125; public function verifyCredentials() &#123; // ... &#125;&#125;class UserSettings &#123; private $user; private $auth; public function __construct($user) &#123; $this-&gt;user = $user; $this-&gt;auth = new UserAuth($user); &#125; public function changeSettings($settings) &#123; if ($this-&gt;auth-&gt;verifyCredentials()) &#123; // ... &#125; &#125;&#125; 开闭原则 Open/Closed Principle (OCP)正如Bertrand Meyer所述，”软件的实体（类, 模块, 函数,等）应该对扩展开放，对修改关闭。”这个原则是在说明应该允许用户在不改变已有代码的情况下增加新的功能。 Bad: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960abstract class Adapter&#123; protected $name; public function getName() &#123; return $this-&gt;name; &#125;&#125;class AjaxAdapter extends Adapter&#123; public function __construct() &#123; parent::__construct(); $this-&gt;name = 'ajaxAdapter'; &#125;&#125;class NodeAdapter extends Adapter&#123; public function __construct() &#123; parent::__construct(); $this-&gt;name = 'nodeAdapter'; &#125;&#125;class HttpRequester&#123; private $adapter; public function __construct($adapter) &#123; $this-&gt;adapter = $adapter; &#125; public function fetch($url) &#123; $adapterName = $this-&gt;adapter-&gt;getName(); if ($adapterName === 'ajaxAdapter') &#123; return $this-&gt;makeAjaxCall($url); &#125; elseif ($adapterName === 'httpNodeAdapter') &#123; return $this-&gt;makeHttpCall($url); &#125; &#125; private function makeAjaxCall($url) &#123; // request and return promise &#125; private function makeHttpCall($url) &#123; // request and return promise &#125;&#125; 在上面的代码中，对于HttpRequester类中的fetch方法，如果我新增了一个新的xxxAdapter类并且要在fetch方法中用到的话，就需要在HttpRequester类中去修改类（如加上一个elseif 判断），而通过下面的代码，就可很好的解决这个问题。下面代码很好的说明了如何在不改变原有代码的情况下增加新功能。 Good: 1234567891011121314151617181920212223242526272829303132333435interface Adapter&#123; public function request($url);&#125;class AjaxAdapter implements Adapter&#123; public function request($url) &#123; // request and return promise &#125;&#125;class NodeAdapter implements Adapter&#123; public function request($url) &#123; // request and return promise &#125;&#125;class HttpRequester&#123; private $adapter; public function __construct(Adapter $adapter) &#123; $this-&gt;adapter = $adapter; &#125; public function fetch($url) &#123; return $this-&gt;adapter-&gt;request($url); &#125;&#125; 里氏替换原则 Liskov Substitution Principle (LSP)对这个概念最好的解释是：如果你有一个父类和一个子类，在不改变原有结果正确性的前提下父类和子类可以互换。这个听起来让人有些迷惑，所以让我们来看一个经典的正方形-长方形的例子。从数学上讲，正方形是一种长方形，但是当你的模型通过继承使用了”is-a”的关系时，就不对了。 Bad: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Rectangle&#123; protected $width = 0; protected $height = 0; public function render($area) &#123; // ... &#125; public function setWidth($width) &#123; $this-&gt;width = $width; &#125; public function setHeight($height) &#123; $this-&gt;height = $height; &#125; public function getArea() &#123; return $this-&gt;width * $this-&gt;height; &#125;&#125;class Square extends Rectangle&#123; public function setWidth($width) &#123; $this-&gt;width = $this-&gt;height = $width; &#125; public function setHeight(height) &#123; $this-&gt;width = $this-&gt;height = $height; &#125;&#125;function renderLargeRectangles($rectangles)&#123; foreach ($rectangles as $rectangle) &#123; $rectangle-&gt;setWidth(4); $rectangle-&gt;setHeight(5); $area = $rectangle-&gt;getArea(); // BAD: Will return 25 for Square. Should be 20. $rectangle-&gt;render($area); &#125;&#125;$rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles($rectangles); Good: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263abstract class Shape&#123; protected $width = 0; protected $height = 0; abstract public function getArea(); public function render($area) &#123; // ... &#125;&#125;class Rectangle extends Shape&#123; public function setWidth($width) &#123; $this-&gt;width = $width; &#125; public function setHeight($height) &#123; $this-&gt;height = $height; &#125; public function getArea() &#123; return $this-&gt;width * $this-&gt;height; &#125;&#125;class Square extends Shape&#123; private $length = 0; public function setLength($length) &#123; $this-&gt;length = $length; &#125; public function getArea() &#123; return pow($this-&gt;length, 2); &#125;&#125;function renderLargeRectangles($rectangles)&#123; foreach ($rectangles as $rectangle) &#123; if ($rectangle instanceof Square) &#123; $rectangle-&gt;setLength(5); &#125; elseif ($rectangle instanceof Rectangle) &#123; $rectangle-&gt;setWidth(4); $rectangle-&gt;setHeight(5); &#125; $area = $rectangle-&gt;getArea(); $rectangle-&gt;render($area); &#125;&#125;$shapes = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles($shapes); 接口隔离原则接口隔离原则：”客户端不应该被强制去实现于它不需要的接口”。 有一个清晰的例子来说明示范这条原则。当一个类需要一个大量的设置项，为了方便不会要求客户端去设置大量的选项，因为在通常他们不需要所有的设置项。使设置项可选有助于我们避免产生”胖接口” Bad: 1234567891011121314151617181920212223242526272829303132interface Employee&#123; public function work(); public function eat();&#125;class Human implements Employee&#123; public function work() &#123; // ....working &#125; public function eat() &#123; // ...... eating in lunch break &#125;&#125;class Robot implements Employee&#123; public function work() &#123; //.... working much more &#125; public function eat() &#123; //.... robot can't eat, but it must implement this method &#125;&#125; 上面的代码中，Robot类并不需要eat()这个方法，但是实现了Emplyee接口，于是只能实现所有的方法了，这使得Robot实现了它并不需要的方法。所以在这里应该对Emplyee接口进行拆分，正确的代码如下： Good: 1234567891011121314151617181920212223242526272829303132333435interface Workable&#123; public function work();&#125;interface Feedable&#123; public function eat();&#125;interface Employee extends Feedable, Workable&#123;&#125;class Human implements Employee&#123; public function work() &#123; // ....working &#125; public function eat() &#123; //.... eating in lunch break &#125;&#125;// robot can only workclass Robot implements Workable&#123; public function work() &#123; // ....working &#125;&#125; 依赖反转原则 Dependency Inversion Principle (DIP)这条原则说明两个基本的要点： 高阶的模块不应该依赖低阶的模块，它们都应该依赖于抽象 抽象不应该依赖于实现，实现应该依赖于抽象 这条起初看起来有点晦涩难懂，但是如果你使用过php框架（例如 Symfony），你应该见过依赖注入（DI）对这个概念的实现。虽然它们不是完全相通的概念，依赖倒置原则使高阶模块与低阶模块的实现细节和创建分离。可以使用依赖注入（DI）这种方式来实现它。更多的好处是它使模块之间解耦。耦合会导致你难于重构，它是一种非常糟糕的的开发模式。 Bad: 123456789101112131415161718192021222324252627282930class Employee&#123; public function work() &#123; // ....working &#125;&#125;class Robot extends Employee&#123; public function work() &#123; //.... working much more &#125;&#125;class Manager&#123; private $employee; public function __construct(Employee $employee) &#123; $this-&gt;employee = $employee; &#125; public function manage() &#123; $this-&gt;employee-&gt;work(); &#125;&#125; Good: 1234567891011121314151617181920212223242526272829303132333435interface Employee&#123; public function work();&#125;class Human implements Employee&#123; public function work() &#123; // ....working &#125;&#125;class Robot implements Employee&#123; public function work() &#123; //.... working much more &#125;&#125;class Manager&#123; private $employee; public function __construct(Employee $employee) &#123; $this-&gt;employee = $employee; &#125; public function manage() &#123; $this-&gt;employee-&gt;work(); &#125;&#125; 别写重复代码 (DRY)这条原则大家应该都是比较熟悉了。 尽你最大的努力去避免复制代码，它是一种非常糟糕的行为，复制代码通常意味着当你需要变更一些逻辑时，你需要修改不止一处。 Bad: 12345678910111213141516171819202122232425262728293031function showDeveloperList($developers)&#123; foreach ($developers as $developer) &#123; $expectedSalary = $developer-&gt;calculateExpectedSalary(); $experience = $developer-&gt;getExperience(); $githubLink = $developer-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125;function showManagerList($managers)&#123; foreach ($managers as $manager) &#123; $expectedSalary = $manager-&gt;calculateExpectedSalary(); $experience = $manager-&gt;getExperience(); $githubLink = $manager-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125; Good: 123456789101112131415function showList($employees)&#123; foreach ($employees as $employee) &#123; $expectedSalary = $employee-&gt;calculateExpectedSalary(); $experience = $employee-&gt;getExperience(); $githubLink = $employee-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125; Very good: 12345678910function showList($employees)&#123; foreach ($employees as $employee) &#123; render([ $employee-&gt;calculateExpectedSalary(), $employee-&gt;getExperience(), $employee-&gt;getGithubLink() ]); &#125;&#125; 后记：虽然OOP设计需要遵守如上原则，不过实际的代码设计一定要简单、简单、简单。在实际编码中要根据情况进行取舍，一味遵守原则，而不注重实际情况的话，可能会让你的代码变的难以理解!","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"PHP代码简洁之道——类和对象部分","date":"2017-12-24T16:00:00.000Z","path":"2017/12/25/clean-code-php-object/","text":"使用getter和setter在 PHP 中，通过为属性或方法设置 public, protected 和 private 关键字可以实现对属性或方法的可见性控制。不过，通过 getter 和 setter 也可以达到控制可见性的目的，并且在某些场景下它具备一些额外的好处。 使用 getter和 setter 有以下好处： 当你除了获取对象之外还想做一些别的事情时，就不用到项目中去查找所有的属性并修改 使添加验证更简单 在获取和设置时添加日志和错误处理更方便 我们可以延迟加载类的属性 继承了类，你可以重写默认的函数 另外，这是面向对象的基本设计原则中的开放/封闭原则。 Bad: 123456789class BankAccount&#123; public $balance = 1000;&#125;$bankAccount = new BankAccount();// 买了一双鞋...$bankAccount-&gt;balance -= 100; Good: 12345678910111213141516171819202122232425262728293031323334353637class BankAccount&#123; private $balance; public function __construct($balance = 1000) &#123; $this-&gt;balance = $balance; &#125; //做一些事情 public function withdrawBalance($amount) &#123; if ($amount &gt; $this-&gt;balance) &#123; throw new \\Exception('Amount greater than available balance.'); &#125; $this-&gt;balance -= $amount; &#125; public function depositBalance($amount) &#123; $this-&gt;balance += $amount; &#125; public function getBalance() &#123; return $this-&gt;balance; &#125;&#125;$bankAccount = new BankAccount();// 买了一双鞋...$bankAccount-&gt;withdrawBalance($shoesPrice);// 获取结余$balance = $bankAccount-&gt;getBalance(); 让对象具有私有或受保护的的成员Bad: 123456789101112class Employee&#123; public $name; public function __construct($name) &#123; $this-&gt;name = $name; &#125;&#125;$employee = new Employee('John Doe');echo 'Employee name: '.$employee-&gt;name; // Employee name: John Doe Good: 1234567891011121314151617class Employee&#123; private $name; public function __construct($name) &#123; $this-&gt;name = $name; &#125; public function getName() &#123; return $this-&gt;name; &#125;&#125;$employee = new Employee('John Doe');echo 'Employee name: '.$employee-&gt;getName(); // Employee name: John Doe 使用组合而不是继承这里不是说不使用继承，使用“组合模式”和使用“继承”都有很多好的理由。 这里想说的是当你本能的要使用继承时就想一想“组合模式”是否能更好帮你的解决问题。 那么，你可能想知道，“什么时候应该用继承？”， 这取决于你手头上问题。 以下几点说明了什么时候使用继承会更合适。 你的继承表达了一个对等（比如”人类是动物”）的关系，不是包含的关系（比如”用户具有用户详情”） 你能从基类中复用代码 你想通过修改全局类来对所有派生类进行修改。 Bad: 123456789101112131415161718192021222324252627282930313233class Employee &#123; private $name; private $email; public function __construct($name, $email) &#123; $this-&gt;name = $name; $this-&gt;email = $email; &#125; // ...&#125;// 因为雇员和税收不是对等关系而是包含的关系// 所以这里应用组合比较合适class EmployeeTaxData extends Employee &#123; private $ssn; private $salary; public function __construct($name, $email, $ssn, $salary) &#123; parent::__construct($name, $email); $this-&gt;ssn = $ssn; $this-&gt;salary = $salary; &#125; // ...&#125; Good: 123456789101112131415161718192021222324252627282930313233class EmployeeTaxData &#123; private $ssn; private $salary; public function __construct($ssn, $salary) &#123; $this-&gt;ssn = $ssn; $this-&gt;salary = $salary; &#125; // ...&#125;class Employee &#123; private $name; private $email; private $taxData; public function __construct($name, $email) &#123; $this-&gt;name = $name; $this-&gt;email = $email; &#125; public function setTaxData($ssn, $salary) &#123; $this-&gt;taxData = new EmployeeTaxData($ssn, $salary); &#125; // ...&#125;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"PHP代码简洁之道——函数部分","date":"2017-12-16T16:00:00.000Z","path":"2017/12/17/clean-code-php-function/","text":"函数参数不要超过两个限制函数的参数数量是非常重要的，因为它使你的函数更容易测试。超过三个参数会导致参数之间的组合过多，你必须对每个单独的参数测试大量不同的情况。 没有参数是最理想的情况，一个或两个参数是可以接受的，三个以上则是应该避免的。这很重要。如果你有两个以上的参数，那么你的函数可能试图做的太多，如果不是，你可能需要将一个高级别的对象传当做参数传进去。 Bad: 12345function createMenu($title, $body, $buttonText, $cancellable)&#123; // ...&#125; Good： 123456789101112131415161718class MenuConfig&#123; public $title; public $body; public $buttonText; public $cancellable = false;&#125;$config = new MenuConfig();$config-&gt;title = 'Foo';$config-&gt;body = 'Bar';$config-&gt;buttonText = 'Baz';$config-&gt;cancellable = true;function createMenu(MenuConfig $config)&#123; // ...&#125; 一个函数只做一件事这是软件工程中一个重要的原则。这会让你的代码清晰易懂以及易于复用。 Bad： 123456789function emailClients($clients)&#123; foreach ($clients as $client) &#123; $clientRecord = $db-&gt;find($client); if ($clientRecord-&gt;isActive()) &#123; email($client); &#125; &#125;&#125; Good: 1234567891011121314151617function emailClients($clients)&#123; $activeClients = activeClients($clients); array_walk($activeClients, 'email');&#125;function activeClients($clients)&#123; return array_filter($clients, 'isClientActive');&#125;function isClientActive($client)&#123; $clientRecord = $db-&gt;find($client); return $clientRecord-&gt;isActive();&#125; 函数名要能说明它是做什么的Bad: 12345678910111213class Email&#123; //... public function handle() &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// 这是什么？一条消息的句柄？还是要写一个文件？（读者的疑问）$message-&gt;handle(); Good: 12345678910111213class Email &#123; //... public function send() &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// 一目了然$message-&gt;send(); 函数应该只做一层抽象当你有多个层次的抽象时，你的函数就已经做的太多了。拆分这些函数，可以让代码可重用性更高且更易测试。Bad: 123456789101112131415161718192021222324function parseBetterJSAlternative($code)&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; // ... &#125; &#125; $ast = []; foreach ($tokens as $token) &#123; // lex... &#125; foreach ($ast as $node) &#123; // parse... &#125;&#125; Bad too:我们从函数中迁出去了一些工作，但是 parseBetterJSAlternative() 函数还是很复杂，不可测试。 1234567891011121314151617181920212223242526272829303132333435function tokenize($code)&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens;&#125;function lexer($tokens)&#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast;&#125;function parseBetterJSAlternative($code)&#123; $tokens = tokenize($code); $ast = lexer($tokens); foreach ($ast as $node) &#123; // parse... &#125;&#125; Good: 最好的解决方案是移除 parseBetterJSAlternative 函数的依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Tokenizer&#123; public function tokenize($code) &#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens; &#125;&#125;class Lexer&#123; public function lexify($tokens) &#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast; &#125;&#125;class BetterJSAlternative&#123; private $tokenizer; private $lexer; public function __construct(Tokenizer $tokenizer, Lexer $lexer) &#123; $this-&gt;tokenizer = $tokenizer; $this-&gt;lexer = $lexer; &#125; public function parse($code) &#123; $tokens = $this-&gt;tokenizer-&gt;tokenize($code); $ast = $this-&gt;lexer-&gt;lexify($tokens); foreach ($ast as $node) &#123; // parse... &#125; &#125;&#125; 不要使用标志作为函数的参数当你在函数中使用标志来作为参数时，你的函数就不是只做一件事情了，这与我们前面所讲的每个函数只做一件事的原则相违背，所以不要使用标志作为函数的参数。 Bad: 12345678function createFile($name, $temp = false)&#123; if ($temp) &#123; touch('./temp/'.$name); &#125; else &#123; touch($name); &#125;&#125; Good: 12345678910function createFile($name)&#123; touch($name);&#125;function createTempFile($name)&#123; touch('./temp/'.$name);&#125; 避免副作用如果一个函数做了“拿到一个值并返回一个值或者多个值”以外的事情，那么这个函数就有可能产生副作用，副作用可能是意外的写入了文件、修改了全局变量、或者打钱给了陌生人。 现在假如你确实要在函数中做一些有可能产生副作用的事情。 比如要写一个文件，你需要做的是将写文件的操作集中到一处，而不是在几个函数或者类里对同一个文件做操作，实现一个服务（函数或者类）去操作它，有且仅有一个。 关键是要能避免常见的陷阱：像是在没有结构的对象之间共享状态、使用可能被写入任何值的可变数据类型、 不集中处理有可能产生副作用的操作。 如果你能做到这些，你会比绝大多数程序员更快乐。 Bad: 1234567891011121314// Global variable referenced by following function.// If we had another function that used this name, now it'd be an array and it could break it.$name = 'Ryan McDermott';function splitIntoFirstAndLastName()&#123; global $name; $name = explode(' ', $name);&#125;splitIntoFirstAndLastName();var_dump($name); // ['Ryan', 'McDermott']; Good: 1234567891011function splitIntoFirstAndLastName($name)&#123; return explode(' ', $name);&#125;$name = 'Ryan McDermott';$newName = splitIntoFirstAndLastName($name);var_dump($name); // 'Ryan McDermott';var_dump($newName); // ['Ryan', 'McDermott']; 不要修改全局变量在许多编程语言中污染全局是一种糟糕的做法，因为你的库可能会与另一个库冲突，但是你的库的用户却一无所知，直到在生产环境中爆发异常。让我们来考虑一个例子：如果你想要拿到配置数组怎么办？你可以编写全局函数，如config()，但是它可能与另一个试图做同样事情的库冲突。 Bad: 123456function config()&#123; return [ 'foo' =&gt; 'bar', ]&#125; Good: 12345678910111213141516171819class Configuration&#123; private $configuration = []; public function __construct(array $configuration) &#123; $this-&gt;configuration = $configuration; &#125; public function get($key) &#123; return isset($this-&gt;configuration[$key]) ? $this-&gt;configuration[$key] : null; &#125;&#125;$configuration = new Configuration([ 'foo' =&gt; 'bar',]); 避免条件判断人们会问“如果不用 if 语句我该怎么做？”，答案是在许多情况下，你可以用多态来实现同样的效果。那这样做什么好处，还是那句话：“一个函数应该只做一件事”， 当你的类或函数中有了 if 语句，你的函数就不止是只做一件事情了。 Bad: 12345678910111213141516class Airplane&#123; // ... public function getCruisingAltitude() &#123; switch ($this-&gt;type) &#123; case '777': return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); case 'Air Force One': return $this-&gt;getMaxAltitude(); case 'Cessna': return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125; &#125;&#125; Good: 123456789101112131415161718192021222324252627282930313233343536interface Airplane&#123; // ... public function getCruisingAltitude();&#125;class Boeing777 implements Airplane&#123; // ... public function getCruisingAltitude() &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); &#125;&#125;class AirForceOne implements Airplane&#123; // ... public function getCruisingAltitude() &#123; return $this-&gt;getMaxAltitude(); &#125;&#125;class Cessna implements Airplane&#123; // ... public function getCruisingAltitude() &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125;&#125;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"PHP代码简洁之道——变量部分","date":"2017-12-07T16:00:00.000Z","path":"2017/12/08/clean-code-php/","text":"将代码写的简洁并且易读易懂是每一位优秀的coder所应该具备的基本功。 前几天在github上看到clean-code-php这个项目，感觉很有收获，于是在这里记录一下。 使用有意义并且可读的变量名称Bad: 1$ymdstr = $moment-&gt;format('y-m-d'); Good: 1$currentDate = $moment-&gt;format('y-m-d'); 对同一只类型的变量使用同样的词汇Bad: 1234getUserInfo();getUserData();getUserRecord();getUserProfile(); Good: 1getUser(); 使用易于查找的命名Bad: 1234// 这里的4是什么鬼??if ($user-&gt;access &amp; 4) &#123; // ...&#125; Good: 1234567891011class User&#123; const ACCESS_READ = 1; const ACCESS_CREATE = 2; const ACCESS_UPDATE = 4; const ACCESS_DELETE = 8;&#125;if ($user-&gt;access &amp; User::ACCESS_UPDATE) &#123; // do edit ...&#125; 不要让读者猜Bad: 123456789101112$l = ['Austin', 'New York', 'San Francisco'];for ($i = 0; $i &lt; count($l); $i++) &#123; $li = $l[$i]; doStuff(); doSomeOtherStuff(); // ... // ... // ... // $li 变量代表什么？？？ dispatch($li);&#125; Good: 12345678910$locations = ['Austin', 'New York', 'San Francisco'];foreach ($locations as $location) &#123; doStuff(); doSomeOtherStuff(); // ... // ... // ... dispatch($location);&#125; 避免过深的嵌套Bad: 123456789101112131415161718192021function isShopOpen($day)&#123; if ($day) &#123; if (is_string($day)) &#123; $day = strtolower($day); if ($day === 'friday') &#123; return true; &#125; elseif ($day === 'saturday') &#123; return true; &#125; elseif ($day === 'sunday') &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125;&#125; Good: 123456789101112function isShopOpen($day)&#123; if (empty($day) &amp;&amp; ! is_string($day)) &#123; return false; &#125; $openingDays = [ 'friday', 'saturday', 'sunday' ]; return in_array(strtolower($day), $openingDays);&#125; Bad: 12345678910111213141516function fibonacci($n)&#123; if ($n &lt; 50) &#123; if ($n !== 0) &#123; if ($n !== 1) &#123; return fibonacci($n - 1) + fibonacci($n - 2); &#125; else &#123; return 1; &#125; &#125; else &#123; return 0; &#125; &#125; else &#123; return 'Not supported'; &#125;&#125; Good: 12345678910111213141516function fibonacci($n)&#123; if ($n === 0) &#123; return 0; &#125; if ($n === 1) &#123; return 1; &#125; if ($n &gt; 50) &#123; return 'Not supported'; &#125; return fibonacci($n - 1) + fibonacci($n - 2);&#125; 不要添加不必要的上下文如果你的类/对象已经说明了一些信息,不要在你的变量名和属性里重复 Bad: 12345678class Car&#123; public $carMake; public $carModel; public $carColor; //...&#125; Good: 12345678class Car&#123; public $make; public $model; public $color; //...&#125; 参数初始化时设置默认值12345function create($name = null)&#123; $newName = $name ?: 'ABC'; // ...&#125; 设置默认值一个比较明显的好处是，当对一个较早之前已经定义好的函数添加参数时,将新增的参数设置默认值可以省得去修改以前使用该函数的地方。 参考链接","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"关于 RESTful API 设计的总结","date":"2017-11-24T16:00:00.000Z","path":"2017/11/25/RESTful/","text":"为什么要用 RESTfulRESTful 给我的最大感觉就是规范、易懂和优雅，一个结构清晰、易于理解的 API 完全可以省去许多无意义的沟通和文档。并且 RESTful 现在越来越流行， 在开始介绍 RESTful API 之前，先介绍一下 RESTful 架构。 RESTful 架构REST，即Representational State Transfer 的缩写。意为 “ 表现层状态转化 “ 。 要理解RESTful架构，最好的方法就是去理解 Representational State Transfer 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果把这个名称搞懂了，也就不难体会 REST 是一种什么样的设计。 资源 （Resources）REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或独一无二的识别符。所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的 URI 。 表现层（Representation）“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、 XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。URI 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的” .html “后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而 URI 应该只代表”资源”的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对”表现层”的描述。 状态转化（State Transfer）访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET 、 POST 、 PUT 、 DELETE 。 它们分别对应四种基本操作： GET 用来获取资源， POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 综述总结一下什么是RESTful架构： 每一个URI代表一种资源； 客户端和服务器之间，传递这种资源的某种表现层； 客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 RESTful API 的设计介绍完 RESTful 的含义，再说说 RESTful API 的设计。 协议如果能全站 HTTPS 当然是最好的，不能的话也请尽量将登录、注册等涉及密码的接口使用 HTTPS。 域名应该尽量将API部署在专用域名之下。如： 1https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 1https://example.org/api/ 版本号API 的版本号和客户端 APP 的版本号是毫无关系的，不要让 APP 将它们用于提交应用市场的版本号传递到服务器，而是提供类似于v1、v2之类的 API 版本号。 版本号拼接在 URL 中。如： 1api.example.com/v1/users 或是放在 Header 中: 123api.xxx.com/usersversion=v1 请求一般来说 API 的外在形式无非就是增删改查（当然具体的业务逻辑肯定要复杂得多），而查询又分为详情和列表两种，在 RESTful 中这就相当于通用的模板。例如针对文章（Article）设计 API，那么最基础的 URL 就是这几种： GET /articles： 文章列表 GET /articles/id：文章详情 POST /articles/： 创建文章 PUT /articles/id：修改文章 DELETE /articles/id：删除文章 Token 和 SignAPI 需要设计成无状态，所以客户端在每次请求时都需要提供有效的 Token 和 Sign，在我看来它们的用途分别是： Token 用于证明请求所属的用户，一般都是服务端在登录后随机生成一段字符串（UUID）和登录用户进行绑定，再将其返回给客户端。Token 的状态保持一般有两种方式实现：一种是在用户每次操作都会延长或重置 TOKEN 的生存时间（类似于缓存的机制），另一种是 Token 的生存时间固定不变，但是同时返回一个刷新用的 Token，当 Token 过期时可以将其刷新而不是重新登录。 Sign 用于证明该次请求合理，所以一般客户端会把请求参数拼接后并加密作为 Sign 传给服务端，这样即使被抓包了，对方只修改参数而无法生成对应的 Sign 也会被服务端识破。当然也可以将时间戳、请求地址和 Token 也混入 Sign，这样 Sign 也拥有了所属人、时效性和目的地。 业务参数在 RESTful 的标准中，PUT 和 PATCH 都可以用于修改操作，它们的区别是 PUT 需要提交整个对象，而 PATCH 只需要提交修改的信息。但是在我看来实际应用中不需要这么麻烦，所以我一律使用 PUT，并且只提交修改的信息。 另一个问题是在 POST 创建对象时，究竟该用表单提交更好些还是用 JSON 提交更好些。其实两者都可以，在我看来它们唯一的区别是 JSON 可以比较方便的表示更为复杂的结构（有嵌套对象）。另外无论使用哪种，请保持统一，不要两者混用。 还有一个建议是最好将过滤、分页和排序的相关信息全权交给客户端，包括过滤条件、页数或是游标、每页的数量、排序方式、升降序等，这样可以使 API 更加灵活。但是对于过滤条件、排序方式等，不需要支持所有方式，只需要支持目前用得上的和以后可能会用上的方式即可，并通过字符串枚举解析，这样可见性要更好些。例如： 搜索，客户端只提供关键词，具体搜索的字段，和搜索方式（前缀、全文、精确）由服务端决定： 1/users/?query=ScienJus 过滤，只需要对已有的情况进行支持： 1/users/?gender=1 分页： 1/users/?page=2&amp;pre_page=20 响应尽量使用 HTTP 状态码，常用的有： 200：请求成功 201：创建、修改成功 204：删除成功 400：参数错误 401：未登录 403：禁止访问 404：未找到 500：系统错误 但是有些时候仅仅使用 HTTP 状态码没有办法明确的表达错误信息，所以也可以在里面再包一层自定义的返回码，例如： 成功时： 12345&#123; &quot;code&quot;: 100, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: &#123;&#125;&#125; 1234&#123; &quot;code&quot;: -1000, &quot;msg&quot;: &quot;用户名或密码错误&quot;&#125; data是真正需要返回的数据，并且只会在请求成功时才存在，msg只用在开发环境，并且只为了开发人员识别。客户端逻辑只允许识别code，并且不允许直接将msg的内容展示给用户。如果这个错误很复杂，无法使用一段话描述清楚，也可以在添加一个doc字段，包含指向该错误的文档的链接。 返回数据JSON 比 XML 可视化更好，也更加节约流量，所以尽量不要使用 XML。 创建和修改操作成功后，需要返回该资源的全部信息。 返回数据不要和客户端界面强耦合，不要在设计 API 时就考虑少查询一张关联表或是少查询 / 返回几个字段能带来多大的性能提升。并且一定要以资源为单位，即使客户端一个页面需要展示多个资源，也不要在一个接口中全部返回，而是让客户端分别请求多个接口。 最好将返回数据进行加密和压缩，尤其是压缩在移动应用中还是比较重要的。","tags":[{"name":"API","slug":"API","permalink":"http://www.tenpercent.top/tags/API/"},{"name":"RESTful","slug":"RESTful","permalink":"http://www.tenpercent.top/tags/RESTful/"}]},{"title":"观察者模式的总结","date":"2017-11-17T16:00:00.000Z","path":"2017/11/18/observer-pattern/","text":"什么是观察者模式观察者模式用于实现对对象进行观察：一旦主体对象状态发生改变，与之关联的观察者对象会收到通知，并进行相应操作。 举个例子说明：假设一个这样的情景，当公司有一个新员工入职了，入职的当天，HR需要为他办理入职手续，网管需要给他配好电脑和办公用品，部门主管需要带他熟悉部门。传统的编程方式，就是在员工入职这个事件发生的代码之后直接加入处理逻辑,当后续我们需要增加处理逻辑时（比如员工入职后增加培训），代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要改变事件主题的代码。运用观察者模式，将员工的入职作为事件，其他的处理逻辑都做为观察者的操作，那么，当以后需要再增加更多的逻辑时，新增逻辑代码就会很方便。具体代码实现如下。 代码实现首先定义一个观察者接口，所有的观察者都实现这个接口（为什么要定义成接口呢？因为每一个观察者的具体行为需要具体去实现，用接口定义一个统一的方法，具体的实现交给观察者去实现） 1234interface observer&#123; public function update();&#125; 再定义一个事件生成器的抽象类，用来使继承它的事件都具有通知观察者的能力。 1234567891011121314151617181920abstract class EventGenerator&#123; private $observers = []; //定义一个添加观察者的方法 public function addOberver(Observer $observer) &#123; $this-&gt;observers[] = $observer; &#125; //定义一个通知观察者的方法 public function notify() &#123; foreach($this-&gt;observers as $observer) &#123; $observer-&gt;update(); &#125; &#125;&#125; 然后再来定义事件类 1234567891011class event extends EventGenerator&#123; //定义一个触发观察者的方法 public funtion trigger() &#123; echo \"Event &lt;br/&gt;\"; //开始通知观察者 $this-&gt;notify(); &#125; &#125; 开始使用 12$event = new event();$event-&gt;trigger(); 这个时候，当我们要在事件发生的时候增加别的操作，只需要新增观察者就可以了 新增一个观察者 12345678class Observer1 implements Observer&#123; public function update() &#123; echo \"操作1&lt;br/&gt;\"; &#125; &#125; 然后使用的时候就是 1234$event = new event();// 增加观察者$event-&gt;addObserver(new Observer1);$event-&gt;trigger(); 如果需要在事件发生后再增加操作，只需再新增相应的观察者即可。 应用观察者模式的好处观察者模式解除了主体和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。降低对象之间的耦合度以达到解耦的目的，符合”开闭原则”的要求。 利用 SPL 实现观察者模式PHP 通过内置的 SPL 扩展提供了对观察者模式的原生支持，其中的观察者由 3 个元素组成 ： SplObserver 接口、 SplSubject 接口和 SplObjectStorage 工具类。下面是利用 SPL 实现观察者模式的代码。SPL 的地址见这里。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class MyObserver1 implements SplObserver &#123; public function update(SplSubject $subject) &#123; echo __CLASS__ . ' - ' . $subject-&gt;getName(); &#125;&#125;class MyObserver2 implements SplObserver &#123; public function update(SplSubject $subject) &#123; echo __CLASS__ . ' - ' . $subject-&gt;getName(); &#125;&#125;class MySubject implements SplSubject &#123; private $observers; private $name; public function __construct($name) &#123; $this-&gt;observers = new SplObjectStorage(); $this-&gt;name = $name; &#125; public function attach(SplObserver $observer) &#123; $this-&gt;observers-&gt;attach($observer); &#125; public function detach(SplObserver $observer) &#123; $this-&gt;observers-&gt;detach($observer); &#125; public function notify() &#123; foreach ($this-&gt;observers as $observer) &#123; $observer-&gt;update($this); &#125; &#125; public function getName() &#123; return $this-&gt;name; &#125;&#125;$observer1 = new MyObserver1();$observer2 = new MyObserver2();$subject = new MySubject(\"test\");$subject-&gt;attach($observer1);$subject-&gt;attach($observer2);$subject-&gt;notify();/* 输出:MyObserver1 - testMyObserver2 - test*/$subject-&gt;detach($observer2);$subject-&gt;notify();/* 输出:MyObserver1 - test*/","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"通俗易懂的谈谈装饰器模式","date":"2017-09-16T16:00:00.000Z","path":"2017/09/17/Decorator-Pattern/","text":"前言在编码的时候，我们为了扩展一个类经常是使用继承方式来实现，随着扩展功能的增多，子类会越来越膨胀，使系统变得不灵活。 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。它能让我们在扩展类的时候让系统较好的保持灵活性。 那么装饰器模式具体是什么样的呢？ 从一个情景开始我们有一块地，在这块地上，我们要盖一栋有好几间房间的别墅，每间房间的装修费用都不同，现在，我们要对盖别墅的费用进行计算。 先定义一个Land类，表示这块地，Land类定义了在这块地上盖别墅需要花钱这个规则。 1234abstract class Land&#123; abstract function cost();&#125; Land已经定义好了在这块地上盖房需要花钱的这个规则了，但是盖一间房间具体花多少钱呢？此时我们再定义一个Room类，这个类具体的定义了一个房间建造的基本费用（一个最简单房间，里面啥也没有的）。 12345678class Room extends Land&#123; private $money = 1000; public function cost() &#123; return $this-&gt;money; &#125;&#125; 然后开始建造房间，我们建了两个房间，分别是客厅和餐厅，用LivingRoom类和DiningRoom类来表示 12345678910111213141516class LivingRoom extends Room&#123; public function cost() &#123; return parent::cost()+200; //客厅的建造费用在房屋建造费用的基础上多200，比如要买沙发，电视 &#125; &#125;class DiningRoom extends Room&#123; public function cost() &#123; return parent::cost()+100; //餐厅的建造费用在房屋建造费用的基础上多100，比如买餐桌 &#125;&#125; 现在，我们很容易就能得到建造一间客厅所需的花费 12$livingRoomCost = new LivingRoom();echo $livingRoomCost-&gt;cost(); 问题的产生不过，这样的结构并不具备灵活性，虽然我们可以很容易的分别得出建造一间客厅和建造一间餐厅的费用，但是，如果我买的地比较小，只能把餐厅和客厅建在同一个房间里，那要怎么去计算费用？难道还要很麻烦的去创建一个包含客厅和餐厅的LivingDiningRoom类？这样做的话除了麻烦，还会使代码产生重复。 解决问题为了更好的解决这个问题，我们得做一些调整，同样先声明Land类和Room类，不同的是，引入了一个房间的装饰类RoomDecorator，它继承了Land类，因为没有实现Land类的cost()方法，所以需将它声明为抽象类，并且定义了一个以Land类的对象为参数的构造方法，传入的对象会保存在$land属性中，该属性声明为protected，以便子类访问。具体如下。 12345678abstract class RoomDecorator extends Land&#123; protected $land; public function __construct(Land $land) &#123; $this-&gt;land = $land; &#125;&#125; 然后我们再重新定义客厅类和餐厅类 12345678910111213141516class LivingRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+200; &#125;&#125;class DiningRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+100; &#125;&#125; 这两个类都扩展自RoomDecorator类，这意味着它们都拥有指向Land对象的引用。当它们的cost()方法被调用时，都会先调用所引用的Land类对象的cost()方法，然后再执行自己特有的操作。 所以这时候，建造一间客厅所需的费用是这样计算 12$livingRoomCost = new LivingRoom(new Room());echo $livingRoomCost-&gt;cost(); //输出1200 建造一间餐厅所需的费用是这样计算 12$diningRoomCost = new DiningRoom(new Room());echo $diningRoomCost-&gt;cost(); //输出1100 回到刚才的问题，如果我们需计算建造一间包含客厅餐厅的房间所需费用，代码如下 12$livingRoom = new DiningRoom(new LivingRoom(new Room()));echo $livingRoom-&gt;cost(); //输出1300 看，我们现在计算建造费用的思路是：计算出基础房间的费用 –&gt; 在基础房间上装饰成客厅的费用 –&gt; 在客厅的基础上加装饰餐厅的费用 –&gt; 得到包含客厅餐厅的房间费用。已经不需要麻烦的通过创建一个LivingDiningRoom类来计算包含客厅餐厅的房间建造费用了。 这便是装饰模式，通过一层一层的装饰，我们可以灵活的得到我们想要的结果。可以轻松的添加新的装饰器类或者新的组件来创建灵活的结构。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpabstract class Land&#123; abstract function cost();&#125;class Room extends Land&#123; private $money = 1000; public function cost() &#123; return $this-&gt;money; &#125;&#125;//装饰器abstract class RoomDecorator extends Land&#123; protected $land; public function __construct(Land $land) &#123; $this-&gt;land = $land; &#125;&#125;class LivingRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+200; &#125;&#125;class DiningRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+100; &#125;&#125;$livingRoomCost = new LivingRoom(new Room());echo $livingRoomCost-&gt;cost(); //输出1200$diningRoomCost = new DiningRoom(new Room());echo $diningRoomCost-&gt;cost(); //输出1100$livingDining = new DiningRoom(new LivingRoom(new Room()));echo $livingDining-&gt;cost(); //输出1300 the end. happy coding! ^_^","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"外观模式的总结","date":"2017-09-09T16:00:00.000Z","path":"2017/09/10/Facade-pattern/","text":"前言外观模式(Facade Pattern)是一个比较简单的概念，它只是为一个子系统创建一个单一的入口。这样的好处是有助于分离项目中不同的部分，其次，会使得我们在访问代码时变得简洁方便。另外，由于只在一个地方调用子系统，减少了出错的可能性。 外观模式比较简单，这里就不做过多的赘述了，主要是要吸收该模式减少耦合的思想，直接上代码。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass SystemA&#123; public function operationA() &#123; echo \"operationA &lt;br&gt;\"; &#125;&#125;class SystemB&#123; public function operationB() &#123; echo \"operationB &lt;br&gt;\"; &#125;&#125;class SystemC&#123; public function operationC() &#123; echo \"operationC &lt;br&gt;\"; &#125;&#125;class Facade&#123; protected $systemA; protected $systemB; protected $systemC; function __construct() &#123; $this-&gt;systemA = new SystemA(); $this-&gt;systemB = new SystemB(); $this-&gt;systemC = new SystemC(); &#125; public function myOperation() &#123; $this-&gt;systemA-&gt;operationA(); $this-&gt;systemB-&gt;operationB(); $this-&gt;systemC-&gt;operationC(); &#125;&#125;$facade = new Facade();$facade-&gt;myOperation();//只通过一个入口调用 总结使用外观模式最大的优点就是子系统与客户端之间是松耦合的关系，客户端不必知道具体有哪些子系统，也无需知道他们是如何工作的，通过引入一个外观类，提供一个客户端间接访问子系统的高级接口。子系统和外观类可以独立运作，修改某一个子系统的内容，不会影响到其他子系统，也不会影响到外观对象。 不过它的缺点就是它不够灵活，当需要增加一个子系统的时候，需要修改外观类。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"使用 Vagrant 并搭建 LNMP 环境","date":"2017-09-02T16:00:00.000Z","path":"2017/09/03/use-vagrant/","text":"Vagrant介绍 Vagrant 是一个自动化构建虚拟机环境的工具，可以自动化虚拟机的安装和配置流程。 在团队开发的情况下，我们常常需要在多台机器间同步开发时，有的同事用的 wamp ,有的同事是用的 xampp ，可能在某些配置上的些许不同会导致些许不同或者bug，通过使用 Vagrant ，我们只需要同步 Vagrantfile ，就可以保证各台机器拥有一致的开发环境。也可以通过打包好一个Vagrant box ,供团队的同事使用，这样就能最大程度的保证开发环境一致，避免出现一些没必要的问题从而浪费精力去解决。 安装 Vagrant1、安装 VirtualBox ,具体安装包直接从官网下载（要下载顺畅的话需翻墙）：https://www.virtualbox.org/wiki/Downloads 2、安装 Vagrant，下载地址：https://releases.hashicorp.com/vagrant/ 3、下载box镜像，这里我是下载的Ubuntu的box,可以到这个网址上去查找想下载的box：https://app.vagrantup.com/boxes/search 切换到自己的文件夹下，初始化vagrant环境，生成一个vagrantfile文件，命令如下： 用 vagrant 命令加 box 1$ vagrant box add testUbuntu ~/Downloads/ubuntu-14.04-amd64.box 初始化虚拟机 1$ vagrant init testUbuntu 启动虚拟机 1$ vagrant up 进入虚拟机的 Ubuntu 系统 1$ vagrant ssh 接下来还要对虚拟机进行一些配置。 打开 vagrantfile 文件进行配置，我的配置如下： 到这里，利用 vagrant 搭建虚拟机环境就基本完成了。 vagrant 常用命令 123456789vagrant box add 添加box，自动帮你生成vagrantfilevagrant init 初始化vagrantfilevagrant halt 关闭虚拟机vagrant destroy 销毁虚拟机vagrant ssh 连接虚拟机vagrant reload 重新加载vagarntfile文件vagrant suspend 暂时挂起虚拟机vagrant status 查看虚拟机运行状态vagrant package --output 打包导出box 搭建 LNMP 环境使用 vagrant ssh 登录到虚拟机的 Linux 系统上，就可以开始搭建 LNMP 的环境了。 在安装软件之前，需要对 Ubuntu 系统的镜像源文件 source.list 进行修改一下，可以在网上找一下网易的镜像源或者是阿里搜狐等的镜像源，然后写入 source.list 文件夹里（对源文件先进行下备份）。修改完之后还要运行一下 apt-get update 命令来更新一下镜像源。 安装 Nginx使用apt-get install nginx便可以安装nginx。非常简单。安转完之后，可以使用 curl -I &#39;127.0.0.1&#39;访问一下，看看是否安装成功。 安装 MySQL使用 apt-get install mysql-server mysql-cli 安装MySQL的服务端可客户端，安装的时候需要设置一下密码。安装完之后，通过命令 mysql -uroot -ppassword 命令来登录数据库。 安装PHP 7.0在这里，我使用 Ubuntu 的 PPA 源来安装 PHP 7.0。 先介绍一下 PPA源 PPA 全称为 Personal Package（个人软件包档案），是 Ubuntu Launchpad 网站提供的一项服务，当然不仅限于 Launchpad 。它允许个人用户上传软件源代码，通过 Launchpad 进行编译并发布为二进制软件包，作为 apt/新立得源供其他用户下载和更新。在Launchpad网站上的每一个用户和团队都可以拥有一个或多个PPA。通常 PPA 源里的软件是官方源里没有的，或者是最新版本的软件。相对于通过 Deb 包安装来说，使用 PPA 的好处是，一旦软件有更新，通过 sudo apt-get upgrade 这样命令就可以直接升级到新版本。 如何通过 PPA 源来安装软件： 我们可以通过 Google 来搜索一些常用软件的 PPA 源，通常的搜索方法是软件名称关键字 + PPA ，或者也可直接到 launchpad.net 上去搜索，搜索到后我们就可以直接用 sudo apt-add-repository 命令把 PPA 源添加到 Source list 中了。比如 FireFox PPA 源：https://launchpad.net/~ubuntu-mozilla-daily/+archive/ppa ，我们可以在这里找到 ppa:ubuntu-mozilla-daily/ppa 的字样，然后我们通过以下命令把这个源加入到 source list 中。 sudo apt-add-repository ppa:ubuntu-mozilla-daily/ppa 开始安装 PHP 7.0 第一次使用PPA时，需要先安装一下 python-software-properties 和 software-properties-common apt-get install python-software-properties software-properties-common 然后便可以开始安装PHP 7.0 了 123$ add-apt-repository ppa:ondrej/php$ apt-get update 安装PHP的一些扩展 $ apt-get install php7.0-fpm php7.0-mysql php7.0-common php7.0-curl php7.0-cli php7.0-mbstring php7.0-dom 打开 php.ini进行配置 vim /etc/php/7.0/fpm/php.ini 将cgi.fix__pathinfo=1 改成cgi.fix__pathinfo=0,这个配置是为了避免 nginx 产生某个漏洞。具体参考鸟哥的文章http://www.laruence.com/2010/05/20/1495.html cgi.fix_pathinfo=0 然后重启一下 php-fpm 服务。 到这里就成功搭建好了 LNMP环境了。 happy codding ! ^_^","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.tenpercent.top/tags/Linux/"},{"name":"Vagrant","slug":"Vagrant","permalink":"http://www.tenpercent.top/tags/Vagrant/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://www.tenpercent.top/tags/虚拟机/"}]},{"title":"PSR编程规范摘录","date":"2017-08-26T16:00:00.000Z","path":"2017/08/27/PSR-reference/","text":"这篇文章记录一下PHP的编程代码规范，做一个规范的PHPer。 PSR：即PHP Standards recommendation(PHP推荐标准)。 PSR-1:基本的代码风格 PHP标签： PHP标签只使用&lt;?php ?&gt;和&lt;?= ?&gt;，不得使用其他PHP标签句法。 编码： PHP所有文件都必须使用UTF-8字符集编码。 目的： 一个PHP文件可以定义符号（类、性状、函数和常量），或者执行有副作用的操作（例如，生成结果或处理数据），但是不能同时做这两件事。 自动加载： PHP命名空间和类必须遵守PSR-4自动加载器标准。 类的名称： PHP类的名称必须使用CamelCase这种驼峰式。 常量的名称：PHP常量的名称必须全部使用大写字母。如果需要，可以使用下划线把单词分开。例如：THIS_VARIABLE 方法的命名： PHP方法的名称必须使用camelCase这种驼峰式，首字母是小写的，后续的所有单词的首字母都是大写的。如：phpIsAwesome PSR-2:严格的代码风格PSR-2是在PSR-1的基础上进一步的要求。 缩进 PSR-2推荐的规范要求是使用4个空格缩进（因为空格最可靠，在不同的代码编辑器中渲染的效果基本一致） 文件和代码 PHP文件的最后一行要有一个空行，而且不能使用PHP关闭标签?&gt;，每行末尾都不能有空格。（这些要求大多数编辑器能帮你做好） 注：PHP文件不写关闭标签的目的是能避免意料之外的输出错误。如果加上关闭标签?&gt;，而且在关闭标签后有空行。那么这个空行会被当成输出导致错误。（例如，设定HTTP头部时） 关键字 对于ture,false和null,PSR-2推荐这些关键字都要使用小写字母的形式。 命名空间 每个命名空间声明语句后面必须跟着一个空行。使用use关键字导入命名空间时，在一系列的use声明语句后要加一个空行。 类 PSR-2推荐类定义体的起始括号应该在类名之后新起一行写。如下代码所示： 1234567&lt;?phpclass example &#123; //类的定义&#125; 方法 （直接代码示例如下） 12345678910&lt;?phpnamespace Animals //注意这里的命名空间首字母需要大写class example&#123; public function test($params = 1, $params = 'two')//注意这里起始括号和结束括号两边都没有空格 &#123; //方法的定义 &#125;&#125; 可见性 类中的每个属性和方法都要声明可见性。abstract和final这俩关键字要放在可见性关键字前面。static关键字要放在可见性关键字后面。代码如下 12345678910class example&#123; public static $number = 0; public function __construct() &#123; static::$number++; &#125;&#125; 控制结构 控制结构中如if else switch foreach等这些关键字后面都要有一个空格。示例代码如下 12345&lt;?phpif (a == b)&#123; //注意这里的花括号不用新起一行 &#125; 虽然现在有挺多的编辑器支持根据PSR-1和PSR-2来格式化代码了，不过这些写代码中的规范还是需要记住一下，尽量让自己的代码风格规范一些，这样在日常的工作中也方便团队交流。 PSR-3：日志记录器接口PSR-3与前面得规范不同，它是一个接口，规定PHP日志记录器组件可以实现得方法。 大多数PHP框架都在某种程度上实现了日志功能。为了实现互操作性和专业化，PHP-FIG制定了PSR-3日志记录器接口。若想使用符合PSR-3规范得日志记录器，框架要做到两件重要得事：日志功能委托给第三方库实现；最终用户能选择使用他们喜欢得日志记录器组件。 编写PSR-3日志记录器符合PSR-3推荐规范的PHP日志记录器组件，必须包含一个实现Psr\\Log|LoggerInterface接口得PHP类。PSR-3接口复用了系统日志协议，规定要实现以下九个方法： 123456789101112131415&lt;?phpnamespace Psr\\Log;interface LoggerInterface&#123; public function emergency($message,array $context = array()); public function alert($message,array $context = array()); public function critial($message,array $context = array()); public function error($message,array $context = array()); public function warning($message,array $context = array()); public function notice($message,array $context = array()); public function info($message,array $context = array()); public function debug($message,array $context = array()); public function log($level,$message,array $context = array());&#125; 但是，我们现在已经不需要自己去编写一个日志记录器了，因为已经有了Monolog(可访问packagist这个网站查看介绍)这个十分出色的PHP日志记录器组件了，它几乎提供了开发过程中所有需要的功能。 PSR-4：自动加载器PSR-4描述了一个标准的自动加载器策略。自动加载器策略是指，在运行时按需查找PHP类、接口或者性状，并将其载入PHP解释器。支持PSR-4自动加载器标准的PHP组件和框架，使用同一个自动加载器就能找到相关代码 在PHP-FIG发布PSR-4推荐规范之前，PHP组件和框架的作者使用__autoload()和spl_autoload_register()函数注册自定义的自动加载器策略。可是，每个PHP组件和框架都使用独特的自动加载器，而且每个加载器使用不同的逻辑查找并加载PHP类、性状和接口。使用这些组件和框架的开发者，在引导PHP应用时必须调用每个组件各自的自动加载器时必须调用每个组件各自的自动加载器。这样在开发中很麻烦。 如今，得益于PSR-4，我们只需要使用一个自动加载器就能自动加载应用中的所有PHP组件。大多数现代的PHP组件和框架都符合PSR-4规范。 PSR自动加载策略PSR-4自动加载策略依赖PHP命名空间和文件系统目录结构查找并加载PHP类、接口，性状。 它的精髓是把命名空间的前缀和文件系统中的目录对应起来。例如，\\Oreilly\\ModernPHP\\Chapter1命名空间对应与src/chapter1目录，\\Oreilly\\ModernPHP\\Chapter1\\Example类对应于src/Chapter1/Example。 实现一个PSR-4自动加载器123456789101112131415161718192021222324252627282930313233343536&lt;?php/*** 该代码中，使用SPL注册这个自动加载函数后，遇到下述代码时，这个函数会* 自动尝试从/path/to/project/src/Baz/Qux.php文件中加载* \\Foo\\Bar\\Baz\\Quz类：* new \\Foo\\Bar\\Baz\\Qux;* */spl_autpload_register(function ($class))&#123; //这个项目的命名空间前缀 $prefix = 'Foo\\\\Bar\\\\'; //这个命名空间对应的根目录； $base_url = __DIR__.'/src/'; //参数传入的类使用这个命名空间前缀吗？ $len = strlen($prefix); if(strncmp($prefix, $class, $len) !==0)&#123; //不使用，交给注册的下一个自动加载器处理 return; &#125; //获取去掉前缀后的类名 $relative_class = substr($class, $len); //把命名空间前缀替换成根目录， //去掉前缀的类命中，把命名空间分隔符替换成目录分隔符， //然后再后面加上.php $file = $base_dir.str_replace('\\\\', '/', $relative_class).'.php'; //如果文件存在，将其导入 if(file_exists($file))&#123; require $file; &#125;&#125; 以上代码是一个PSR-4自动加载器的逻辑。不过在现在，我们也无须自己编写一个PSR-4自动加载器了，因为我们可以使用依赖管理器Composer自动生成PSR-4自动加载器。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"PSR","slug":"PSR","permalink":"http://www.tenpercent.top/tags/PSR/"}]},{"title":"现代化PHP的标准","date":"2017-08-12T16:00:00.000Z","path":"2017/08/13/php-standard/","text":"在今天，PHP组件和框架的数量很多，可以说是多如牛毛。PHP生态系统是个名副其实的大熔炉，有各种各样的代码，帮助开发者构建强大的应用。为了使这些不同的组件代码、框架能互相通信，共享代码，就诞生了PHP-FIG这个组织，PHP-FIG制定了推荐规范，PHP框架可以自愿实现这些规范，改进与其他框架的通信和共享功能。如今的很多受欢迎的大型PHP框架通常都会实现定案的PHP-FIG推荐规范。 PHP-FIG的使命是实现框架的互操作性。框架的互操作性是指，通过接口、自动加载机制和标准的风格，让框架互相操作。 接口PHP框架之间通过共用的接口合作。框架通过PHP接口假定第三方依赖提供了什么方法，而不关心依赖是如何实现接口的。 例如：假如第三方日志记录器对象实现了alert()，critical()，error()，warning()和debug()等方法，那么框架就可以放心的使用这个记录器对象。至于这些方法是如何实现的无关紧要，框架只关心第三方依赖是否实现了这些方法。 PHP开发者使用接口可以开发、共享并使用专门的组件，而无需使用庞大的框架。 自动加载PHP框架之间通过自动加载机制合作。自动加载是指，PHP解释器在运行时按需自动找到并加载PHP类的过程。 在这些PHP标准出现之前，PHP组件和框架会使用模式方法__autoload（）或最新的spl_autoload_register()方法实现各自特有的自动加载器。因此，我们要学习使用每一个组件和框架各自特有的自动加载器。而如今，多数现代的PHP组件和框架都符合同一个自动加载器标准。这意味着，我们只需使用一个自动加载器就能混合搭配多个PHP组件。 风格PHP框架之间通过标准的代码风格合作。代码风格是指如何使用空格、大小写和括号的位置（等待）。如果PHP框架都使用标准的代码风格，那么每次使用新PHP框架时，PHP开发者已经对框架所用的风格就很熟悉了，就不用适应新的风格。标准的代码风格还能降低项目新贡献者的门槛，让新贡献者把更多的时间用在解决缺陷上，而不用花太多时间学习不熟悉的风格。 标准的代码风格对我们自己的项目也有好处。每个开发者都有一些独特的风格，如果多为开发者在同一个代码基中工作，就会显露问题。使用标准的代码风格，不管作者是谁，团队中的所有成员都能立即理解代码基。 关于代码风格的规范，PHP-FIG退出了PSR，即PHP Standard Recommendation（PHP推荐标准）的简称。它包括PSR-1，PSR-2，PSR-3，PSR-4四个规范，现代的PHP框架基本都会遵守这些规范，这些个规范的具体详细内容就等下一篇总结再介绍吧。今天就先写到这里。 ^_^ happy coding!","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"PHP标准","slug":"PHP标准","permalink":"http://www.tenpercent.top/tags/PHP标准/"}]},{"title":"关于三种工厂模式的总结","date":"2017-07-09T16:00:00.000Z","path":"2017/07/10/factory-pattern/","text":"工厂模式分为简单工厂模式，工厂方法模式和抽象工厂模式，它们都属于设计模式中的创建型模式。其主要功能都是帮助我们把对象的实例化部分抽取了出来，目的是降低系统中代码耦合度，并且增强了系统的扩展性。本文对这三种模式进行了介绍并且分析它们之间的区别。 简单工厂模式简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码逻辑将会非常复杂。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php//简单工厂方法interface People&#123; public function say();&#125;class Man implements People&#123; public function say() &#123; echo 'this is a man '; &#125;&#125;class Women implements People&#123; public function say() &#123; echo 'this is a women'; &#125;&#125;class SimpleFactory&#123; public static function create($name) &#123; if ($name == 'man') &#123; return new Man(); &#125; elseif ($name == 'women') &#123; return new Women(); &#125; &#125; &#125;//具体调用$man = SimpleFactory::create('man');$man-&gt;say();$women = SimpleFactory::create('women');$women-&gt;say(); 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。 工厂方法模式此模式中，通过定义一个抽象的核心工厂类，并定义创建产品对象的接口，创建具体产品实例的工作延迟到其工厂子类去完成。这样做的好处是核心类只关注工厂类的接口定义，而具体的产品实例交给具体的工厂子类去创建。当系统需要新增一个产品是，无需修改现有系统代码，只需要添加一个具体产品类和其对应的工厂子类，使系统的扩展性变得很好，符合面向对象编程的开闭原则。体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php//工厂方法模式interface People&#123; public function say();&#125;class Man implements People&#123; public function say() &#123; echo 'this is a man'; &#125;&#125;class Women implements People&#123; public function say() &#123; echo 'this is a women'; &#125;&#125;//与简单工厂模式相比。区别在于，此处将对象的创建抽象成一个接口interface CreatePeople&#123; public function create();&#125;class FactoryMan implements CreatePeople&#123; public function create() &#123; return new Man(); &#125;&#125;class FactoryWomen implements CreatePeople&#123; public function create() &#123; return new Women(); &#125;&#125;class Client&#123; // 具体生产对象并执行对象方法测试 public function test() &#123; $factory = new FactoryMan(); $man = $factory-&gt;create(); $man-&gt;say(); $factory = new FactoryWomen(); $man = $factory-&gt;create(); $man-&gt;say(); &#125;&#125;// 执行$demo = new Client();$demo-&gt;test(); 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 此模式是对工厂方法模式的进一步扩展。在工厂方法模式中，一个具体的工厂负责生产一类具体的产品，即一对一的关系，但是，如果需要一个具体的工厂生产多种产品对象，那么就需要用到抽象工厂模式了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php interface TV&#123; public function open(); public function watch();&#125;class HaierTv implements TV&#123; public function open() &#123; echo \"Open Haier TV &lt;br&gt;\"; &#125; public function watch() &#123; echo \"I'm watching TV &lt;br&gt;\"; &#125;&#125;interface PC&#123; public function work(); public function play();&#125;class LenovoPc implements PC&#123; public function work() &#123; echo \"I'm working on a Lenovo computer &lt;br&gt;\"; &#125; public function play() &#123; echo \"Lenovo computers can be used to play games &lt;br&gt;\"; &#125;&#125;abstract class Factory&#123; abstract public static function createPc(); abstract public static function createTv();&#125;class ProductFactory extends Factory&#123; public static function createTV() &#123; return new HaierTv(); &#125; public static function createPc() &#123; return new LenovoPc(); &#125;&#125;$newTv = ProductFactory::createTV();$newTv-&gt;open();$newTv-&gt;watch();$newPc = ProductFactory::createPc();$newPc-&gt;work();$newPc-&gt;play(); 在上面的Factory抽象类中，定义了两个抽象方法，这两个抽象方法分别用来生产不同的产品（即由不同类实例化的对象）。 工厂方法模式和抽象工厂模式对比通过以上代码：我们来对比一下工厂方法模式和抽象工厂模式： 工厂方法模式中 当我需要多生产一种新的产品，比如factoryKid这个产品，我需要专门再设一个factoryKid的工厂，即添加如下代码： 1234567891011121314class Kid implements People&#123; public function say() &#123; echo 'this is a kid'; &#125;&#125;class FactoryKid implements CreatePeople&#123; public function create() &#123; return new Kid(); &#125;&#125; 抽象工厂模式中 同样当我需要多生产一种新的产品，比如生产一个iphone,此时我需要修改工厂父类里的接口，并且在具体工厂类ProductFactory这个工厂里增加一条createPhone生产线(即类里面的方法)，所需添加的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041interface Phone&#123; public function work(); public function sms();&#125;class IPhone implements Phone&#123; public function work() &#123; echo \"I'm iphone &lt;br&gt;\"; &#125; public function sms() &#123; echo \"this is an iphone &lt;br&gt;\"; &#125;&#125;//在原来的抽象工厂类中添加方法声明abstract class Factory&#123; abstract public static function createPc(); abstract public static function createTv(); abstract public static function createPhone();&#125;//在原来的工厂类里添加一个方法class ProductFactory extends Factory&#123; public static function createTV() &#123; return new HaierTv(); &#125; public static function createPc() &#123; return new LenovoPc(); &#125; public static function createPhone() &#123; return new IPhone(); &#125;&#125; 从上面的分析可以看出，要生产一个新的产品，抽象工厂模式并不比工厂方法模式更为便捷，那么抽象工厂模式的好处在哪呢?它优点就是在于是增加固定类型产品的不同具体工厂比较方便，比如我要增加一个生产同样类型产品的具体工厂Product2Factory，那么就再建一个Product2Factory类继承Factory就可以了。 最后的最后，总结一下工厂方法模式和抽象工厂模式的核心区别 工厂方法模式利用继承，抽象工厂模式利用组合 工厂方法模式产生一个对象，抽象工厂模式产生一族对象 工厂方法模式利用子类创造对象，抽象工厂模式利用接口的实现创造对象","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"PHP单例模式的总结","date":"2017-06-19T16:00:00.000Z","path":"2017/06/20/Singleton-Pattern/","text":"什么是单例模式含义单例模式是一种对象的创建模式，它用来确保某一个类只有一个实例，而且自行实例化并向整个系统全局的提供这个实例。 单例模式的特点1、有一个保存类的唯一实例的静态成员变量 2、有一个定义为私有的构造函数，表明这个类是不可能形成实例的，防止出现这个类有多个实例的情况出现（有时也可添加个声明为私有的克隆函数）。 3、提供一个能访问这个实例的声明为公共的静态方法（通常为getInstance方法），用来作为返回唯一实例的引用。 具体实现代码： 1234567891011121314151617181920212223242526272829class Preferences &#123; private $props = array(); private static $instance; private function __construct()&#123; &#125; private function __clone()&#123;&#125;; public static function getInstance()&#123; if(empty(self::$instance))&#123; self::$instance = new Preferences(); &#125; return self::$instance; &#125; public function setProperty($key,$val)&#123; $this-&gt;props[$key] = $val; &#125; public function getProperty($key)&#123; return $this-&gt;props[$key]; &#125; &#125;//调用单例 $pref = Preferences::getInstance(); $pref-&gt;setProperty('name','cjhlfy'); unset($pref); $pref2 = Preferences::getInstance(); echo $pref2-&gt;getProperty('name'); //name的属性值不会丢失,因为实例引用 $instance是静态属性 为什么要用单例模式全局变量是面向对象程序员遇到的引发bug的主要原因之一，这是因为全局变量将捆绑于特定的环境，破坏了封装。如果新的应用程序无法保证一开始就定义了相同的全局变量，那么一个依赖于全局变量的类就无法就无法从一个应用程序中提取出来并应用到新的应用程序中。所以单例模式是一种对于全局变量的改进。 不过，单例模式的使用也有不利的地方，它可能导致很难调试的依赖关系。如果改变一个实例，那么所有使用改单例的类可能都会受到影响。当单例被使用时，依赖便会隐藏在方法内部，而且并不会出现在方法声明里。这使得系统中的依赖关系更难以追踪，因此需要谨慎小心的部署单例类 单例模式应用应用场合1、应用程序与数据库的交互 一个应用中会存在大量的数据库操作，比如通过数据库句柄来连接数据库这一行为，使用单例模式可以避免大量的new操作，因为每一次new操作都会消耗内存资源和系统资源。 2、控制配置信息 如果系统中有有一个类来全局控制某些配置信息，那么使用单例模式就可以很方便实现，并且可以对配置进行统一管理。 以数据库操作为例深入理解12345678910111213141516171819202122232425262728293031323334class DB &#123; private $db; private static $instance; private function __construct()&#123; //进行数据库连接 &#125; private function __clone() &#123; &#125;; public static function getInstance()&#123; if(empty(self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; //数据库查询操作 public function select()&#123; //... &#125; //数据库插入操作 public function insert()&#123; //... &#125;&#125; //数据库编辑操作 public function update()&#123; //... &#125;&#125; //获取数据库单例类实例化之后，便可对数据库进行操作$db = DB::getInstance();$db-&gt;select();$db-&gt;insert();$db-&gt;update(); 单例模式的总结就到这里。 参考：《面向对象、模式与实践》","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"数据库查询中的exists与in分析比较","date":"2017-06-07T16:00:00.000Z","path":"2017/06/08/about-exists/","text":"最近在用Laravel的ORM写数据库查询时，用到了whereHas的写法，这个写法的背后实现的SQL语句就是select * from `table1` where exists(select * from `table2` where table1.id = table2.table1_id),于是就查清楚了一下exists的用法和特点，在这里记录一下。 exists的用法以下图的两张表关系作为分析： exists表示存在，它常常和子查询配合使用。例如对于上图，写下下面的SQL语句 SELECT FROM `user` WHERE exists (SELECT FROM `order` WHERE user.id = order.user_id) 在这里，exists用于检查查询子查询语句是否会至少返回一行数据，如果有返回数据，则返回值是true，反之是false。 放子查询返回为true时，则外层的查询语句将进行查询，反之，外层查询语句将不进行查询或者查不出任何记录。 因此：上面的SQL所实现的意义在于，搜索出所有下过单的会员。 exists和in的区别和使用场景除了exitst，in的使用也可以实现上面语句的效果。如下： SELECT * FROM `user` WHERE id in (SELECT user_id FROM `order`) 那么，它们之间有什么区别呢。 in()语句只会执行一次，它查出order表中的所有user_id字段并且缓存起来，之后，检查user表的id是否和order表中的user_id相当，如果相等则加入结果期，直到遍历完user的所有记录。用程序来表示如下： 123456789101112131415161718192021222324252627$result = [];$users = \"SELECT * FROM `user`\";$orders = \"SELECT user_id FROM `order`\";for($i = 0;$i &lt; $users.length;$i++)&#123; for($j = 0;$j &lt; $orders.length;$j++)&#123; // 此过程为内存操作，不涉及数据库查询。 if($users[$i].id == $orders[$j].user_id)&#123; $result[] = $users[$i]; break; &#125; &#125;&#125;``` 从上面的程序可以明显的看出，当order表数据很大的时候不适合用in,因为最多会将order表数据全部遍历一遍。如：user表有10000条记录,order表有1000000条记录,那么最多有可能遍历10000*1000000次,这样的话效率就很差了。* 再看exists，它的查询过程类似如下：```php $result = [];$users = \"SELECT * FROM `user`\";for($i=0;$i&lt;$users.length;$i++)&#123; if(exists($users[$i].id))&#123;// 执行SELECT * FROM `order` WHERE user.id = order.user_id $result[] = $users[$i]; &#125;&#125; 显而易见：当order表比user表大很多的时候，使用exists是再恰当不过了，它没有那么多遍历操作,只需要再执行一次查询就行。查询次数的多少完全取决于user表的记录条数。 但是：如果说user表有10000条记录,order表有100条记录,那么exists()还是执行10000次,反而不如使用in()遍历10000*100次,因为in()是在内存里遍历,而exists()需要查询数据库,我们都知道查询数据库所消耗的性能比较大,而操作内存的话会比较快. 因此，可以得出总结： 若外层查询表小于子查询表，则用exists。 若外层查询表(记录条数很多)远大于子查询表，则考虑用in。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"}]}]