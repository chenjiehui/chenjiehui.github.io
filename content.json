[{"title":"当我们在谈索引的时候，我们在谈什么","date":"2019-10-16T16:00:00.000Z","path":"2019/10/17/mysql-index-1/","text":"一句话总结：一个索引就是一棵 B+ 树 那么这个 B+ 树是什么样子的呢？ 数据存储在叶子节点，中间节点存目录项 那么， 叶子节点啥样的？ 目录节点啥样的？ 要知道节点的结构，就得先知道 InnoDB 管理存储空间的基本单位 —— 页。 InnoDB 引擎将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，页的大小一般为 16 KB。InnoDB 设计了许多种不同类型的页，比如存放表数据记录的页，存放表空间头部信息的页，存放 Insert Buffer 信息的页，存放 undo 日志的页等等，而这之中存放表中索引数据记录的页即数据页就是 B+ 数的叶子节点。 数据页数据页中由多个部分组成，不同部分有不同的作用，其结构如下图： 其中，各个部分的作用如下： File Header File Header 是各种类型的页都有的部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页分别是谁等信息。通过 File Header 存储的上一页下一页的信息，各个数据页可以组成一种双向链表的结构。 Page Header Page Header 用来存储本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等。 Infimum + Supremum InnoDB 定义的两条分别为最小记录与最大记录的伪记录 User Records User Records 插入数据库的记录存储的地方，一开始生成页的时候，并没有 User Records 这部分，每当插入一条记录后，都会从 Free Space 部分申请一个记录大小的空间划分到 User Records 部分，当插入的记录越来越多导致 Free Space 用完之后，也就意味着这个也使用完了，要再插入新记录，就需要申请新的页了。每条记录通过 next_record 属性记录着下一条记录的地址偏移量，即所有记录实际上是一个单向链表的结构。记录里的 record_type 属性值为 0。 Page Directory 为了便于查找， InnoDB 将 User Records 里的记录划分为多个组，每个组的最后一条记录的地址偏移量取出来放在 Page Directory 中，这个地址偏移量被称为槽（Slot），所以 Page Directory 就是由槽组成的。 所以在页中要查找一条记录的过程是：通过主键值用二分法确定要查找的记录位于哪个槽所对应的组中，在对应的组里遍历（每个组里包含的记录只能是 1 ~ 8 条）找到对应的记录。 File Trailer File Trailer 是用来校验页是否完整的，确保数据在内存和磁盘间同步不会有差错。 以上就是数据页的结构，所以，索引的叶子节点就是存有被设为索引的记录的数据页。 目录节点上面说到数据页之间是通过 File Header 里记录的信息来找到上一页和下一页的信息，那么如何找到第一页呢？这里就得需要有目录项了，每个目录项包括两个部分：页的用户记录中最小的主键值和页号。因为存储的记录会很多导致目录项也很多，所以为了方便对目录项进行存放和管理，InnoDB 目录项的结构设计是跟数据页一样的，不同的是其中保存记录的部分存放的是目录的信息，即目录的主键和其页号，且记录里的record_type 属性值为 1。 目录指向叶子节点的的示意图如下： 当存储的记录越来越多导致目录项越来越多时，要查找一个目录项就变得越来越不容易，此时，就需要有指向目录项的目录了，于是一直演变下去就会出现多级目录，形成数据的索引，而这个多级目录就是一个树的结构，如下图所示： 在 InnoDB 里这种树叫 B+ 树，所谓的索引就是长这样。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"http://www.tenpercent.top/tags/索引/"}]},{"title":"浅析 PHP7 的垃圾回收机制","date":"2019-08-30T16:00:00.000Z","path":"2019/08/31/php7-garbage-collection/","text":"垃圾回收机制垃圾回收机制是一种动态存储分配方案。它会自动释放程序不再需要的已分配的内存块。 自动回收内存的过程叫垃圾收集。垃圾回收机制可以让程序员不必过分关心程序内存分配，从而将更多的精力投入到业务逻辑。 在现在的流行各种语言当中，垃圾回收机制是新一代语言所共有的特征。 垃圾的产生PHP7 中复杂类型，像字符串、数组、对象等的数据结构中，头部都有一个 gc, 这个 gc 的作用就是用来对垃圾回收的支持。当变量赋值、传递时，会增加 value 的引用数， unset、return 等释放变量时再减掉引用数，减掉后如果发现 refcount 变为 0 则直接释放 value，这是变量的基本回收过程。 不过有一种问题是这个机制无法解决的，就是循环引用的问题。 什么是循环引用呢？ 简单说就是变量的内部里存的 value 又引用了变量自身。 这种比较经常发生在数组和对象类型的变量上。 这里先讲一下引用，即 zend_reference 这个类型，这个是 PHP7 新增的变量类型，当对变量使用 “&amp;” 操作时，会创建新的中间结构体 zend_reference，这个结构体会真正的指向对应的 value 结构。 举个例子： 1234// 当进行如下赋值操作时$a = 'hello'; // $a -&gt; zend_string$b = $a; // $b,$a -&gt; zend_string$c = &amp;$b; // $c,$b -&gt; zval(type = IS_REFERENCE, refcount = 2) -&gt; zend_string 最终会变成如下这样： 即 $b 和 $c 的 zval 是通过中间结构体 zend_reference 再指向最终的 zend_string。 回到循环引用的问题，举个数组循环引用例子： 1234$a = [1];$a[] = &amp;$a;unset($a); 使用 &amp; 操作之后，变量 a 就变成了引用类型且引用计数 refcount 为 2，而又赋值给自己里面的元素，即变量 a 变成了自己引用自己。 具体如下如所示： 当 unset 之后就变成下图这样： 即 $a 所在的 zval 类型已经变成了 IS_UNDEF 了，zend_reference 结构体的引用计数减 1，但是仍然大于 0，这时候，这部分结构体就变成了垃圾，对此不处理的话，就可能会造成内存泄露。这里就需要垃圾收集器将这部分收集到缓冲区，之后进行回收处理。 回收过程如果当变量的 refcount 减小后大于 0，PHP 并不会立即对这个变量进行垃圾鉴定和回收，而是放入一个缓冲区中，等这个缓冲区满了以后(10000 个值)再统一进行处理，加入缓冲区的是变量 zend_value 里的 gc，目前垃圾只会出现在数组和对象两种类型中，数组的情况上面已经介绍了，对象的情况则是成员属性引用对象本身导致的，其它类型不会出现这种变量中的成员引用变量自身的情况，所以垃圾回收只会处理这两种类型的变量。 gc 的结构 zend_refcounted_h 具体如下: 123456789101112typedef struct _zend_refcounted_h &#123; uint32_t refcount; // 记录 zend_value 的引用数 union &#123; struct &#123; zend_uchar type, // zend_value的类型, 与zval.u1.type一致 zend_uchar flags, uint16_t gc_info // GC信息，记录在 gc 池中的位置和颜色，垃圾回收的过程会用到 &#125; v; uint32_t type_info; &#125; u;&#125; zend_refcounted_h; 一个变量只能加入一次缓冲区，为了防止重复加入，变量加入后会把 zend_refcounted_h.gc_info 置为 GC_PURPLE，即标为紫色，后续不会重复插入。 垃圾缓冲区是一个双向链表，等到缓存区满了以后则启动垃圾检查过程：遍历缓冲区，对当前变量的所有成员进行遍历，然后把成员的 refcount 减 1 (如果成员还包含子成员则也进行递归遍历，即深度优先遍历)，最后再检查当前变量的引用，如果减为了 0 则为垃圾。这个算法的原理核心是：垃圾是由于成员引用自身导致的，那么就对所有的成员减一遍引用，如果发现最后变量本身的 refcount 变为了 0 则就表明其引用全部来自自身成员，即其他任何地方都不再使用它，那么它就是垃圾，需要被回收掉。反之说明不是垃圾，需要将其从缓冲区移出去。具体的过程如下： (1) 从缓冲区链表的 roots 开始遍历，把当前 value 标为灰色 (zend_refcounted_h.gc_info 置为 GC_GREY)，然后对当前 value 的成员进行深度优先遍历，把成员 value 的 refcount 减 1，并且也标为灰色； (2) 重复遍历缓冲区链表，检查当前 value 引用是否为 0，为 0 则表示确实是垃圾，把它标为白色(GC_WHITE)，如果不为 0 则排除了引用全部来自自身成员的可能，表示还有外部的引用，并不是垃圾，这时候因为步骤(1)对成员进行了 refcount 减 1 操作，需要再还原回去，对所有成员进行深度遍历，把成员 refcount 加 1，同时标为黑色； (3) 再次遍历缓冲区链表，将非 GC_WHITE 的节点从 roots 链表中移出（移到待释放的列表），最终 roots 链表中全部为真正的垃圾，最后将这些垃圾清除。 参考资料 《PHP7 底层设计与源码解析》 php7-internal","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"底层","slug":"底层","permalink":"http://www.tenpercent.top/tags/底层/"}]},{"title":"PHP7 数组的底层实现","date":"2019-08-22T16:00:00.000Z","path":"2019/08/23/PHP7-Array/","text":"PHP 数组具有的特性PHP 的数组是一种非常强大灵活的数据类型，在讲它的底层实现之前，先看一下 PHP 的数组都具有哪些特性。 可以使用数字或字符串作为数组健值 12$arr = [1 =&gt; 'ok', 'one' =&gt; 'hello']; 可按顺序读取数组 1234foreach($arr as $key =&gt; $value)&#123; echo $arr[$key];&#125; 可随机读取数组中的元素 12345$arr = [1 =&gt; 'ok', 'one' =&gt; 'hello', 'a' =&gt; 'world'];echo $arr['one'];echo current($arr); 数组的长度是可变的 123456$arr = [1, 2, 3];$arr[] = 4;array_push($arr, 5); 正是基于这些特性，我们可以使用 PHP 中的数组轻易的实现集合、栈、列表、字典等多种数据结构。那么这些特性在底层是如何实现的呢？ 这就得从数据结构说起了。 数据结构 PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。 PHP 数组的底层实现是散列表（也叫 hashTable )，散列表是根据键（Key）直接访问内存存储位置的数据结构，它的key - value 之间存在一个映射函数，可以根据 key 通过映射函数得到的散列值直接索引到对应的 value 值，无需通过关键字比较，在理想情况下，不考虑散列冲突，散列表的查找效率是非常高的，时间复杂度是 O(1)。 从源码中我们可以看到 zend_array 的结构如下： 123456789101112131415161718192021222324typedef struct _zend_array zend_array;typedef struct _zend_array hashTable;struct _zend_array &#123; zend_refcounted_h gc; union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar flags, zend_uchar nApplyCount, zend_uchar nIteratorsCount, zend_uchar reserve) &#125; v; uint32_t flags; &#125; u; uint32_t nTableMask; // 哈希值计算掩码，等于nTableSize的负值(nTableMask = -nTableSize) Bucket *arData; // 存储元素数组，指向第一个Bucket uint32_t nNumUsed; // 已用Bucket数（含失效的 Bucket） uint32_t nNumOfElements; // 哈希表有效元素数 uint32_t nTableSize; // 哈希表总大小，为2的n次方（包括无效的元素） uint32_t nInternalPointer; // 内部指针，用于遍历 zend_long nNextFreeElement; // 下一个可用的数值索引,如:arr[] = 1;arr[\"a\"] = 2;arr[] = 3; 则nNextFreeElement = 2; dtor_func_t pDestructor;&#125;; 该结构中的 Bucket 即储存元素的数组，arData 指向数组的起始位置，使用映射函数对 key 值进行映射后可以得到偏移值，通过内存起始位置 + 偏移值即可在散列表中进行寻址操作。 Bucket 的数据结构如下： 12345typedef struct _Bucket &#123; zval val; // 存储的具体 value，这里是一个 zval，而不是一个指针 zend_ulong h; // 数字 key 或字符串 key 的哈希值。用于查找时 key 的比较 zend_string *key; // 当 key 值为字符串时，指向该字符串对应的 zend_string（使用数字索引时该值为 NULL），用于查找时 key 的比较&#125; Bucket; 到这里有个问题出现了：存储在散列表里的元素是无序的，PHP 数组如何做到按顺序读取的呢？ 答案是中间映射表，为了实现散列表的有序性，PHP 为其增加了一张中间映射表，该表是一个大小与 Bucket 相同的数组，数组中储存整形数据，用于保存元素实际储存的 Value 在 Bucekt 中的下标。Bucekt 中的数据是有序的，而中间映射表中的数据是无序的。 而通过映射函数映射后的散列值要在中间映射表的区间内，这就对映射函数提出了要求。 映射函数PHP7 数组采用的映射方式： 1nIndex = h | ht-&gt;nTableMask; 将 key 经过 time33 算法生成的哈希值 h 和 nTableMask 进行或运算即可得出映射表的下标，其中 nTableMask 数值为 nTableSize 的负数。并且由于 nTableSize 的值为 2 的幂次方，所以 nTableMask 二进制位右侧全部为 0，保证了 h | ht-&gt;nTableMask 的取值范围会在 [-nTableSize, -1] 之间，正好在映射表的下标范围内。另外，用按位或运算的方法和其他方法如取余的方法相比运算速度较高，这个映射函数可以说设计的非常巧妙了。 散列（哈希）冲突不同键名的通过映射函数计算得到的散列值有可能相同，此时便发生了散列冲突。 对于散列冲突有以下 4 种常用方法： 1.将散列值放到相邻的最近地址里 2.换个散列函数重新计算散列值 3.将冲突的散列值统一放到另一个地方 4.在冲突位置构造一个单向链表，将散列值相同的元素放到相同槽位对应的链表中。这个方法叫链地址法，PHP 数组就是采用这个方法解决散列冲突的问题。 其具体实现是：将冲突的 Bucket 串成链表，这样中间映射表映射出的就不是某一个元素，而是一个 Bucket 链表，通过散列函数定位到对应的 Bucket 链表时，需要遍历链表，逐个对比 Key 值，继而找到目标元素。而每个 Bucket 之间的链接则是将原 value 的下标保存到新 value 的 zval.u2.next 里，新 value 放在当前位置上，从而形成一个单向链表。 举个例子： 当我们访问 $arr[‘key’] 的过程中，假设首先通过散列运算得出映射表下标为 -2 ，然后访问映射表发现其内容指向 arData 数组下标为 1 的元素。此时我们将该元素的 key 和要访问的键名相比较，发现两者并不相等，则该元素并非我们所想访问的元素，而元素的 zval.u2.next 保存的值正是另一个具有相同散列值的元素对应 arData 数组的下标，所以我们可以不断通过 zval.u2.next 的值遍历直到找到键名相同的元素。 扩容PHP 的数组在底层实现了自动扩容机制，当插入一个元素且没有空闲空间时，就会触发自动扩容机制，扩容后再执行插入。 扩容的过程为： 如果已删除元素所占比例达到阈值，则会移除已被逻辑删除的 Bucket，然后将后面的 Bucket 向前补上空缺的 Bucket，因为 Bucket 的下标发生了变动，所以还需要更改每个元素在中间映射表中储存的实际下标值。 如果未达到阈值，PHP 则会申请一个大小是原数组两倍的新数组，并将旧数组中的数据复制到新数组中，因为数组长度发生了改变，所以 key-value 的映射关系需要重新计算，这个步骤为重建索引。 重建散列表在删除某一个数组元素时，会先使用标志位对该元素进行逻辑删除，即在删除 value 时只是将 value 的 type 设置为 IS_UNDEF，而不会立即删除该元素所在的 Bucket，因为如果每次删除元素立刻删除 Bucket 的话，每次都需要进行排列操作，会造成不必要的性能开销。 所以，当删除元素达到一定数量或扩容后都需要重建散列表，即移除被标记为删除的 value。因为 value 在 Bucket 位置移动了或哈希数组 nTableSize 变化了导致 key 与 value 的映射关系改变，重建过程就是遍历 Bucket 数组中的 value，然后重新计算映射值更新到散列表。 关于 PHP7 的数组底层实现就总结这么些了，因为水平有限也无法研究的十分详尽清楚，如果有疑问或者不足之处欢迎提出~~ 参考资料 《PHP7 的底层设计与源码实现》 php7-internal","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"底层","slug":"底层","permalink":"http://www.tenpercent.top/tags/底层/"}]},{"title":"PHP7 的基本变量","date":"2019-08-14T16:00:00.000Z","path":"2019/08/15/php-zval-struct/","text":"变量的基础结构我们都知道PHP的变量是弱类型的，声明的时候无需指定类型。那么这里面具体是怎么实现的呢？这就得从变量的基础结构说起了。 zval的实现在源码文件 zend_type.h 中，可以看到 zval 的定义： 1234567891011121314151617181920212223242526typedef struct _zval_struct zval;struct _zval_struct &#123; zend_value value; /* value */ union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar type, /* active type */ zend_uchar type_flags, zend_uchar const_flags, zend_uchar reserved) /* call info for EX(This) */ &#125; v; uint32_t type_info; &#125; u1; union &#123; uint32_t next; /* hash collision chain */ uint32_t cache_slot; /* literal cache slot */ uint32_t lineno; /* line number (for ast nodes) */ uint32_t num_args; /* arguments number for EX(This) */ uint32_t fe_pos; /* foreach position */ uint32_t fe_iter_idx; /* foreach iterator index */ uint32_t access_flags; /* class constant access flags */ uint32_t property_guard; /* single property guard */ uint32_t extra; /* not further specified */ &#125; u2;&#125; zval 的结构由一个保存变量类型的值或指针的 union 联合体 zend_value 以及两个 union 联合体 u1 和 u2 组成 u1 u1的作用是用来保存变量类型及其信息，其里面的字段用处如下： type：记录变量类型。 即可通过 u2.v.type 来访问到 type_flags：对应变量特有类型的标记（如常量类型，需引用计数类型，不可变类型），不同类型的变量对应的 flag 不一样。 const_flags：常量类型的标记 reserved：保留字段 u2 u2 主要是辅助作用，由于结构体的内存对齐，所以 u2 的的这块空间有或者没有 u2 都是已经占据空间了，所以就利用起来。u2的辅助字段里面记录了很多类型信息，这些信息对内部功能有很大的好处，或提升缓存友好性或减少了内存寻址的操作。这里介绍其中部分字段。 next：用来解决哈希冲突问题（哈希冲突这个目前还不懂），记录冲突的下一个元素位置。 cache_slot：运行时缓存。在执行函数时会优先去缓存中查找，若缓存中没有，再去全局的 function 表中查找。 num_args：函数调用时传入参数的个数 access_flags：对象类的访问标识，如public protected private 这些。 zend_value 12345678910111213141516171819typedef union _zend_value &#123; zend_long lval; /* 整型*/ double dval; /* 浮点型 */ zend_refcounted *counted; zend_string *str; zend_array *arr; zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; zval *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct &#123; uint32_t w1; uint32_t w2; &#125; ww;&#125; zend_value; 从 zend__value 中可以看出，long、double 类型直接存储值，而其它类型都为指针，指向各自的结构。所以，由于 zval 这样的结构，PHP 变量在声明的时候不用显示的指定其类型，因为不管你赋给变量什么类型的值，它都能帮你找到对应的存储结构。 以值为字符串的变量为例，其结构是这样的： PHP5 与 PHP7 的 zval 结构对比 PHP5 PHP7 可以看到 php7 的 zval 总的只占 16 个字节，相比 PHP5 的 zval 所占用的 48 个字节节省了很大的内存。 此外，在 PHP5 中，所有的变量都在堆中申请，但是对于临时变量来说，没有必要在堆中申请。所以在 PHP7 中对此做了优化，临时变量是直接在栈中申请的。 常见变量类型下面介绍几个常见类型的变量结构，其他更多的类型，可自行查看源码。 整型和浮点型对于整型和浮点型，由于其占用空间小，在 zval 中是直接存储的 整型的值是存在 lval 里，浮点型值则是存储在 dval 里。 12345typedef union _zend_value &#123; zend_long lval; /* 整型*/ double dval; /* 浮点型 */ ... &#125; 字符串PHP 7 中定义了新的字符串结构体。结构如下： 123456struct _zend_string &#123; zend_refcounted_h ; zend_ulong h; /* hash value */ size_t len; char val[1];&#125;; 上面各个字段的意思： gc： 变量引用信息，所有用到引用计数的变量类型都会有这个结构。 h： 哈希值，数组中计算索引时会用到。（据说这个操作为 PHP7 提高了 5% 的性能） len： 字符串长度，通过这个值保证二进制安全 val： 字符串内容，变长struct，分配时按len长度申请内存数组 array 是 PHP 中非常强大的一个数据结构，它的底层实现就是普通的有序HashTable，这里简单看下它的结构。后续再具体深入。 123456789101112131415161718192021222324typedef struct _zend_array HashTable;struct _zend_array &#123; zend_refcounted_h gc; union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar flags, zend_uchar nApplyCount, zend_uchar nIteratorsCount, zend_uchar consistency) &#125; v; uint32_t flags; &#125; u; uint32_t nTableMask; Bucket *arData; uint32_t nNumUsed; uint32_t nNumOfElements; uint32_t nTableSize; uint32_t nInternalPointer; zend_long nNextFreeElement; dtor_func_t pDestructor;&#125; ###对象 PHP7 的对象结构也是重新设计了，和 PHP5 的实现有了很大的不同。 12345678struct _zend_object &#123; zend_refcounted_h gc; uint32_t handle; zend_class_entry *ce; const zend_object_handlers *handlers; HashTable *properties; zval properties_table[1];&#125;; 这里介绍下其中几个字段： gc：gc头部 *ce：对象对应的 class 类 *properties ：HashTable结构，key 为对象的属性名，value 是属性值在properties_tables数组中的偏移量，通过偏移量在 properties_talbe 找到对应的属性值。 properties_talbe[1]：存储对象的属性值 ok，先写这到这里。 参考资料 《PHP7 底层设计与源码实现》","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"底层","slug":"底层","permalink":"http://www.tenpercent.top/tags/底层/"}]},{"title":"浅析 PHP7 底层运行机制","date":"2019-08-08T16:00:00.000Z","path":"2019/08/09/PHP-internal-learning/","text":"PHP7 代码执行过程PHP 是解释型语言，其执行过程需先编译成中间代码，再经由特定的虚拟机，翻译成特定的指令被执行。其执行过程如下： 1PHP 代码 =&gt; Token =&gt; 抽象语法树 =&gt; Opcodes =&gt; 执行 各个步骤内容如下： 源代码通过词法分析得到 Token Token 是 PHP 代码被切割成的有意义的标识。PHP7 一共有 137 种 Token，在zend_language_parser.h 文件中做了定义。 基于语法分析器将 Token 转换成抽象语法树（AST） Token 就是一个个的词块，但是单独的词块不能表达完整的语义，还需要借助一定的规则进行组织串联。所以就需要语法分析器根据语法匹配Token，将 Token 进行串联。语法分析器串联完 Token 后的产物就是抽象语法树（AST，Abstract Syntax Tree）。AST 是 PHP7 版本的新特性，之前版本的 PHP 代码的执行过程中是没有生成 AST 这一步的。它的作用主要是实现了PHP编译器和解释器的解耦，提升了可维护性。 将语法树转换成 Opcode 需要将语法树转换成Opcode，才能被引擎直接执行。 执行 Opcodes opcodes 是 opcode 的集合形式，是 PHP 执行过程中的中间代码。PHP工程优化措施中有一个比较常见的“开启 opcache”，指的技术这里将 opcodes 进行缓存。通过省去从源码到 opcode 的阶段，引擎直接执行缓存好的 opacode，以提升性能。 PHP7 内核架构 要把这张图印在脑海里 zend引擎 词法/语法分析、AST编译和 opcodes 的执行均在 Zend 引擎中实现。此外，PHP的变量设计、内存管理、进程管理等也在引擎层实现。 PHP层 zend 引擎为 PHP 提供基础能力，而来自外部的交互则需要通过 PHP 层来处理。 SAPI server API 的缩写，其中包含了场景的 cli SAPI 和 fpm SAPI。只要遵守定义好的 SAPI 协议，外部模块便可与PHP完成交互。 扩展部分 依据 zend 引擎提供的核心能力和接口规范，可以进行开发扩展。 PHP 7 源码结构php 7 的源码主要目录有：sapi 、Zend、main、ext 和 TSRM 这几个。 sapi目录 sapi目录是对输入和输出层的抽象，是PHP提供对外服务的规范。 几种常用的 SAPI： 1）apache2handler: Apache 扩展，编译后生成动态链接库，配置到Apache下。当有 http 请求到 Apache 时，根据配置会调用此动态链接库来执行PHP代码，完成与PHP的交互。 2）cgi-fcgi: 编译后生成支持 CGI 协议的可执行程序，webserver（如NGINX）通过 CGI 协议把请求传给CGI进程，CGI 进程根据请求执行相应代码后将执行结果返回给 webserver。 3）fpm-fcgi: fpm是 FastCGI 进程管理器。以 NGINX 服务器为例，当有请求发送到 NGINX 服务器，NGINX 按照 FastCGI 协议把请求交给 php-fpm 进程处理。 4）cli: PHP的命令行交互接口 Zend 目录 Zend 目录是 PHP 的核心代码。PHP中的内存管理，垃圾回收、进程管理、变量、数组实现等均在该目录的源码里。 main 目录 main目录是SAPI层和Zend层的黏合剂。Zend 层实现了 PHP 脚本的编译和执行，sapi 层实现了输入和输出的抽象，main目录则在它们中间起着承上启下的作用。承上，解析 SAPI 的请求，分析要执行的脚本文件和参数；启下，调用 zend 引擎之前，完成必要的模块初始化等工作。 ext目录 ext 是 PHP 扩展相关的目录，常用的 array、str、pdo 等系列函数都在这里定义。 TSRM TSRM（Thread Safe Resource Manager）——线程安全资源管理器， 是用来保证资源共享的安全。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"底层","slug":"底层","permalink":"http://www.tenpercent.top/tags/底层/"}]},{"title":"深入 Nginx 之配置篇","date":"2019-02-14T16:00:00.000Z","path":"2019/02/15/learn-nginx-configuration/","text":"常用配置项在工作中，我们与 Nginx 打交道更多的是通过其配置文件来进行。那么掌握这些配置项各自的作用就很有必要了。 首先，nginx.conf 的内容通常是这样的： 12345678910111213141516171819202122232425262728293031323334... ... #核心摸块events &#123; #事件模块 ...&#125;http &#123; # http 模块 server &#123; # server块 location [PATTERN] &#123; # location块 ... &#125; location [PATTERN] &#123; ... &#125; &#125; server &#123; ... &#125; &#125;mail &#123; # mail 模块 server &#123; # server块 ... &#125;&#125; 我们依次看一下每个模块一般有哪些配置项： 核心模块1234567user admin; #配置用户或者组。worker_processes 4; #允许生成的进程数，默认为1 pid /nginx/pid/nginx.pid; #指定 nginx 进程运行文件存放地址 error_log log/error.log debug; #错误日志路径，级别。 事件模块123456789events &#123; accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off use epoll; #事件驱动模型select|poll|kqueue|epoll|resig worker_connections 1024; #最大连接数，默认为512&#125; http 模块1234567891011121314151617181920212223242526272829303132333435363738http &#123; include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型，默认为text/plain access_log off; #取消服务日志 sendfile on; #允许 sendfile 方式传输文件，默认为off，可以在http块，server块，location块。 sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 keepalive_timeout 65; #连接超时时间，默认为75s，可以在http，server，location块。 server &#123; keepalive_requests 120; #单连接请求上限次数。 listen 80; #监听端口 server_name 127.0.0.1; #监听地址 index index.html index.htm index.php; root your_path; #根目录 location ~ \\.php$ &#123; fastcgi_pass unix:/var/run/php/php7.1-fpm.sock; #fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; &#125; &#125;&#125; 配置项解析 worker_processes worker_processes 用来设置 Nginx 服务的进程数。该值推荐使用 CPU 内核数。 worker_cpu_affinity worker_cpu_affinity 用来为每个进程分配CPU的工作内核，参数有多个二进制值表示，每一组代表一个进程，每组中的每一位代表该进程使用CPU的情况，1代表使用，0代表不使用。所以我们使用 worker_cpu_affinity 0001 0010 0100 1000;来让进程分别绑定不同的核上。默认情况下worker进程不绑定在任何一个CPU上。 worker_rlimit_nofile 设置毎个进程的最大文件打开数。如果不设的话上限就是系统的 ulimit –n的数字，一般为65535。 worker_connections 设置一个进程理论允许的最大连接数，理论上越大越好，但不可以超过 worker_rlimit_nofile 的值。 use epoll 设置事件驱动模型使用 epoll。epoll 是 Nginx 支持的高性能事件驱动库之一。是公认的非 常优秀的事件驱动模型。 accept_mutex off 关闭网络连接序列化，当其设置为开启的时候，将会对多个 Nginx 进程接受连接进行序列化，防止多个进程对连接的争抢。当服务器连接数不多时，开启这个参数会让负载有一定程度的降低。但是当服务器的吞吐量很大时，为了效率，请关闭这个参数；并且关闭这个参数的时候也可以让请求在多个 worker 间的分配更均衡。所以我们设置 accept_mutex off; multi_accept on 设置一个进程可同时接受多个网络连接 Sendfile on Sendfile是 Linux2.0 以后的推出的一个系统调用,它能简化网络传输过程中的步骤，提高服务器性能。不用 sendfile的传统网络传输过程：硬盘 &gt;&gt; kernel buffer &gt;&gt; user buffer &gt;&gt; kernel socket buffer &gt;&gt; 协议栈 用 sendfile()来进行网络传输的过程：硬盘 &gt;&gt; kernel buffer (快速拷贝到 kernelsocket buffer) &gt;&gt; 协议栈 tcp_nopush on 设置数据包会累积一下再一起传输，可以提高一些传输效率。 tcp_nopush 必须和 sendfile 搭配使用。 tcp_nodelay on 小的数据包不等待直接传输。默认为on。看上去是和 tcp_nopush 相反的功能，但是两边都为 on 时 nginx 也可以平衡这两个功能的使用。 keepalive_timeout HTTP 连接的持续时间。设的太长会使无用的线程变的太多。这个根据服务器访问数量、处理速度以及网络状况方面考虑。 send_timeout 设置 Nginx 服务器响应客户端的超时时间，这个超时时间只针对两个客户端和服务器建立连接后，某次活动之间的时间，如果这个时间后，客户端没有任何活动，Nginx服务器将关闭连接 gzip on 启用 gzip，对响应数据进行在线实时压缩,减少数据传输量。 gzip_disable “msie6” Nginx服务器在响应这些种类的客户端请求时，不使用 Gzip 功能缓存应用数据，gzip_disable “msie6”对IE6浏览器的数据不进行 GZIP 压缩。 常用的配置项大致这些，对于不同的业务场景，有的需要额外的其他配置项，这里不做展开。 其他http 配置里有 location 这一项，它是用来根据请求中的 uri 来为其匹配相应的处理规则。 location 查找规则1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950location = / &#123; # 精确匹配 / ，主机名后面不能带任何字符串 [ config A ]&#125;location / &#123; # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求 # 但是正则和最长字符串会优先匹配 [ config B ]&#125;location /documents/ &#123; # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ config C ]&#125;location ~ /documents/Abc &#123; # 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ config CC ]&#125;location ^~ /images/ &#123; # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。 [ config D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; # 匹配所有以 gif,jpg或jpeg 结尾的请求 # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则 [ config E ]&#125;location /images/ &#123; # 字符匹配到 /images/，继续往下，会发现 ^~ 存在 [ config F ]&#125;location /images/abc &#123; # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在 # F与G的放置顺序是没有关系的 [ config G ]&#125;location ~ /images/abc/ &#123; # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用 [ config H ]&#125; 正则查找优先级从高到低依次如下： “ = ” 开头表示精确匹配，如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。 “ ^~ ” 开头表示uri以某个常规字符串开头，不是正则匹配 “ ~ ” 开头表示区分大小写的正则匹配; “ ~* ”开头表示不区分大小写的正则匹配 “ / ” 通用匹配, 如果没有其它匹配,任何请求都会匹配到 负载均衡配置Nginx 的负载均衡需要用到 upstream 模块，可通过以下配置来实现： 1234567891011121314upstream test-upstream &#123; ip_hash; # 使用 ip_hash 算法分配 server 192.168.1.1; # 要分配的 ip server 192.168.1.2;&#125;server &#123; location / &#123; proxy_pass http://test-upstream; &#125; &#125; 上面的例子定义了一个 test-upstream 的负载均衡配置，通过 proxy_pass 反向代理指令将请求转发给该模块进行分配处理。","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.tenpercent.top/tags/Nginx/"},{"name":"配置","slug":"配置","permalink":"http://www.tenpercent.top/tags/配置/"}]},{"title":"深入 Nginx 之架构篇","date":"2019-01-17T16:00:00.000Z","path":"2019/01/18/depth-nginx/","text":"前言最近在读 Nginx 相关的书籍，做一下读书笔记。 Nginx 作为业界知名的高性能服务器，被广泛的应用。它的高性能正是由于其优秀的架构设计，其架构主要包括这几点：模块化设计、事件驱动架构、请求的多阶段异步处理、管理进程与多工作进程设计、内存池的设计，以下内容依次进行说明。 模块化设计高度模块化的设计是 Nginx 的架构基础。在 Nginx 中，除了少量的核心代码，其他一切皆为模块。 所有模块间是分层次、分类别的，Nginx 官方共有五大类型的模块：核心模块、配置模块、事件模块、HTTP 模块、mail 模块。它们之间的关系如下： 在这 5 种模块中，配置模块和核心模块是与 Nginx 框架密切相关的。而事件模块则是 HTTP 模块和 mail 模块的基础。HTTP 模块和 mail 模块的“地位”类似，它们都是更关注于应用层面。 事件驱动架构事件驱动架构，简单的说就是由一些事件发生源来产生事件，由事件收集器来收集、分发事件，然后由事件处理器来处理这些事件（事件处理器需要先在事件收集器里注册自己想处理的事件）。 对于 Nginx 服务器而言，一般由网卡、磁盘产生事件，Nginx 中的事件模块将负责事件的收集、分发操作；而所有的模块都可能是事件消费者，它们首先需要向事件模块注册感兴趣的事件类型，这样，在有事件产生时，事件模块会把事件分发到相应的模块中进行处理。 对于传统 web 服务器（如 Apache）而言，采用的所谓事件驱动往往局限在 TCP 连接建立、关闭事件上，一个连接建立以后，在其关闭之前的所有操作都不再是事件驱动，这时会退化成按顺序执行每个操作的批处理模式，这样每个请求在连接建立后都将始终占用着系统资源，直到关闭才会释放资源。这种请求占用着服务器资源等待处理的模式会造成服务器资源极大的浪费。如下图所示，传统 web 服务器往往把一个进程或线程作为时间消费者，当一个请求产生的事件被该进程处理时，直到这个请求处理结束时，进程资源都将被这一请求所占用。比较典型的例子如 Apache 同步阻塞的多进程模式就是这样的。 传统 web 服务器处理事件的简单模型（矩形代表进程）: Nginx 采用事件驱动架构处理业务的方式与传统的 web 服务器是不同的。它不使用进程或者线程来作为事件消费者，所谓的事件消费者只能是某个模块。只有事件收集、分发器才有资格占用进程资源，它们会在分发某个事件时调用事件消费模块使用当前占用的进程资源，如下图所示，该图中列出了 5 个不同的事件，在事件收集、分发者进程的一次处理过程中，这 5 个事件按照顺序被收集后，将开始使用当前进程分发事件，从而调用相应的事件消费者来处理事件。当然，这种分发、调用也是有序的。 Nginx 处理事件的简单模型： 由上图可以看出，处理请求事件时，Nginx 的事件消费者只是被事件分发者进程短期调用而已，这种设计使得网络性能、用户感知的请求时延都得到了提升，每个用户的请求所产生的事件会及时响应，整个服务器的网络吞吐量都会由于事件的及时响应而增大。当然，这也带来一定的要求，即每个事件消费者都不能有阻塞行为，否则将会由于长时间占用事件分发者进程而导致其他事件得不到及时响应，Nginx 的非阻塞特性就是由于它的模块都是满足这个要求的。 请求的多阶段异步处理多阶段异步处理请求与事件驱动架构是密切相关的，也就是说，请求的多阶段异步处理只能基于事件驱动架构实现。多阶段异步处理就是把一个请求的处理过程按照事件的触发方式划分为多个阶段，每个阶段都可以由事件收集、分发器来触发。 处理获取静态文件的 HTTP 请求时切分的阶段及各阶段的触发事件如下所示： 这个例子中，该请求大致分为 7 个阶段，这些阶段是可以重复发生的，因此，一个下载静态资源请求可能会由于请求数据过大，网速不稳定等因素而被分解为成百上千个上图所列出的阶段。 异步处理和多阶段是相辅相成的，只有把请求分为多个阶段，才有所谓的异步处理。当一个时间被分发到事件消费者中进行处理时，事件消费者处理完这个事件只相当于处理完 1 个请求的阶段。什么时候可以处理下一个阶段呢？这只能等待内核的通知，即当下一次事件出现时，epoll 等事件分发器将会获取到通知，然后去调用事件消费者进行处理。 管理进程、多工作进程设计Nginx 在启动后，会有一个 master 进程和多个 worker 进程。master 进程主要用来管理worker 进程，包括接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态以及启动 worker 进程。 worker 进程是用来处理来自客户端的请求事件。多个 worker 进程之间是对等的，它们同等竞争来自客户端的请求，各进程互相独立，一个请求只能在一个 worker 进程中处理。worker 进程的个数是可以设置的，一般会设置与机器 CPU 核数一致，这里面的原因与事件处理模型有关。Nginx 的进程模型，可由下图来表示： 在服务器上查看 Nginx 进程： 这种设计带来以下优点： 1） 利用多核系统的并发处理能力 现代操作系统已经支持多核 CPU 架构，这使得多个进程可以分别占用不同的 CPU 核心来工作。Nginx 中所有的 worker 工作进程都是完全平等的。这提高了网络性能、降低了请求的时延。 2） 负载均衡 多个 worker 工作进程通过进程间通信来实现负载均衡，即一个请求到来时更容易被分配到负载较轻的 worker 工作进程中处理。这也在一定程度上提高了网络性能、降低了请求的时延。 3） 管理进程会负责监控工作进程的状态，并负责管理其行为 管理进程不会占用多少系统资源，它只是用来启动、停止、监控或使用其他行为来控制工作进程。首先，这提高了系统的可靠性，当 worker 进程出现问题时，管理进程可以启动新的工作进程来避免系统性能的下降。其次，管理进程支持 Nginx 服务运行中的程序升级、配置项修改等操作，这种设计使得动态可扩展性、动态定制性较容易实现。 内存池的设计为了避免出现内存碎片，减少向操作系统申请内存的次数、降低各个模块的开发复杂度，Nginx 设计了简单的内存池，它的作用主要是把多次向系统申请内存的操作整合成一次，这大大减少了 CPU 资源的消耗，同时减少了内存碎片。 因此，通常每一个请求都有一个简易的独立内存池（如每个 TCP 连接都分配了一个内存池），而在请求结束时则会销毁整个内存池，把曾经分配的内存一次性归还给操作系统。这种设计大大提高了模块开发的简单些，因为在模块申请内存后不用关心它的释放问题；而且因为分配内存次数的减少使得请求执行的时延得到了降低。同时，通过减少内存碎片，提高了内存的有效利用率和系统可处理的并发连接数，从而增强了网络性能。","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.tenpercent.top/tags/Nginx/"},{"name":"架构","slug":"架构","permalink":"http://www.tenpercent.top/tags/架构/"}]},{"title":"PHP-FPM 与 Nginx 的通信机制总结","date":"2018-12-20T16:00:00.000Z","path":"2018/12/21/php-fpm and nginx /","text":"PHP-FPM 介绍CGI 协议与 FastCGI 协议每种动态语言（ PHP,Python 等）的代码文件需要通过对应的解析器才能被服务器识别，而 CGI 协议就是用来使解释器与服务器可以互相通信。PHP 文件在服务器上的解析需要用到 PHP 解释器，再加上对应的 CGI 协议，从而使服务器可以解析到 PHP 文件。 由于 CGI 的机制是每处理一个请求需要 fork 一个 CGI 进程，请求结束再kill掉这个进程，在实际应用上比较浪费资源，于是就出现了CGI 的改良版本 FastCGI，FastCGI 在请求处理完后，不会 kill 掉进程，而是继续处理多个请求，这样就大大提高了效率。 PHP-FPM 是什么PHP-FPM 即 PHP-FastCGI Process Manager， 它是 FastCGI 的实现，并提供了进程管理的功能。进程包含 master 进程和 worker 进程两种；master 进程只有一个，负责监听端口，接收来自服务器的请求，而 worker 进程则一般有多个（具体数量根据实际需要进行配置），每个进程内部都会嵌入一个 PHP 解释器，是代码真正执行的地方。 Nginx 与 php-fpm 通信机制当我们访问一个网站（如 www.test.com）的时候，处理流程是这样的： 12345678910111213141516171819 www.test.com | | Nginx | |路由到 www.test.com/index.php | |加载 nginx 的 fast-cgi 模块 | |fast-cgi 监听 127.0.0.1:9000 地址 | |www.test.com/index.php 请求到达 127.0.0.1:9000 | | 等待处理... Nginx 与 php-fpm 的结合在 Linux 上，nginx 与 php-fpm 的通信有 tcp socket 和 unix socket 两种方式。 tcp socket 的优点是可以跨服务器，当 nginx 和 php-fpm 不在同一台机器上时，只能使用这种方式。 Unix socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信，这种方式需要在 nginx配置文件中填写 php-fpm 的 socket 文件位置。 两种方式的数据传输过程如下图所示： 二者的不同： 由于 Unix socket 不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。所以其效率比 tcp socket 的方式要高，可减少不必要的 tcp 开销。不过，unix socket 高并发时不稳定，连接数爆发时，会产生大量的长时缓存，在没有面向连接协议的支撑下，大数据包可能会直接出错不返回异常。而 tcp 这样的面向连接的协议，可以更好的保证通信的正确性和完整性。 Nginx 与 php-fpm 结合只需要在各自的配置文件中做设置即可： 1） Nginx 中的配置 以 tcp socket通信为例 12345678910111213141516171819server &#123; listen 80; #监听 80 端口，接收http请求 server_name www.test.com; #就是网站地址 root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径 #路由到网站根目录 www.test.com 时候的处理 location / &#123; index index.php; #跳转到 www.test.com/index.php autoindex on; &#125; #当请求网站下 php 文件的时候，反向代理到 php-fpm location ~ \\.php$ &#123; include /usr/local/etc/nginx/fastcgi.conf; #加载 nginx 的 fastcgi 模块 fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; # tcp 方式，php-fpm 监听的 IP 地址和端口 # fasrcgi_pass /usr/run/php-fpm.sock # unix socket 连接方式 &#125;&#125; 2) php-fpm 的配置 123listen = 127.0.0.1:9000# 或者下面这样listen = /var/run/php-fpm.sock 注意，在使用 unix socket 方式连接时，由于 socket 文件本质上是一个文件，存在权限控制的问题，所以需要注意 nginx 进程的权限与 php-fpm 的权限问题，不然会提示无权限访问。（在各自的配置文件里设置用户） 通过以上配置即可完成 php-fpm 与 nginx 的通信。 在应用中的选择如果是在同一台服务器上运行的 nginx 和 php-fpm，且并发量不高（不超过1000），选择unix socket，以提高 nginx 和 php-fpm 的通信效率。如果是面临高并发业务，则考虑选择使用更可靠的 tcp socket，以负载均衡、内核优化等运维手段维持效率。 若并发较高但仍想用 unix socket 时，可通过以下方式提高 unix socket 的稳定性。 1）将sock文件放在 /dev/shm 目录下，此目录下将 sock 文件放在内存里面，内存的读写更快。 2）提高 backlog backlog 默认位 128，1024 这个值最好换算成自己正常的 QPS，配置如下。 nginx.conf 文件中 123server &#123; listen 80 default backlog = 1024; &#125; php-fpm.conf 文件中 1listen.backlog = 1024 3）增加 sock 文件和 php-fpm 实例 在 /dev/shm 新建一个 sock 文件，在 nginx 中通过 upstream 模块将请求负载均衡到两个 sock 文件，并且将两个 sock 文件分别对应到两套 php-fpm 实例上。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"Nginx","slug":"Nginx","permalink":"http://www.tenpercent.top/tags/Nginx/"},{"name":"PHP-FPM","slug":"PHP-FPM","permalink":"http://www.tenpercent.top/tags/PHP-FPM/"}]},{"title":"Linux 性能监控工具","date":"2018-07-09T16:00:00.000Z","path":"2018/07/10/Linux-performance-monitor/","text":"最近了解了下 Linux 性能相关的东西，主要是如何查看服务器性能的一些工具，在这里做个记录，以后遇到相关使用场景的时候，方便查看。 Linux 性能指标 CPU CPU利用率、用户时间（表示CPU在用户进程上的时间百分比）、系统时间（表示CPU花在内核操作上的时间百分比）、空闲时间、平均负载、阻塞、上下文切换、中断等 内存 空闲内存、Swap利用率、缓冲和缓存、活动和非活动内存等 磁盘IO IO等待、平均队列长度、每秒传输（TPS）等 网络 接收和发送的包、每秒碰撞（各个网络接口所连接网络的所发生的冲突数量）、丢包、错误等 监测工具以下是对 Linux 的性能进行监控的常用工具： 工具 简介 top 查看进程活动状态以及一些系统状况 vmstat 查看系统状态、硬件和系统信息等 iostat 查看 CPU 负载、硬盘状况 sar 综合工具，查看系统状况 mpstat 查看多处理器状况 netstat 查看网络状况 iptraf 实时网络状态监测 tcpdump 抓取网络数据包，详细分析 tcptrace 网络包分析工具 netperf 网络带宽工具 dstat 综合了 vmstat、iostat、ifstat、netstat 等多个信息 这里介绍其中几个。 top 工具top是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。 PID：进程的ID USER：进程所有者 PR：进程的优先级别，越小越优先被执行 NI：nice值 VIRT：进程占用的虚拟内存 RES：进程占用的物理内存 SHR：进程使用的共享内存 S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数 %CPU：进程占用CPU的使用率 %MEM：进程使用的物理内存和总内存的百分比 TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。 COMMAND：进程启动命令名称 vmstat 工具vmstat 是个查看系统整体性能的小工具，小巧，即使在机器负载很高的情况下也运行良好，并且可以用时间间隔采集得到连续的性能数据。 参数介绍： r，可运行队列的线程数，这些线程都是可运行状态，只不过 CPU 暂时不可用 b，被 blocked 的进程数，正在等待 IO 请求 in，被处理过的中断数 cs，系统上正在做上下文切换的数目 us，用户占用 CPU 的百分比 sys，内核和中断占用 CPU 的百分比 wa，所有可运行的线程被 blocked 以后都在等待 IO，这时候 CPU 空闲的百分比 id，CPU 完全空闲的百分比 举两个例子来分析一下 12345678$ vmstat 1procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------ r b swpd free buff cache si so bi bo in cs us sy id wa st 4 0 140 2915476 341288 3951700 0 0 0 0 1057 523 89 21 0 0 0 4 0 140 2915724 341296 3951700 0 0 0 0 1048 546 79 11 0 0 0 4 0 140 2915848 341296 3951700 0 0 0 0 1044 514 88 22 0 0 0 4 0 140 2915848 341296 3951700 0 0 0 24 1044 564 80 20 0 0 0 4 0 140 2915848 341296 3951700 0 0 0 0 1060 546 78 12 0 0 0 从上面的数据可以看出几点： interrupts(in) 非常高，context switch(cs) 比较低，说明这个 CPU 一直在不停的请求资源 user time(us) 一直保持在 80% 以上，而且上下文切换较低 (cs)，说明某个进程可能一直霸占着 CPU run queue(r) 刚好在 4 个 12345678$ vmstat 1procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------ r b swpd free buff cache si so bi bo in cs us sy id wa st14 0 140 2904316 341912 3952308 0 0 0 460 1106 9593 36 64 1 0 017 0 140 2903492 341912 3951780 0 0 0 0 1037 9614 35 65 1 0 020 0 140 2902016 341912 3952000 0 0 0 0 1046 9739 35 64 1 0 017 0 140 2903904 341912 3951888 0 0 0 76 1044 9879 37 63 0 0 016 0 140 2904580 341912 3952108 0 0 0 0 1055 9808 34 65 1 0 0 从上面的数据可以看出几点： context switch(cs) 比 interrupts(in) 要高的多，说明内核不得不来回切换进程 进一步观察发现 system time(sy) 很高而 user time(us) 很低，而且加上高频度的上下文切换 (cs)，说明正在运行的应用程序调用了大量的系统调用 run queue(r) 在 14 个线程以上，而这个机器的硬件配置 (4 核），应该保持在 12 以内。 iostat 工具iostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。iostat属于sysstat软件包。可以用yum install sysstat 直接安装。 cpu属性值说明： %user：CPU处在用户模式下的时间百分比。 %nice：CPU处在带NICE值的用户模式下的时间百分比。 %system：CPU处在系统模式下的时间百分比。 %iowait：CPU等待输入输出完成时间的百分比。 %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。 %idle：CPU空闲时间百分比。 如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。 disk属性值说明： rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/s wrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/s r/s: 每秒完成的读 I/O 设备次数。即 rio/s w/s: 每秒完成的写 I/O 设备次数。即 wio/s rsec/s: 每秒读扇区数。即 rsect/s wsec/s: 每秒写扇区数。即 wsect/s rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。 wkB/s: 每秒写K字节数。是 wsect/s 的一半。 avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。 avgqu-sz: 平均I/O队列长度。 await: 平均每次设备I/O操作的等待时间 (毫秒)。 svctm: 平均每次设备I/O操作的服务时间 (毫秒)。 %util: 一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比 如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。 如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间； 如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。 如果avgqu-sz比较大，也表示有大量io在等待。 sar 工具 sar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。 查看 cpu使用率 sar -u %user 用户模式下消耗的CPU时间的比例； %nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例 %system 系统模式下消耗的CPU时间的比例； %iowait CPU等待磁盘I/O导致空闲状态消耗的时间比例； %steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例； %idle CPU空闲时间比例； 查看平均负载 sar -q runq-sz：运行队列的长度（等待运行的进程数） plist-sz：进程列表中进程（processes）和线程（threads）的数量 ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载 ldavg-15：过去15分钟的系统平均负载 查看内存使用状况 sar -r kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间. kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间. %memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比. kbbuffers和kbcached：这两个值就是free命令中的buffer和cache. kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap). %commit：这个值是kbcommit与内存总量(包括swap)的一个百分比. sar参数说明 -A 汇总所有的报告 -a 报告文件读写使用情况 -B 报告附加的缓存的使用情况 -b 报告缓存的使用情况 -c 报告系统调用的使用情况 -d 报告磁盘的使用情况 -g 报告串口的使用情况 -h 报告关于buffer使用的统计数据 -m 报告IPC消息队列和信号量的使用情况 -n 报告命名cache的使用情况 -p 报告调页活动的使用情况 -q 报告运行队列和交换队列的平均长度 -R 报告进程的活动情况 -r 报告没有使用的内存页面和硬盘块 -u 报告CPU的利用率 -v 报告进程、i节点、文件和锁表状态 -w 报告系统交换活动状况 -y 报告TTY设备活动状况","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.tenpercent.top/tags/Linux/"},{"name":"工具","slug":"工具","permalink":"http://www.tenpercent.top/tags/工具/"}]},{"title":"深入解析 composer 的自动加载原理","date":"2018-05-16T16:00:00.000Z","path":"2018/05/17/composer-autoload/","text":"前言PHP 自5.3的版本之后，已经重焕新生，命名空间、性状（trait）、闭包、接口、PSR 规范、以及 composer 的出现已经让 PHP 变成了一门现代化的脚本语言。PHP 的生态系统也一直在演进，而 composer 的出现更是彻底的改变了以往构建 PHP 应用的方式，我们可以根据 PHP 的应用需求混合搭配最合适的 PHP 组件。当然这也得益于 PSR 规范的提出。 掌握 composer 自动加载原理的好处 更好的运用 composer 来构建我们的 PHP 应用程序 对 PSR 规范有进一步的了解 当需要用到没有 composer 化的第三方库时，可以将其 composer 化来提高工程效率 学习比较严谨、高深的编码技巧 大纲 PHP 自动加载功能 PSR 规范 comoposer 的自动加载过程 composer 源码分析 一、PHP 自动加载功能PHP 自动加载功能的由来在 PHP 开发过程中，如果希望从外部引入一个 Class ，通常会使用 include 和 require 方法，去把定义这个 Class 的文件包含进来。这个在小规模开发的时候，没什么大问题。但在大型的开发项目中，使用这种方式会带来一些隐含的问题：如果一个 PHP 文件需要使用很多其它类，那么就需要很多的 require/include 语句，这样有可能会 造成遗漏 或者 包含进不必要的类文件。如果大量的文件都需要使用其它的类，那么要保证每个文件都包含正确的类文件肯定是一个噩梦， 况且 require或 incloud 的性能代价很大。 PHP5 为这个问题提供了一个解决方案，这就是 类的自动加载(autoload)机制。autoload机制 可以使得 PHP 程序有可能在使用类时才自动包含类文件，而不是一开始就将所有的类文件include进来，这种机制也称为 Lazy loading (惰性加载)。 总结起来，自动加载功能带来了几处优点： 使用类之前无需 include / require 使用类的时候才会 include / require 文件，实现了 lazy loading ，避免了 include / require 多余文件。 无需考虑引入 类的实际磁盘地址 ，实现了逻辑和实体文件的分离。 PHP 自动加载函数 __autoload() 通常 PHP5 在使用一个类时，如果发现这个类没有加载，就会自动运行 __autoload() 函数，这个函数是我们在程序中自定义的，在这个函数中我们可以加载需要使用的类。下面是个简单的示例： 12345&lt;?phpfunction __autoload($classname) &#123; require_once ($classname . \".class.php\");&#125; 在我们这个简单的例子中，我们直接将类名加上扩展名 .class.php 构成了类文件名，然后使用 require_once 将其加载。 从这个例子中，我们可以看出 __autoload 至少要做三件事情： 根据类名确定类文件名； 确定类文件所在的磁盘路径； 将类从磁盘文件中加载到系统中。 第三步最简单，只需要使用 include / require 即可。要实现第一步，第二步的功能，必须在开发时约定类名与磁盘文件的映射方法，只有这样我们才能根据类名找到它对应的磁盘文件。 当有大量的类文件要包含的时候，我们只要确定相应的规则，然后在 __autoload() 函数中，将类名与实际的磁盘文件对应起来，就可以实现 lazy loading 的效果 。 如果想详细的了解关于 autoload 自动加载的过程，可以查看手册资料：PHP autoload函数说明 __autoload() 函数存在的问题 如果在一个系统的实现中，如果需要使用很多其它的类库，这些类库可能是由不同的开发人员编写的， 其类名与实际的磁盘文件的映射规则不尽相同。这时如果要实现类库文件的自动加载，就必须 在 __autoload() 函数中将所有的映射规则全部实现，这样的话 __autoload() 函数有可能会非常复杂，甚至无法实现。最后可能会导致 __autoload() 函数十分臃肿，这时即便能够实现，也会给将来的维护和系统效率带来很大的负面影响。 那么问题出现在哪里呢？问题出现在 __autoload() 是全局函数只能定义一次 ，不够灵活，所以所有的类名与文件名对应的逻辑规则都要在一个函数里面实现，造成这个函数的臃肿。那么如何来解决这个问题呢？答案就是使用一个 __autoload调用堆栈 ，不同的映射关系写到不同的 __autoload函数 中去，然后统一注册统一管理，这个就是 PHP5 引入的 SPL Autoload 。 SPL Autoload SPL是 Standard PHP Library(标准PHP库)的缩写。它是 PHP5 引入的一个扩展标准库，包括 spl autoload 相关的函数以及各种数据结构和迭代器的接口或类。spl autoload 相关的函数具体可见 php中spl_autoload 123456789101112131415161718192021222324252627282930313233343536&lt;?php// __autoload 函数//// function __autoload($class) &#123;// include 'classes/' . $class . '.class.php';// &#125;function my_autoloader($class) &#123; include 'classes/' . $class . '.class.php';&#125;spl_autoload_register('my_autoloader');// 定义的 autoload 函数在 class 里// 静态方法class MyClass &#123; public static function autoload($className) &#123; // ... &#125;&#125;spl_autoload_register(array('MyClass', 'autoload'));// 非静态方法class MyClass &#123; public function autoload($className) &#123; // ... &#125;&#125;$instance = new MyClass();spl_autoload_register(array($instance, 'autoload')); spl_autoload_register() 就是我们上面所说的__autoload调用堆栈，我们可以向这个函数注册多个我们自己的 autoload() 函数，当 PHP 找不到类名时，PHP就会调用这个堆栈，然后去调用自定义的 autoload() 函数，实现自动加载功能。如果我们不向这个函数输入任何参数，那么就会默认注册 spl_autoload() 函数。 二、PSR 规范与自动加载相关的规范是 PSR4，在说 PSR4 之前先介绍一下PSR标准。PSR 标准的发明和推出组织是：PHP-FIG，它的网站是：www.php-fig.org。由几位开源框架的开发者成立于 2009 年，从那开始也选取了很多其他成员进来，虽然不是 “官方” 组织，但也代表了社区中不小的一块。组织的目的在于：以最低程度的限制，来统一各个项目的编码规范，避免各家自行发展的风格阻碍了程序员开发的困扰，于是大伙发明和总结了 PSR，PSR是 PHP Standards Recommendation 的缩写，截止到目前为止，总共有 14 套 PSR 规范，其中有 7 套PSR规范已通过表决并推出使用，分别是： PSR-0 自动加载标准（已废弃，一些旧的第三方库还有在使用） PSR-1 基础编码标准 PSR-2 编码风格向导 PSR-3 日志接口 PSR-4 自动加载的增强版，替换掉了 PSR-0 PSR-6 缓存接口规范 PSR-7 HTTP 消息接口规范 具体详细的规范标准可以查看PHP 标准规范 PSR4 标准2013 年底，PHP-FIG 推出了第 5 个规范——PSR-4。 PSR-4 规范了如何指定文件路径从而自动加载类定义，同时规范了自动加载文件的位置。 1）一个完整的类名需具有以下结构：\\&lt;命名空间&gt;\\&lt;子命名空间&gt;\\&lt;类名&gt; 完整的类名必须要有一个顶级命名空间，被称为 “vendor namespace”； 完整的类名可以有一个或多个子命名空间； 完整的类名必须有一个最终的类名； 完整的类名中任意一部分中的下滑线都是没有特殊含义的； 完整的类名可以由任意大小写字母组成； 所有类名都必须是大小写敏感的。 2）根据完整的类名载入相应的文件 完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为「命名空间前缀」，其必须与至少一个「文件基目录」相对应； 紧接命名空间前缀后的子命名空间 必须 与相应的「文件基目录」相匹配，其中的命名空间分隔符将作为目录分隔符。 末尾的类名必须与对应的以 .php 为后缀的文件同名。 自动加载器（autoloader）的实现一定不可抛出异常、一定不可触发任一级别的错误信息以及不应该有返回值。 3) 例子PSR-4风格 类名：\\Zend\\Abc命名空间前缀：Zend文件基目录：/usr/includes/Zend/文件路径：/usr/includes/Zend/Abc.php 类名：\\Symfony\\Core\\Request命名空间前缀：Symfony\\Core文件基目录：./vendor/Symfony/Core/文件路径：./vendor/Symfony/Core/Request.php 目录结构 1234567-vendor/| -vendor_name/| | -package_name/| | | -src/| | | | -ClassName.php # Vendor_Name\\Package_Name\\ClassName| | | -tests/| | | | -ClassNameTest.php # Vendor_Name\\Package_Name\\ClassNameTest Composer自动加载过程Composer 做了哪些事情 你有一个项目依赖于若干个库。 其中一些库依赖于其他库。 你声明你所依赖的东西。 Composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。 例如，你正在创建一个项目，需要做一些单元测试。你决定使用 phpunit 。为了将它添加到你的项目中，你所需要做的就是在 composer.json 文件里描述项目的依赖关系。 12345&#123; \"require\": &#123; \"phpunit/phpunit\":\"~6.0\", &#125;&#125; 然后在 composer require 之后我们只要在项目里面直接 use phpunit 的类即可使用。 执行 composer require 时发生了什么 composer 会找到符合 PR4 规范的第三方库的源 将其加载到 vendor 目录下 初始化顶级域名的映射并写入到指定的文件里（如：&#39;PHPUnit\\\\Framework\\\\Assert&#39; =&gt; __DIR__ . &#39;/..&#39; . &#39;/phpunit/phpunit/src/Framework/Assert.php&#39;） 写好一个 autoload 函数，并且注册到 spl_autoload_register()里 题外话：现在很多框架都已经帮我们写好了顶级域名映射了，我们只需要在框架里面新建文件，在新建的文件中写好命名空间，就可以在任何地方 use 我们的命名空间了。 Composer 源码分析下面我们通过对源码的分析来看看 composer 是如何实现 PSR4标准 的自动加载功能。 很多框架在初始化的时候都会引入 composer 来协助自动加载的，以 Laravel 为例，它入口文件 index.php 第一句就是利用 composer 来实现自动加载功能。 启动1234&lt;?php define('LARAVEL_START', microtime(true)); require __DIR__ . '/../vendor/autoload.php'; 去 vendor 目录下的 autoload.php ： 1234&lt;?php require_once __DIR__ . '/composer' . '/autoload_real.php'; return ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29::getLoader(); 这里就是 Composer 真正开始的地方了 Composer自动加载文件首先，我们先大致了解一下Composer自动加载所用到的源文件。 autoload_real.php: 自动加载功能的引导类。 composer 加载类的初始化(顶级命名空间与文件路径映射初始化)和注册(spl_autoload_register())。 ClassLoader.php : composer 加载类。 composer 自动加载功能的核心类。 autoload_static.php : 顶级命名空间初始化类， 用于给核心类初始化顶级命名空间。 autoload_classmap.php : 自动加载的最简单形式， 有完整的命名空间和文件目录的映射； autoload_files.php : 用于加载全局函数的文件， 存放各个全局函数所在的文件路径名； autoload_namespaces.php : 符合 PSR0 标准的自动加载文件， 存放着顶级命名空间与文件的映射； autoload_psr4.php : 符合 PSR4 标准的自动加载文件， 存放着顶级命名空间与文件的映射； autoload_real 引导类 在 vendor 目录下的 autoload.php 文件中我们可以看出，程序主要调用了引导类的静态方法 getLoader() ，我们接着看看这个函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php public static function getLoader() &#123; if (null !== self::$loader) &#123; return self::$loader; &#125; spl_autoload_register( array('ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader'), true, true ); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister( array('ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader') ); $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION'); if ($useStaticLoader) &#123; require_once __DIR__ . '/autoload_static.php'; call_user_func( \\Composer\\Autoload\\ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::getInitializer($loader) ); &#125; else &#123; $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; /***********************注册自动加载核心类对象********************/ $loader-&gt;register(true); /***********************自动加载全局函数********************/ if ($useStaticLoader) &#123; $includeFiles = Composer\\Autoload\\ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$files; &#125; else &#123; $includeFiles = require __DIR__ . '/autoload_files.php'; &#125; foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file); &#125; return $loader; &#125; 我把自动加载引导类分为 5 个部分。 第一部分——单例第一部分很简单，就是个最经典的单例模式，自动加载类只能有一个。 1234&lt;?php if (null !== self::$loader) &#123; return self::$loader; &#125; 第二部分——构造ClassLoader核心类第二部分 new 一个自动加载的核心类对象。 1234567891011&lt;?php /***********************获得自动加载核心类对象********************/ spl_autoload_register( array('ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader'), true, true ); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister( array('ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader') ); loadClassLoader()函数： 1234567&lt;?phppublic static function loadClassLoader($class)&#123; if ('Composer\\Autoload\\ClassLoader' === $class) &#123; require __DIR__ . '/ClassLoader.php'; &#125;&#125; 从程序里面我们可以看出，composer 先向 PHP 自动加载机制注册了一个函数，这个函数 require 了 ClassLoader 文件。成功 new 出该文件中核心类 ClassLoader() 后，又销毁了该函数。 第三部分 —— 初始化核心类对象12345678910111213141516171819202122232425&lt;?php /***********************初始化自动加载核心类对象********************/ $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION'); if ($useStaticLoader) &#123; require_once __DIR__ . '/autoload_static.php'; call_user_func( \\Composer\\Autoload\\ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::getInitializer($loader) ); &#125; else &#123; $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; 这一部分就是对自动加载类的初始化，主要是给自动加载核心类初始化顶级命名空间映射。 初始化的方法有两种： 1. 使用 autoload_static 进行静态初始化； 2. 调用核心类接口初始化。 autoload_static 静态初始化 ( PHP &gt;= 5.6 )静态初始化只支持 PHP5.6 以上版本并且不支持 HHVM 虚拟机。我们深入 autoload_static.php 这个文件发现这个文件定义了一个用于静态初始化的类，名字叫 ComposerStaticInit7b790917ce8899df9af8ed53631a1c29，仍然为了避免冲突而加了 hash 值。这个类很简单： 12345678910111213141516171819202122232425&lt;?php class ComposerStaticInit7b790917ce8899df9af8ed53631a1c29&#123; public static $files = array(...); public static $prefixLengthsPsr4 = array(...); public static $prefixDirsPsr4 = array(...); public static $prefixesPsr0 = array(...); public static $classMap = array (...); public static function getInitializer(ClassLoader $loader) &#123; return \\Closure::bind(function () use ($loader) &#123; $loader-&gt;prefixLengthsPsr4 = ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$prefixLengthsPsr4; $loader-&gt;prefixDirsPsr4 = ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$prefixDirsPsr4; $loader-&gt;prefixesPsr0 = ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$prefixesPsr0; $loader-&gt;classMap = ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$classMap; &#125;, null, ClassLoader::class); &#125; 这个静态初始化类的核心就是 getInitializer() 函数，它将自己类中的顶级命名空间映射给了 ClassLoader 类。值得注意的是这个函数返回的是一个匿名函数，为什么呢？原因就是 ClassLoader类 中的 prefixLengthsPsr4 、prefixDirsPsr4等等变量都是 private的。利用匿名函数的绑定功能就可以将这些 private 变量赋给 ClassLoader 类 里的成员变量。 关于匿名函数的绑定功能。 接下来就是命名空间初始化的关键了。 classMap（命名空间映射）1234567891011121314151617&lt;?php public static $classMap = array ( 'App\\\\Console\\\\Kernel' =&gt; __DIR__ . '/../..' . '/app/Console/Kernel.php', 'App\\\\Exceptions\\\\Handler' =&gt; __DIR__ . '/../..' . '/app/Exceptions/Handler.php', 'App\\\\Http\\\\Controllers\\\\Auth\\\\ForgotPasswordController' =&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/ForgotPasswordController.php', 'App\\\\Http\\\\Controllers\\\\Auth\\\\LoginController' =&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/LoginController.php', 'App\\\\Http\\\\Controllers\\\\Auth\\\\RegisterController' =&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/RegisterController.php', ...) 直接命名空间全名与目录的映射，简单粗暴，也导致这个数组相当的大。 PSR4 标准顶级命名空间映射数组：1234567891011121314151617181920212223242526&lt;?php public static $prefixLengthsPsr4 = array( 'p' =&gt; array ( 'phpDocumentor\\\\Reflection\\\\' =&gt; 25, ), 'S' =&gt; array ( 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; 26, 'Symfony\\\\Component\\\\Yaml\\\\' =&gt; 23, 'Symfony\\\\Component\\\\VarDumper\\\\' =&gt; 28, ... ), ...); public static $prefixDirsPsr4 = array ( 'phpDocumentor\\\\Reflection\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-common/src', 1 =&gt; __DIR__ . '/..' . '/phpdocumentor/type-resolver/src', 2 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src', ), 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring', ), 'Symfony\\\\Component\\\\Yaml\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/symfony/yaml', ), ...) PSR4 标准顶级命名空间映射用了两个数组，第一个是用命名空间第一个字母作为前缀索引，然后是 顶级命名空间，但是最终并不是文件路径，而是 顶级命名空间的长度。为什么呢？ 因为 PSR4 标准是用顶级命名空间目录替换顶级命名空间，所以获得顶级命名空间的长度很重要。 具体说明这些数组的作用： 假如我们找 Symfony\\Polyfill\\Mbstring\\example 这个命名空间，通过前缀索引和字符串匹配我们得到了 12&lt;?php 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; 26, 这条记录，键是顶级命名空间，值是命名空间的长度。拿到顶级命名空间后去 $prefixDirsPsr4数组 获取它的映射目录数组：(注意映射目录可能不止一条) 1234&lt;?php 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring', ) 然后我们就可以将命名空间 Symfony\\\\Polyfill\\\\Mbstring\\\\example 前26个字符替换成目录 __DIR__ . &#39;/..&#39; . &#39;/symfony/polyfill-mbstring ，我们就得到了__DIR__ . &#39;/..&#39; . &#39;/symfony/polyfill-mbstring/example.php，先验证磁盘上这个文件是否存在，如果不存在接着遍历。如果遍历后没有找到，则加载失败。 ClassLoader 接口初始化（ PHP &lt; 5.6 ） 如果PHP版本低于 5.6 或者使用 HHVM 虚拟机环境，那么就要使用核心类的接口进行初始化。 1234567891011121314151617&lt;?php // PSR0 标准 $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; // PSR4 标准 $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; PSR4 标准的映射autoload_psr4.php 的顶级命名空间映射 123456789101112131415161718&lt;?php return array( 'XdgBaseDir\\\\' =&gt; array($vendorDir . '/dnoegel/php-xdg-base-dir/src'), 'Webmozart\\\\Assert\\\\' =&gt; array($vendorDir . '/webmozart/assert/src'), 'TijsVerkoyen\\\\CssToInlineStyles\\\\' =&gt; array($vendorDir . '/tijsverkoyen/css-to-inline-styles/src'), 'Tests\\\\' =&gt; array($baseDir . '/tests'), 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; array($vendorDir . '/symfony/polyfill-mbstring'), ... ) PSR4 标准的初始化接口: 12345678910111213141516&lt;?php public function setPsr4($prefix, $paths) &#123; if (!$prefix) &#123; $this-&gt;fallbackDirsPsr4 = (array) $paths; &#125; else &#123; $length = strlen($prefix); if ('\\\\' !== $prefix[$length - 1]) &#123; throw new \\InvalidArgumentException( \"A non-empty PSR-4 prefix must end with a namespace separator.\" ); &#125; $this-&gt;prefixLengthsPsr4[$prefix[0]][$prefix] = $length; $this-&gt;prefixDirsPsr4[$prefix] = (array) $paths; &#125; &#125; PSR4初始化接口也很简单。如果没有顶级命名空间，就直接保存目录。如果有命名空间的话，要保证顶级命名空间最后是 \\ ，然后分别保存。 总结下上面的顶级命名空间映射过程： ( 前缀 -&gt; 顶级命名空间，顶级命名空间 -&gt; 顶级命名空间长度 ) ( 顶级命名空间 -&gt; 目录 ) 这两个映射数组。具体形式也可以查看下面的 autoload_static 的 prefixLengthsPsr4 、 $prefixDirsPsr4 。 命名空间映射autoload_classmap： 123456789&lt;?phppublic static $classMap = array ( 'App\\\\Console\\\\Kernel' =&gt; __DIR__ . '/../..' . '/app/Console/Kernel.php', 'App\\\\Exceptions\\\\Handler' =&gt; __DIR__ . '/../..' . '/app/Exceptions/Handler.php', ...) addClassMap: 123456789&lt;?php public function addClassMap(array $classMap) &#123; if ($this-&gt;classMap) &#123; $this-&gt;classMap = array_merge($this-&gt;classMap, $classMap); &#125; else &#123; $this-&gt;classMap = $classMap; &#125; &#125; 自动加载核心类 ClassLoader 的静态初始化到这里就完成了！ 其实说是5部分，真正重要的就两部分——初始化与注册。初始化负责顶层命名空间的目录映射，注册负责实现顶层以下的命名空间映射规则。 第四部分 —— 注册 讲完了 Composer 自动加载功能的启动与初始化，经过启动与初始化，自动加载核心类对象已经获得了顶级命名空间与相应目录的映射，也就是说，如果有命名空间 ‘App\\Console\\Kernel，我们已经可以找到它对应的类文件所在位置。那么，它是什么时候被触发去找的呢？ 这就是 composer 自动加载的核心了，我们先回顾一下自动加载引导类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 public static function getLoader() &#123; /***************************经典单例模式********************/ if (null !== self::$loader) &#123; return self::$loader; &#125; /***********************获得自动加载核心类对象********************/ spl_autoload_register(array('ComposerAutoloaderInit 7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader'), true, true); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInit 7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader')); /***********************初始化自动加载核心类对象********************/ $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION'); if ($useStaticLoader) &#123; require_once __DIR__ . '/autoload_static.php'; call_user_func(\\Composer\\Autoload\\ComposerStaticInit 7b790917ce8899df9af8ed53631a1c29::getInitializer($loader)); &#125; else &#123; $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; /***********************注册自动加载核心类对象********************/ $loader-&gt;register(true); /***********************自动加载全局函数********************/ if ($useStaticLoader) &#123; $includeFiles = Composer\\Autoload\\ComposerStaticInit 7b790917ce8899df9af8ed53631a1c29::$files; &#125; else &#123; $includeFiles = require __DIR__ . '/autoload_files.php'; &#125; foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire 7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file); &#125; return $loader;&#125; 现在我们开始引导类的第四部分：注册自动加载核心类对象。我们来看看核心类的 register() 函数： 1234public function register($prepend = false)&#123; spl_autoload_register(array($this, 'loadClass'), true, $prepend);&#125; 一行代码实现自动加载！ 其实奥秘都在自动加载核心类 ClassLoader 的 loadClass() 函数上： 12345678public function loadClass($class) &#123; if ($file = $this-&gt;findFile($class)) &#123; includeFile($file); return true; &#125; &#125; 这个函数负责按照 PSR 标准将顶层命名空间以下的内容转为对应的目录，也就是上面所说的将 ‘App\\Console\\Kernel 中’ Console\\Kernel 这一段转为目录，至于怎么转的在下面 “运行”的部分讲。核心类 ClassLoader 将 loadClass() 函数注册到PHP SPL中的 spl_autoload_register() 里面去。这样，每当PHP遇到一个不认识的命名空间的时候，PHP会自动调用注册到 spl_autoload_register 里面的 loadClass() 函数，然后找到命名空间对应的文件。 全局函数的自动加载 Composer 不止可以自动加载命名空间，还可以加载全局函数。怎么实现的呢？把全局函数写到特定的文件里面去，在程序运行前挨个 require就行了。这个就是 composer 自动加载的第五步，加载全局函数。 12345678if ($useStaticLoader) &#123; $includeFiles = Composer\\Autoload\\ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$files;&#125; else &#123; $includeFiles = require __DIR__ . '/autoload_files.php';&#125;foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file);&#125; 跟核心类的初始化一样，全局函数自动加载也分为两种：静态初始化和普通初始化，静态加载只支持PHP5.6以上并且不支持HHVM。 静态初始化： ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$files： 12345public static $files = array ('0e6d7bf4a5811bfa5cf40c5ccd6fae6a' =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring/bootstrap.php','667aeda72477189d0494fecd327c3641' =&gt; __DIR__ . '/..' . '/symfony/var-dumper/Resources/functions/dump.php',...); 普通初始化autoload_files: 12345678$vendorDir = dirname(dirname(__FILE__));$baseDir = dirname($vendorDir); return array('0e6d7bf4a5811bfa5cf40c5ccd6fae6a' =&gt; $vendorDir . '/symfony/polyfill-mbstring/bootstrap.php','667aeda72477189d0494fecd327c3641' =&gt; $vendorDir . '/symfony/var-dumper/Resources/functions/dump.php', ....); 其实跟静态初始化区别不大。 加载全局函数123456789101112131415161718class ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29&#123; public static function getLoader()&#123; ... foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file); &#125; ... &#125;&#125;function composerRequire7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file) &#123; if (empty(\\$GLOBALS['__composer_autoload_files'][\\$fileIdentifier])) &#123; require $file; $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true; &#125;&#125; 第五部分 —— 运行到这里，终于来到了核心的核心—— composer 自动加载的真相，命名空间如何通过 composer 转为对应目录文件的奥秘就在这一章。前面说过，ClassLoader 的 register() 函数将 loadClass() 函数注册到 PHP 的 SPL 函数堆栈中，每当 PHP 遇到不认识的命名空间时就会调用函数堆栈的每个函数，直到加载命名空间成功。所以 loadClass() 函数就是自动加载的关键了。 看下 loadClass() 函数: 1234567891011121314151617181920212223242526272829303132333435363738public function loadClass($class)&#123; if ($file = $this-&gt;findFile($class)) &#123; includeFile($file); return true; &#125;&#125;public function findFile($class)&#123; // work around for PHP 5.3.0 - 5.3.2 https://bugs.php.net/50731 if ('\\\\' == $class[0]) &#123; $class = substr($class, 1); &#125; // class map lookup if (isset($this-&gt;classMap[$class])) &#123; return $this-&gt;classMap[$class]; &#125; if ($this-&gt;classMapAuthoritative) &#123; return false; &#125; $file = $this-&gt;findFileWithExtension($class, '.php'); // Search for Hack files if we are running on HHVM if ($file === null &amp;&amp; defined('HHVM_VERSION')) &#123; $file = $this-&gt;findFileWithExtension($class, '.hh'); &#125; if ($file === null) &#123; // Remember that this class does not exist. return $this-&gt;classMap[$class] = false; &#125; return $file;&#125; 我们看到 loadClass() ，主要调用 findFile() 函数。findFile() 在解析命名空间的时候主要分为两部分：classMap 和 findFileWithExtension() 函数。classMap 很简单，直接看命名空间是否在映射数组中即可。麻烦的是 findFileWithExtension() 函数，这个函数包含了 PSR0 和 PSR4 标准的实现。还有个值得我们注意的是查找路径成功后 includeFile() 仍然是外面的函数，并不是 ClassLoader 的成员函数，原理跟上面一样，防止有用户写 $this 或 self。还有就是如果命名空间是以\\开头的，要去掉\\然后再匹配。 看下 findFileWithExtension 函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private function findFileWithExtension($class, $ext)&#123; // PSR-4 lookup $logicalPathPsr4 = strtr($class, '\\\\', DIRECTORY_SEPARATOR) . $ext; $first = $class[0]; if (isset($this-&gt;prefixLengthsPsr4[$first])) &#123; foreach ($this-&gt;prefixLengthsPsr4[$first] as $prefix =&gt; $length) &#123; if (0 === strpos($class, $prefix)) &#123; foreach ($this-&gt;prefixDirsPsr4[$prefix] as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) &#123; return $file; &#125; &#125; &#125; &#125; &#125; // PSR-4 fallback dirs foreach ($this-&gt;fallbackDirsPsr4 as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) &#123; return $file; &#125; &#125; // PSR-0 lookup if (false !== $pos = strrpos($class, '\\\\')) &#123; // namespaced class name $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1) . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR); &#125; else &#123; // PEAR-like class name $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext; &#125; if (isset($this-&gt;prefixesPsr0[$first])) &#123; foreach ($this-&gt;prefixesPsr0[$first] as $prefix =&gt; $dirs) &#123; if (0 === strpos($class, $prefix)) &#123; foreach ($dirs as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123; return $file; &#125; &#125; &#125; &#125; &#125; // PSR-0 fallback dirs foreach ($this-&gt;fallbackDirsPsr0 as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123; return $file; &#125; &#125; // PSR-0 include paths. if ($this-&gt;useIncludePath &amp;&amp; $file = stream_resolve_include_path($logicalPathPsr0)) &#123; return $file; &#125;&#125; 最后小结我们通过举例来说下上面代码的流程： 如果我们在代码中写下 new phpDocumentor\\Reflection\\Element()，PHP 会通过 SPL_autoload_register 调用 loadClass -&gt; findFile -&gt; findFileWithExtension。步骤如下： 将 \\ 转为文件分隔符/，加上后缀php，变成 $logicalPathPsr4, 即 phpDocumentor/Reflection//Element.php; 利用命名空间第一个字母p作为前缀索引搜索 prefixLengthsPsr4 数组，查到下面这个数组： 12345p' =&gt; array ( 'phpDocumentor\\\\Reflection\\\\' =&gt; 25, 'phpDocumentor\\\\Fake\\\\' =&gt; 19, ) 遍历这个数组，得到两个顶层命名空间 phpDocumentor\\Reflection\\ 和 phpDocumentor\\Fake\\ 在这个数组中查找 phpDocumentor\\Reflection\\Element，找出 phpDocumentor\\Reflection\\ 这个顶层命名空间并且长度为25。 在prefixDirsPsr4 映射数组中得到phpDocumentor\\Reflection\\ 的目录映射为： 123456'phpDocumentor\\\\Reflection\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-common/src', 1 =&gt; __DIR__ . '/..' . '/phpdocumentor/type-resolver/src', 2 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src', ), 遍历这个映射数组，得到三个目录映射； 查看 “目录+文件分隔符//+substr(\\$logicalPathPsr4, \\$length)”文件是否存在，存在即返回。这里就是&#39;__DIR__/../phpdocumentor/reflection-common/src + substr(phpDocumentor/Reflection/Element.php,25)&#39; 如果失败，则利用 fallbackDirsPsr4 数组里面的目录继续判断是否存在文件 The end. Thanks!","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"composer","slug":"composer","permalink":"http://www.tenpercent.top/tags/composer/"}]},{"title":"对PHP 后期静态绑定的理解","date":"2018-04-19T16:00:00.000Z","path":"2018/04/20/late-static-bindings/","text":"什么是后期静态绑定在看一些框架源码或者是某个项目的代码时，经常能看到后期静态绑定的用法。比如下面这段： 1234567public static function getInstance()&#123; if (is_null(static::$instance)) &#123; static::$instance = new static; &#125; return static::$instance;&#125; 这里用到的就是后期静态绑定。那么，什么是后期静态绑定？ “后期绑定”的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。 这里要先说两个概念，一个是转发调用，另一个是非转发调用。 转发调用所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：self::, parent::, static:: 以及 forward_ static _call()。即在进行静态调用时未指名类名的调用属于转发调用。 非转发调用非转发调用其实就是明确指定类名的静态调用（foo::bar()）和非静态调用($foo-&gt;bar())。即明确地指定类名的静态调用和非静态调用。 顾名思义，非转发调用前面有类名所以调用的函数一定是属于“这个类的”，不需要转到别的类。转发调用就是由于前期的静态绑定导致在后面调用静态方法时可能“转发到其他的类” 在PHP的官方文档里，对于后期静态绑定是这样说的：后期静态绑定工作原理是存储了在上一个“非转发调用”（non-forwarding call）中的类名。意思是当我们调用一个转发调用的静态调用时，实际调用的类是上一个非转发调用的类。 来看两个例子： 例1： 1234567891011121314class A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; static::who(); // 后期静态绑定从这里开始 &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test(); 以上代码会输出 1B 例2： 12345678910111213141516171819202122232425262728class A &#123; public static function foo() &#123; static::who(); &#125; public static function who() &#123; echo __CLASS__.\"\\n\"; &#125;&#125;class B extends A &#123; public static function test() &#123; A::foo(); parent::foo(); self::foo(); &#125; public static function who() &#123; echo __CLASS__.\"\\n\"; &#125;&#125;class C extends B &#123; public static function who() &#123; echo __CLASS__.\"\\n\"; &#125;&#125;C::test(); 以上代码会输出 123ACC 在这里主要分析下例2。 1.C::test()，这是一个非转发调用，因为::前面有类名C。 2.进入test()方法，有三个静态调用 A::foo(),parent::foo(),self::foo(),对于这三个静态调用来说，他们的非转发调用类就是 C。 3.现在执行A::foo(),这是一个非转发调用。A::foo()中的代码是 static::who(),这是一个转发调用，对于这个转发调用来说他的非转发调用类就是不再是C而是A（因为之前执行了A::foo()）。因此执行的结果为A 4.现在执行 parent::foo(),这是一个转发调用，转发到哪里呢？就是它的上一个非转发调用的类，也就是类C（在步骤2中提到的）。在这里一定要注意虽然在这之前执行了 A::foo(),但是 parent::foo()的上一个非转发调用的类任然是类C。因此执行的结果是 C. 5.现在执行 self::foo(),这个和 parent::foo()一样都是转发调用，因此也输出 C。 使用后期静态绑定的好处后期静态绑定目前我看到较多的是用于对象实例化中，在实例化对象时，static 会根据运行时调用的类来决定实例化对象，而 self 则是根据所在位置的类来决定实例化对象。当我们只想实例化子类，并且不希望后续在对子类的使用中由于父类的变化对子类产生影响时，后期静态绑定就能发挥它的作用了。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"PHP代码简洁之道——SOLID原则","date":"2018-03-22T16:00:00.000Z","path":"2018/03/23/clean-code-solid/","text":"SOLID 是Michael Feathers推荐的便于记忆的首字母简写，它代表了Robert Martin命名的最重要的五个面对对象编码设计原则 S: 单一职责原则 (SRP) O: 开闭原则 (OCP) L: 里氏替换原则 (LSP) I: 接口隔离原则 (ISP) D: 依赖反转原则 (DIP) 单一职责原则 Single Responsibility Principle (SRP)“修改一个类应该只为一个理由”。人们总是易于用一堆方法塞满一个类，如同我们在飞机上只能携带一个行李箱（把所有的东西都塞到箱子里）。这样做的问题是：从概念上这样的类不是高内聚的，并且留下了很多理由去修改它。将你需要修改类的次数降低到最小很重要。这是因为，当有很多方法在类中时，修改其中一处，你很难知晓在代码库中哪些依赖的模块会被影响到。 Bad: 123456789101112131415161718192021class UserSettings&#123; private $user; public function __construct($user) &#123; $this-&gt;user = $user; &#125; public function changeSettings($settings) &#123; if ($this-&gt;verifyCredentials()) &#123; // ... &#125; &#125; private function verifyCredentials() &#123; // ... &#125;&#125; Good: 123456789101112131415161718192021222324252627282930313233class UserAuth &#123; private $user; public function __construct($user) &#123; $this-&gt;user = $user; &#125; public function verifyCredentials() &#123; // ... &#125;&#125;class UserSettings &#123; private $user; private $auth; public function __construct($user) &#123; $this-&gt;user = $user; $this-&gt;auth = new UserAuth($user); &#125; public function changeSettings($settings) &#123; if ($this-&gt;auth-&gt;verifyCredentials()) &#123; // ... &#125; &#125;&#125; 开闭原则 Open/Closed Principle (OCP)正如Bertrand Meyer所述，”软件的实体（类, 模块, 函数,等）应该对扩展开放，对修改关闭。”这个原则是在说明应该允许用户在不改变已有代码的情况下增加新的功能。 Bad: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960abstract class Adapter&#123; protected $name; public function getName() &#123; return $this-&gt;name; &#125;&#125;class AjaxAdapter extends Adapter&#123; public function __construct() &#123; parent::__construct(); $this-&gt;name = 'ajaxAdapter'; &#125;&#125;class NodeAdapter extends Adapter&#123; public function __construct() &#123; parent::__construct(); $this-&gt;name = 'nodeAdapter'; &#125;&#125;class HttpRequester&#123; private $adapter; public function __construct($adapter) &#123; $this-&gt;adapter = $adapter; &#125; public function fetch($url) &#123; $adapterName = $this-&gt;adapter-&gt;getName(); if ($adapterName === 'ajaxAdapter') &#123; return $this-&gt;makeAjaxCall($url); &#125; elseif ($adapterName === 'httpNodeAdapter') &#123; return $this-&gt;makeHttpCall($url); &#125; &#125; private function makeAjaxCall($url) &#123; // request and return promise &#125; private function makeHttpCall($url) &#123; // request and return promise &#125;&#125; 在上面的代码中，对于HttpRequester类中的fetch方法，如果我新增了一个新的xxxAdapter类并且要在fetch方法中用到的话，就需要在HttpRequester类中去修改类（如加上一个elseif 判断），而通过下面的代码，就可很好的解决这个问题。下面代码很好的说明了如何在不改变原有代码的情况下增加新功能。 Good: 1234567891011121314151617181920212223242526272829303132333435interface Adapter&#123; public function request($url);&#125;class AjaxAdapter implements Adapter&#123; public function request($url) &#123; // request and return promise &#125;&#125;class NodeAdapter implements Adapter&#123; public function request($url) &#123; // request and return promise &#125;&#125;class HttpRequester&#123; private $adapter; public function __construct(Adapter $adapter) &#123; $this-&gt;adapter = $adapter; &#125; public function fetch($url) &#123; return $this-&gt;adapter-&gt;request($url); &#125;&#125; 里氏替换原则 Liskov Substitution Principle (LSP)对这个概念最好的解释是：如果你有一个父类和一个子类，在不改变原有结果正确性的前提下父类和子类可以互换。这个听起来让人有些迷惑，所以让我们来看一个经典的正方形-长方形的例子。从数学上讲，正方形是一种长方形，但是当你的模型通过继承使用了”is-a”的关系时，就不对了。 Bad: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Rectangle&#123; protected $width = 0; protected $height = 0; public function render($area) &#123; // ... &#125; public function setWidth($width) &#123; $this-&gt;width = $width; &#125; public function setHeight($height) &#123; $this-&gt;height = $height; &#125; public function getArea() &#123; return $this-&gt;width * $this-&gt;height; &#125;&#125;class Square extends Rectangle&#123; public function setWidth($width) &#123; $this-&gt;width = $this-&gt;height = $width; &#125; public function setHeight(height) &#123; $this-&gt;width = $this-&gt;height = $height; &#125;&#125;function renderLargeRectangles($rectangles)&#123; foreach ($rectangles as $rectangle) &#123; $rectangle-&gt;setWidth(4); $rectangle-&gt;setHeight(5); $area = $rectangle-&gt;getArea(); // BAD: Will return 25 for Square. Should be 20. $rectangle-&gt;render($area); &#125;&#125;$rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles($rectangles); Good: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263abstract class Shape&#123; protected $width = 0; protected $height = 0; abstract public function getArea(); public function render($area) &#123; // ... &#125;&#125;class Rectangle extends Shape&#123; public function setWidth($width) &#123; $this-&gt;width = $width; &#125; public function setHeight($height) &#123; $this-&gt;height = $height; &#125; public function getArea() &#123; return $this-&gt;width * $this-&gt;height; &#125;&#125;class Square extends Shape&#123; private $length = 0; public function setLength($length) &#123; $this-&gt;length = $length; &#125; public function getArea() &#123; return pow($this-&gt;length, 2); &#125;&#125;function renderLargeRectangles($rectangles)&#123; foreach ($rectangles as $rectangle) &#123; if ($rectangle instanceof Square) &#123; $rectangle-&gt;setLength(5); &#125; elseif ($rectangle instanceof Rectangle) &#123; $rectangle-&gt;setWidth(4); $rectangle-&gt;setHeight(5); &#125; $area = $rectangle-&gt;getArea(); $rectangle-&gt;render($area); &#125;&#125;$shapes = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles($shapes); 接口隔离原则接口隔离原则：”客户端不应该被强制去实现于它不需要的接口”。 有一个清晰的例子来说明示范这条原则。当一个类需要一个大量的设置项，为了方便不会要求客户端去设置大量的选项，因为在通常他们不需要所有的设置项。使设置项可选有助于我们避免产生”胖接口” Bad: 1234567891011121314151617181920212223242526272829303132interface Employee&#123; public function work(); public function eat();&#125;class Human implements Employee&#123; public function work() &#123; // ....working &#125; public function eat() &#123; // ...... eating in lunch break &#125;&#125;class Robot implements Employee&#123; public function work() &#123; //.... working much more &#125; public function eat() &#123; //.... robot can't eat, but it must implement this method &#125;&#125; 上面的代码中，Robot类并不需要eat()这个方法，但是实现了Emplyee接口，于是只能实现所有的方法了，这使得Robot实现了它并不需要的方法。所以在这里应该对Emplyee接口进行拆分，正确的代码如下： Good: 1234567891011121314151617181920212223242526272829303132333435interface Workable&#123; public function work();&#125;interface Feedable&#123; public function eat();&#125;interface Employee extends Feedable, Workable&#123;&#125;class Human implements Employee&#123; public function work() &#123; // ....working &#125; public function eat() &#123; //.... eating in lunch break &#125;&#125;// robot can only workclass Robot implements Workable&#123; public function work() &#123; // ....working &#125;&#125; 依赖反转原则 Dependency Inversion Principle (DIP)这条原则说明两个基本的要点： 高阶的模块不应该依赖低阶的模块，它们都应该依赖于抽象 抽象不应该依赖于实现，实现应该依赖于抽象 这条起初看起来有点晦涩难懂，但是如果你使用过php框架（例如 Symfony），你应该见过依赖注入（DI）对这个概念的实现。虽然它们不是完全相通的概念，依赖倒置原则使高阶模块与低阶模块的实现细节和创建分离。可以使用依赖注入（DI）这种方式来实现它。更多的好处是它使模块之间解耦。耦合会导致你难于重构，它是一种非常糟糕的的开发模式。 Bad: 123456789101112131415161718192021222324252627282930class Employee&#123; public function work() &#123; // ....working &#125;&#125;class Robot extends Employee&#123; public function work() &#123; //.... working much more &#125;&#125;class Manager&#123; private $employee; public function __construct(Employee $employee) &#123; $this-&gt;employee = $employee; &#125; public function manage() &#123; $this-&gt;employee-&gt;work(); &#125;&#125; Good: 1234567891011121314151617181920212223242526272829303132333435interface Employee&#123; public function work();&#125;class Human implements Employee&#123; public function work() &#123; // ....working &#125;&#125;class Robot implements Employee&#123; public function work() &#123; //.... working much more &#125;&#125;class Manager&#123; private $employee; public function __construct(Employee $employee) &#123; $this-&gt;employee = $employee; &#125; public function manage() &#123; $this-&gt;employee-&gt;work(); &#125;&#125; 别写重复代码 (DRY)这条原则大家应该都是比较熟悉了。 尽你最大的努力去避免复制代码，它是一种非常糟糕的行为，复制代码通常意味着当你需要变更一些逻辑时，你需要修改不止一处。 Bad: 12345678910111213141516171819202122232425262728293031function showDeveloperList($developers)&#123; foreach ($developers as $developer) &#123; $expectedSalary = $developer-&gt;calculateExpectedSalary(); $experience = $developer-&gt;getExperience(); $githubLink = $developer-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125;function showManagerList($managers)&#123; foreach ($managers as $manager) &#123; $expectedSalary = $manager-&gt;calculateExpectedSalary(); $experience = $manager-&gt;getExperience(); $githubLink = $manager-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125; Good: 123456789101112131415function showList($employees)&#123; foreach ($employees as $employee) &#123; $expectedSalary = $employee-&gt;calculateExpectedSalary(); $experience = $employee-&gt;getExperience(); $githubLink = $employee-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125; Very good: 12345678910function showList($employees)&#123; foreach ($employees as $employee) &#123; render([ $employee-&gt;calculateExpectedSalary(), $employee-&gt;getExperience(), $employee-&gt;getGithubLink() ]); &#125;&#125; 后记：虽然OOP设计需要遵守如上原则，不过实际的代码设计一定要简单、简单、简单。在实际编码中要根据情况进行取舍，一味遵守原则，而不注重实际情况的话，可能会让你的代码变的难以理解!","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"PHP代码简洁之道——类和对象部分","date":"2018-03-09T16:00:00.000Z","path":"2018/03/10/clean-code-php-object/","text":"使用getter和setter在 PHP 中，通过为属性或方法设置 public, protected 和 private 关键字可以实现对属性或方法的可见性控制。不过，通过 getter 和 setter 也可以达到控制可见性的目的，并且在某些场景下它具备一些额外的好处。 使用 getter和 setter 有以下好处： 当你除了获取对象之外还想做一些别的事情时，就不用到项目中去查找所有的属性并修改 使添加验证更简单 在获取和设置时添加日志和错误处理更方便 我们可以延迟加载类的属性 继承了类，你可以重写默认的函数 另外，这是面向对象的基本设计原则中的开放/封闭原则。 Bad: 123456789class BankAccount&#123; public $balance = 1000;&#125;$bankAccount = new BankAccount();// 买了一双鞋...$bankAccount-&gt;balance -= 100; Good: 12345678910111213141516171819202122232425262728293031323334353637class BankAccount&#123; private $balance; public function __construct($balance = 1000) &#123; $this-&gt;balance = $balance; &#125; //做一些事情 public function withdrawBalance($amount) &#123; if ($amount &gt; $this-&gt;balance) &#123; throw new \\Exception('Amount greater than available balance.'); &#125; $this-&gt;balance -= $amount; &#125; public function depositBalance($amount) &#123; $this-&gt;balance += $amount; &#125; public function getBalance() &#123; return $this-&gt;balance; &#125;&#125;$bankAccount = new BankAccount();// 买了一双鞋...$bankAccount-&gt;withdrawBalance($shoesPrice);// 获取结余$balance = $bankAccount-&gt;getBalance(); 让对象具有私有或受保护的的成员Bad: 123456789101112class Employee&#123; public $name; public function __construct($name) &#123; $this-&gt;name = $name; &#125;&#125;$employee = new Employee('John Doe');echo 'Employee name: '.$employee-&gt;name; // Employee name: John Doe Good: 1234567891011121314151617class Employee&#123; private $name; public function __construct($name) &#123; $this-&gt;name = $name; &#125; public function getName() &#123; return $this-&gt;name; &#125;&#125;$employee = new Employee('John Doe');echo 'Employee name: '.$employee-&gt;getName(); // Employee name: John Doe 使用组合而不是继承这里不是说不使用继承，使用“组合模式”和使用“继承”都有很多好的理由。 这里想说的是当你本能的要使用继承时就想一想“组合模式”是否能更好帮你的解决问题。 那么，你可能想知道，“什么时候应该用继承？”， 这取决于你手头上问题。 以下几点说明了什么时候使用继承会更合适。 你的继承表达了一个对等（比如”人类是动物”）的关系，不是包含的关系（比如”用户具有用户详情”） 你能从基类中复用代码 你想通过修改全局类来对所有派生类进行修改。 Bad: 123456789101112131415161718192021222324252627282930313233class Employee &#123; private $name; private $email; public function __construct($name, $email) &#123; $this-&gt;name = $name; $this-&gt;email = $email; &#125; // ...&#125;// 因为雇员和税收不是对等关系而是包含的关系// 所以这里应用组合比较合适class EmployeeTaxData extends Employee &#123; private $ssn; private $salary; public function __construct($name, $email, $ssn, $salary) &#123; parent::__construct($name, $email); $this-&gt;ssn = $ssn; $this-&gt;salary = $salary; &#125; // ...&#125; Good: 123456789101112131415161718192021222324252627282930313233class EmployeeTaxData &#123; private $ssn; private $salary; public function __construct($ssn, $salary) &#123; $this-&gt;ssn = $ssn; $this-&gt;salary = $salary; &#125; // ...&#125;class Employee &#123; private $name; private $email; private $taxData; public function __construct($name, $email) &#123; $this-&gt;name = $name; $this-&gt;email = $email; &#125; public function setTaxData($ssn, $salary) &#123; $this-&gt;taxData = new EmployeeTaxData($ssn, $salary); &#125; // ...&#125;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"PHP代码简洁之道——函数部分","date":"2018-02-28T16:00:00.000Z","path":"2018/03/01/clean-code-php-function/","text":"函数参数不要超过两个限制函数的参数数量是非常重要的，因为它使你的函数更容易测试。超过三个参数会导致参数之间的组合过多，你必须对每个单独的参数测试大量不同的情况。 没有参数是最理想的情况，一个或两个参数是可以接受的，三个以上则是应该避免的。这很重要。如果你有两个以上的参数，那么你的函数可能试图做的太多，如果不是，你可能需要将一个高级别的对象传当做参数传进去。 Bad: 12345function createMenu($title, $body, $buttonText, $cancellable)&#123; // ...&#125; Good： 123456789101112131415161718class MenuConfig&#123; public $title; public $body; public $buttonText; public $cancellable = false;&#125;$config = new MenuConfig();$config-&gt;title = 'Foo';$config-&gt;body = 'Bar';$config-&gt;buttonText = 'Baz';$config-&gt;cancellable = true;function createMenu(MenuConfig $config)&#123; // ...&#125; 一个函数只做一件事这是软件工程中一个重要的原则。这会让你的代码清晰易懂以及易于复用。 Bad： 123456789function emailClients($clients)&#123; foreach ($clients as $client) &#123; $clientRecord = $db-&gt;find($client); if ($clientRecord-&gt;isActive()) &#123; email($client); &#125; &#125;&#125; Good: 1234567891011121314151617function emailClients($clients)&#123; $activeClients = activeClients($clients); array_walk($activeClients, 'email');&#125;function activeClients($clients)&#123; return array_filter($clients, 'isClientActive');&#125;function isClientActive($client)&#123; $clientRecord = $db-&gt;find($client); return $clientRecord-&gt;isActive();&#125; 函数名要能说明它是做什么的Bad: 12345678910111213class Email&#123; //... public function handle() &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// 这是什么？一条消息的句柄？还是要写一个文件？（读者的疑问）$message-&gt;handle(); Good: 12345678910111213class Email &#123; //... public function send() &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// 一目了然$message-&gt;send(); 函数应该只做一层抽象当你有多个层次的抽象时，你的函数就已经做的太多了。拆分这些函数，可以让代码可重用性更高且更易测试。Bad: 123456789101112131415161718192021222324function parseBetterJSAlternative($code)&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; // ... &#125; &#125; $ast = []; foreach ($tokens as $token) &#123; // lex... &#125; foreach ($ast as $node) &#123; // parse... &#125;&#125; Bad too:我们从函数中迁出去了一些工作，但是 parseBetterJSAlternative() 函数还是很复杂，不可测试。 1234567891011121314151617181920212223242526272829303132333435function tokenize($code)&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens;&#125;function lexer($tokens)&#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast;&#125;function parseBetterJSAlternative($code)&#123; $tokens = tokenize($code); $ast = lexer($tokens); foreach ($ast as $node) &#123; // parse... &#125;&#125; Good: 最好的解决方案是移除 parseBetterJSAlternative 函数的依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Tokenizer&#123; public function tokenize($code) &#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens; &#125;&#125;class Lexer&#123; public function lexify($tokens) &#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast; &#125;&#125;class BetterJSAlternative&#123; private $tokenizer; private $lexer; public function __construct(Tokenizer $tokenizer, Lexer $lexer) &#123; $this-&gt;tokenizer = $tokenizer; $this-&gt;lexer = $lexer; &#125; public function parse($code) &#123; $tokens = $this-&gt;tokenizer-&gt;tokenize($code); $ast = $this-&gt;lexer-&gt;lexify($tokens); foreach ($ast as $node) &#123; // parse... &#125; &#125;&#125; 不要使用标志作为函数的参数当你在函数中使用标志来作为参数时，你的函数就不是只做一件事情了，这与我们前面所讲的每个函数只做一件事的原则相违背，所以不要使用标志作为函数的参数。 Bad: 12345678function createFile($name, $temp = false)&#123; if ($temp) &#123; touch('./temp/'.$name); &#125; else &#123; touch($name); &#125;&#125; Good: 12345678910function createFile($name)&#123; touch($name);&#125;function createTempFile($name)&#123; touch('./temp/'.$name);&#125; 避免副作用如果一个函数做了“拿到一个值并返回一个值或者多个值”以外的事情，那么这个函数就有可能产生副作用，副作用可能是意外的写入了文件、修改了全局变量、或者打钱给了陌生人。 现在假如你确实要在函数中做一些有可能产生副作用的事情。 比如要写一个文件，你需要做的是将写文件的操作集中到一处，而不是在几个函数或者类里对同一个文件做操作，实现一个服务（函数或者类）去操作它，有且仅有一个。 关键是要能避免常见的陷阱：像是在没有结构的对象之间共享状态、使用可能被写入任何值的可变数据类型、 不集中处理有可能产生副作用的操作。 如果你能做到这些，你会比绝大多数程序员更快乐。 Bad: 1234567891011121314// Global variable referenced by following function.// If we had another function that used this name, now it'd be an array and it could break it.$name = 'Ryan McDermott';function splitIntoFirstAndLastName()&#123; global $name; $name = explode(' ', $name);&#125;splitIntoFirstAndLastName();var_dump($name); // ['Ryan', 'McDermott']; Good: 1234567891011function splitIntoFirstAndLastName($name)&#123; return explode(' ', $name);&#125;$name = 'Ryan McDermott';$newName = splitIntoFirstAndLastName($name);var_dump($name); // 'Ryan McDermott';var_dump($newName); // ['Ryan', 'McDermott']; 不要修改全局变量在许多编程语言中污染全局是一种糟糕的做法，因为你的库可能会与另一个库冲突，但是你的库的用户却一无所知，直到在生产环境中爆发异常。让我们来考虑一个例子：如果你想要拿到配置数组怎么办？你可以编写全局函数，如config()，但是它可能与另一个试图做同样事情的库冲突。 Bad: 123456function config()&#123; return [ 'foo' =&gt; 'bar', ]&#125; Good: 12345678910111213141516171819class Configuration&#123; private $configuration = []; public function __construct(array $configuration) &#123; $this-&gt;configuration = $configuration; &#125; public function get($key) &#123; return isset($this-&gt;configuration[$key]) ? $this-&gt;configuration[$key] : null; &#125;&#125;$configuration = new Configuration([ 'foo' =&gt; 'bar',]); 避免条件判断人们会问“如果不用 if 语句我该怎么做？”，答案是在许多情况下，你可以用多态来实现同样的效果。那这样做什么好处，还是那句话：“一个函数应该只做一件事”， 当你的类或函数中有了 if 语句，你的函数就不止是只做一件事情了。 Bad: 12345678910111213141516class Airplane&#123; // ... public function getCruisingAltitude() &#123; switch ($this-&gt;type) &#123; case '777': return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); case 'Air Force One': return $this-&gt;getMaxAltitude(); case 'Cessna': return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125; &#125;&#125; Good: 123456789101112131415161718192021222324252627282930313233343536interface Airplane&#123; // ... public function getCruisingAltitude();&#125;class Boeing777 implements Airplane&#123; // ... public function getCruisingAltitude() &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); &#125;&#125;class AirForceOne implements Airplane&#123; // ... public function getCruisingAltitude() &#123; return $this-&gt;getMaxAltitude(); &#125;&#125;class Cessna implements Airplane&#123; // ... public function getCruisingAltitude() &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125;&#125;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"PHP代码简洁之道——变量部分","date":"2018-02-23T16:00:00.000Z","path":"2018/02/24/clean-code-php/","text":"将代码写的简洁并且易读易懂是每一位优秀的coder所应该具备的基本功。 前几天在github上看到clean-code-php这个项目，感觉很有收获，于是在这里记录一下。 使用有意义并且可读的变量名称Bad: 1$ymdstr = $moment-&gt;format('y-m-d'); Good: 1$currentDate = $moment-&gt;format('y-m-d'); 对同一只类型的变量使用同样的词汇Bad: 1234getUserInfo();getUserData();getUserRecord();getUserProfile(); Good: 1getUser(); 使用易于查找的命名Bad: 1234// 这里的4是什么鬼??if ($user-&gt;access &amp; 4) &#123; // ...&#125; Good: 1234567891011class User&#123; const ACCESS_READ = 1; const ACCESS_CREATE = 2; const ACCESS_UPDATE = 4; const ACCESS_DELETE = 8;&#125;if ($user-&gt;access &amp; User::ACCESS_UPDATE) &#123; // do edit ...&#125; 不要让读者猜Bad: 123456789101112$l = ['Austin', 'New York', 'San Francisco'];for ($i = 0; $i &lt; count($l); $i++) &#123; $li = $l[$i]; doStuff(); doSomeOtherStuff(); // ... // ... // ... // $li 变量代表什么？？？ dispatch($li);&#125; Good: 12345678910$locations = ['Austin', 'New York', 'San Francisco'];foreach ($locations as $location) &#123; doStuff(); doSomeOtherStuff(); // ... // ... // ... dispatch($location);&#125; 避免过深的嵌套Bad: 123456789101112131415161718192021function isShopOpen($day)&#123; if ($day) &#123; if (is_string($day)) &#123; $day = strtolower($day); if ($day === 'friday') &#123; return true; &#125; elseif ($day === 'saturday') &#123; return true; &#125; elseif ($day === 'sunday') &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125;&#125; Good: 123456789101112function isShopOpen($day)&#123; if (empty($day) &amp;&amp; ! is_string($day)) &#123; return false; &#125; $openingDays = [ 'friday', 'saturday', 'sunday' ]; return in_array(strtolower($day), $openingDays);&#125; Bad: 12345678910111213141516function fibonacci($n)&#123; if ($n &lt; 50) &#123; if ($n !== 0) &#123; if ($n !== 1) &#123; return fibonacci($n - 1) + fibonacci($n - 2); &#125; else &#123; return 1; &#125; &#125; else &#123; return 0; &#125; &#125; else &#123; return 'Not supported'; &#125;&#125; Good: 12345678910111213141516function fibonacci($n)&#123; if ($n === 0) &#123; return 0; &#125; if ($n === 1) &#123; return 1; &#125; if ($n &gt; 50) &#123; return 'Not supported'; &#125; return fibonacci($n - 1) + fibonacci($n - 2);&#125; 不要添加不必要的上下文如果你的类/对象已经说明了一些信息,不要在你的变量名和属性里重复 Bad: 12345678class Car&#123; public $carMake; public $carModel; public $carColor; //...&#125; Good: 12345678class Car&#123; public $make; public $model; public $color; //...&#125; 参数初始化时设置默认值12345function create($name = null)&#123; $newName = $name ?: 'ABC'; // ...&#125; 设置默认值一个比较明显的好处是，当对一个较早之前已经定义好的函数添加参数时,将新增的参数设置默认值可以省得去修改以前使用该函数的地方。 参考链接","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"关于 RESTful API 设计的总结","date":"2017-12-08T16:00:00.000Z","path":"2017/12/09/RESTful/","text":"为什么要用 RESTfulRESTful 给我的最大感觉就是规范、易懂和优雅，一个结构清晰、易于理解的 API 完全可以省去许多无意义的沟通和文档。并且 RESTful 现在越来越流行， 在开始介绍 RESTful API 之前，先介绍一下 RESTful 架构。 RESTful 架构REST，即Representational State Transfer 的缩写。意为 “ 表现层状态转化 “ 。 要理解RESTful架构，最好的方法就是去理解 Representational State Transfer 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果把这个名称搞懂了，也就不难体会 REST 是一种什么样的设计。 资源 （Resources）REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或独一无二的识别符。所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的 URI 。 表现层（Representation）“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、 XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。URI 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的” .html “后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而 URI 应该只代表”资源”的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对”表现层”的描述。 状态转化（State Transfer）访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET 、 POST 、 PUT 、 DELETE 。 它们分别对应四种基本操作： GET 用来获取资源， POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 综述总结一下什么是RESTful架构： 每一个URI代表一种资源； 客户端和服务器之间，传递这种资源的某种表现层； 客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 RESTful API 的设计介绍完 RESTful 的含义，再说说 RESTful API 的设计。 协议如果能全站 HTTPS 当然是最好的，不能的话也请尽量将登录、注册等涉及密码的接口使用 HTTPS。 域名应该尽量将API部署在专用域名之下。如： 1https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 1https://example.org/api/ 版本号API 的版本号和客户端 APP 的版本号是毫无关系的，不要让 APP 将它们用于提交应用市场的版本号传递到服务器，而是提供类似于v1、v2之类的 API 版本号。 版本号拼接在 URL 中。如： 1api.example.com/v1/users 或是放在 Header 中: 123api.xxx.com/usersversion=v1 请求一般来说 API 的外在形式无非就是增删改查（当然具体的业务逻辑肯定要复杂得多），而查询又分为详情和列表两种，在 RESTful 中这就相当于通用的模板。例如针对文章（Article）设计 API，那么最基础的 URL 就是这几种： GET /articles： 文章列表 GET /articles/id：文章详情 POST /articles/： 创建文章 PUT /articles/id：修改文章 DELETE /articles/id：删除文章 Token 和 SignAPI 需要设计成无状态，所以客户端在每次请求时都需要提供有效的 Token 和 Sign，在我看来它们的用途分别是： Token 用于证明请求所属的用户，一般都是服务端在登录后随机生成一段字符串（UUID）和登录用户进行绑定，再将其返回给客户端。Token 的状态保持一般有两种方式实现：一种是在用户每次操作都会延长或重置 TOKEN 的生存时间（类似于缓存的机制），另一种是 Token 的生存时间固定不变，但是同时返回一个刷新用的 Token，当 Token 过期时可以将其刷新而不是重新登录。 Sign 用于证明该次请求合理，所以一般客户端会把请求参数拼接后并加密作为 Sign 传给服务端，这样即使被抓包了，对方只修改参数而无法生成对应的 Sign 也会被服务端识破。当然也可以将时间戳、请求地址和 Token 也混入 Sign，这样 Sign 也拥有了所属人、时效性和目的地。 业务参数在 RESTful 的标准中，PUT 和 PATCH 都可以用于修改操作，它们的区别是 PUT 需要提交整个对象，而 PATCH 只需要提交修改的信息。但是在我看来实际应用中不需要这么麻烦，所以我一律使用 PUT，并且只提交修改的信息。 另一个问题是在 POST 创建对象时，究竟该用表单提交更好些还是用 JSON 提交更好些。其实两者都可以，在我看来它们唯一的区别是 JSON 可以比较方便的表示更为复杂的结构（有嵌套对象）。另外无论使用哪种，请保持统一，不要两者混用。 还有一个建议是最好将过滤、分页和排序的相关信息全权交给客户端，包括过滤条件、页数或是游标、每页的数量、排序方式、升降序等，这样可以使 API 更加灵活。但是对于过滤条件、排序方式等，不需要支持所有方式，只需要支持目前用得上的和以后可能会用上的方式即可，并通过字符串枚举解析，这样可见性要更好些。例如： 搜索，客户端只提供关键词，具体搜索的字段，和搜索方式（前缀、全文、精确）由服务端决定： 1/users/?query=ScienJus 过滤，只需要对已有的情况进行支持： 1/users/?gender=1 分页： 1/users/?page=2&amp;pre_page=20 响应尽量使用 HTTP 状态码，常用的有： 200：请求成功 201：创建、修改成功 204：删除成功 400：参数错误 401：未登录 403：禁止访问 404：未找到 500：系统错误 但是有些时候仅仅使用 HTTP 状态码没有办法明确的表达错误信息，所以也可以在里面再包一层自定义的返回码，例如： 成功时： 12345&#123; &quot;code&quot;: 100, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: &#123;&#125;&#125; 1234&#123; &quot;code&quot;: -1000, &quot;msg&quot;: &quot;用户名或密码错误&quot;&#125; data是真正需要返回的数据，并且只会在请求成功时才存在，msg只用在开发环境，并且只为了开发人员识别。客户端逻辑只允许识别code，并且不允许直接将msg的内容展示给用户。如果这个错误很复杂，无法使用一段话描述清楚，也可以在添加一个doc字段，包含指向该错误的文档的链接。 返回数据JSON 比 XML 可视化更好，也更加节约流量，所以尽量不要使用 XML。 创建和修改操作成功后，需要返回该资源的全部信息。 返回数据不要和客户端界面强耦合，不要在设计 API 时就考虑少查询一张关联表或是少查询 / 返回几个字段能带来多大的性能提升。并且一定要以资源为单位，即使客户端一个页面需要展示多个资源，也不要在一个接口中全部返回，而是让客户端分别请求多个接口。 最好将返回数据进行加密和压缩，尤其是压缩在移动应用中还是比较重要的。","tags":[{"name":"API","slug":"API","permalink":"http://www.tenpercent.top/tags/API/"},{"name":"RESTful","slug":"RESTful","permalink":"http://www.tenpercent.top/tags/RESTful/"}]},{"title":"观察者模式的总结","date":"2017-11-17T16:00:00.000Z","path":"2017/11/18/observer-pattern/","text":"什么是观察者模式观察者模式用于实现对对象进行观察：一旦主体对象状态发生改变，与之关联的观察者对象会收到通知，并进行相应操作。 举个例子说明：假设一个这样的情景，当公司有一个新员工入职了，入职的当天，HR需要为他办理入职手续，网管需要给他配好电脑和办公用品，部门主管需要带他熟悉部门。传统的编程方式，就是在员工入职这个事件发生的代码之后直接加入处理逻辑,当后续我们需要增加处理逻辑时（比如员工入职后增加培训），代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要改变事件主题的代码。运用观察者模式，将员工的入职作为事件，其他的处理逻辑都做为观察者的操作，那么，当以后需要再增加更多的逻辑时，新增逻辑代码就会很方便。具体代码实现如下。 代码实现首先定义一个观察者接口，所有的观察者都实现这个接口（为什么要定义成接口呢？因为每一个观察者的具体行为需要具体去实现，用接口定义一个统一的方法，具体的实现交给观察者去实现） 1234interface observer&#123; public function update();&#125; 再定义一个事件生成器的抽象类，用来使继承它的事件都具有通知观察者的能力。 1234567891011121314151617181920abstract class EventGenerator&#123; private $observers = []; //定义一个添加观察者的方法 public function addOberver(Observer $observer) &#123; $this-&gt;observers[] = $observer; &#125; //定义一个通知观察者的方法 public function notify() &#123; foreach($this-&gt;observers as $observer) &#123; $observer-&gt;update(); &#125; &#125;&#125; 然后再来定义事件类 1234567891011class event extends EventGenerator&#123; //定义一个触发观察者的方法 public funtion trigger() &#123; echo \"Event &lt;br/&gt;\"; //开始通知观察者 $this-&gt;notify(); &#125; &#125; 开始使用 12$event = new event();$event-&gt;trigger(); 这个时候，当我们要在事件发生的时候增加别的操作，只需要新增观察者就可以了 新增一个观察者 12345678class Observer1 implements Observer&#123; public function update() &#123; echo \"操作1&lt;br/&gt;\"; &#125; &#125; 然后使用的时候就是 1234$event = new event();// 增加观察者$event-&gt;addObserver(new Observer1);$event-&gt;trigger(); 如果需要在事件发生后再增加操作，只需再新增相应的观察者即可。 应用观察者模式的好处观察者模式解除了主体和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。降低对象之间的耦合度以达到解耦的目的，符合”开闭原则”的要求。 利用 SPL 实现观察者模式PHP 通过内置的 SPL 扩展提供了对观察者模式的原生支持，其中的观察者由 3 个元素组成 ： SplObserver 接口、 SplSubject 接口和 SplObjectStorage 工具类。下面是利用 SPL 实现观察者模式的代码。SPL 的地址见这里。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class MyObserver1 implements SplObserver &#123; public function update(SplSubject $subject) &#123; echo __CLASS__ . ' - ' . $subject-&gt;getName(); &#125;&#125;class MyObserver2 implements SplObserver &#123; public function update(SplSubject $subject) &#123; echo __CLASS__ . ' - ' . $subject-&gt;getName(); &#125;&#125;class MySubject implements SplSubject &#123; private $observers; private $name; public function __construct($name) &#123; $this-&gt;observers = new SplObjectStorage(); $this-&gt;name = $name; &#125; public function attach(SplObserver $observer) &#123; $this-&gt;observers-&gt;attach($observer); &#125; public function detach(SplObserver $observer) &#123; $this-&gt;observers-&gt;detach($observer); &#125; public function notify() &#123; foreach ($this-&gt;observers as $observer) &#123; $observer-&gt;update($this); &#125; &#125; public function getName() &#123; return $this-&gt;name; &#125;&#125;$observer1 = new MyObserver1();$observer2 = new MyObserver2();$subject = new MySubject(\"test\");$subject-&gt;attach($observer1);$subject-&gt;attach($observer2);$subject-&gt;notify();/* 输出:MyObserver1 - testMyObserver2 - test*/$subject-&gt;detach($observer2);$subject-&gt;notify();/* 输出:MyObserver1 - test*/","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"通俗易懂的谈谈装饰器模式","date":"2017-09-16T16:00:00.000Z","path":"2017/09/17/Decorator-Pattern/","text":"前言在编码的时候，我们为了扩展一个类经常是使用继承方式来实现，随着扩展功能的增多，子类会越来越膨胀，使系统变得不灵活。 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。它能让我们在扩展类的时候让系统较好的保持灵活性。 那么装饰器模式具体是什么样的呢？ 从一个情景开始我们有一块地，在这块地上，我们要盖一栋有好几间房间的别墅，每间房间的装修费用都不同，现在，我们要对盖别墅的费用进行计算。 先定义一个Land类，表示这块地，Land类定义了在这块地上盖别墅需要花钱这个规则。 1234abstract class Land&#123; abstract function cost();&#125; Land已经定义好了在这块地上盖房需要花钱的这个规则了，但是盖一间房间具体花多少钱呢？此时我们再定义一个Room类，这个类具体的定义了一个房间建造的基本费用（一个最简单房间，里面啥也没有的）。 12345678class Room extends Land&#123; private $money = 1000; public function cost() &#123; return $this-&gt;money; &#125;&#125; 然后开始建造房间，我们建了两个房间，分别是客厅和餐厅，用LivingRoom类和DiningRoom类来表示 12345678910111213141516class LivingRoom extends Room&#123; public function cost() &#123; return parent::cost()+200; //客厅的建造费用在房屋建造费用的基础上多200，比如要买沙发，电视 &#125; &#125;class DiningRoom extends Room&#123; public function cost() &#123; return parent::cost()+100; //餐厅的建造费用在房屋建造费用的基础上多100，比如买餐桌 &#125;&#125; 现在，我们很容易就能得到建造一间客厅所需的花费 12$livingRoomCost = new LivingRoom();echo $livingRoomCost-&gt;cost(); 问题的产生不过，这样的结构并不具备灵活性，虽然我们可以很容易的分别得出建造一间客厅和建造一间餐厅的费用，但是，如果我买的地比较小，只能把餐厅和客厅建在同一个房间里，那要怎么去计算费用？难道还要很麻烦的去创建一个包含客厅和餐厅的LivingDiningRoom类？这样做的话除了麻烦，还会使代码产生重复。 解决问题为了更好的解决这个问题，我们得做一些调整，同样先声明Land类和Room类，不同的是，引入了一个房间的装饰类RoomDecorator，它继承了Land类，因为没有实现Land类的cost()方法，所以需将它声明为抽象类，并且定义了一个以Land类的对象为参数的构造方法，传入的对象会保存在$land属性中，该属性声明为protected，以便子类访问。具体如下。 12345678abstract class RoomDecorator extends Land&#123; protected $land; public function __construct(Land $land) &#123; $this-&gt;land = $land; &#125;&#125; 然后我们再重新定义客厅类和餐厅类 12345678910111213141516class LivingRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+200; &#125;&#125;class DiningRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+100; &#125;&#125; 这两个类都扩展自RoomDecorator类，这意味着它们都拥有指向Land对象的引用。当它们的cost()方法被调用时，都会先调用所引用的Land类对象的cost()方法，然后再执行自己特有的操作。 所以这时候，建造一间客厅所需的费用是这样计算 12$livingRoomCost = new LivingRoom(new Room());echo $livingRoomCost-&gt;cost(); //输出1200 建造一间餐厅所需的费用是这样计算 12$diningRoomCost = new DiningRoom(new Room());echo $diningRoomCost-&gt;cost(); //输出1100 回到刚才的问题，如果我们需计算建造一间包含客厅餐厅的房间所需费用，代码如下 12$livingRoom = new DiningRoom(new LivingRoom(new Room()));echo $livingRoom-&gt;cost(); //输出1300 看，我们现在计算建造费用的思路是：计算出基础房间的费用 –&gt; 在基础房间上装饰成客厅的费用 –&gt; 在客厅的基础上加装饰餐厅的费用 –&gt; 得到包含客厅餐厅的房间费用。已经不需要麻烦的通过创建一个LivingDiningRoom类来计算包含客厅餐厅的房间建造费用了。 这便是装饰模式，通过一层一层的装饰，我们可以灵活的得到我们想要的结果。可以轻松的添加新的装饰器类或者新的组件来创建灵活的结构。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpabstract class Land&#123; abstract function cost();&#125;class Room extends Land&#123; private $money = 1000; public function cost() &#123; return $this-&gt;money; &#125;&#125;//装饰器abstract class RoomDecorator extends Land&#123; protected $land; public function __construct(Land $land) &#123; $this-&gt;land = $land; &#125;&#125;class LivingRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+200; &#125;&#125;class DiningRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+100; &#125;&#125;$livingRoomCost = new LivingRoom(new Room());echo $livingRoomCost-&gt;cost(); //输出1200$diningRoomCost = new DiningRoom(new Room());echo $diningRoomCost-&gt;cost(); //输出1100$livingDining = new DiningRoom(new LivingRoom(new Room()));echo $livingDining-&gt;cost(); //输出1300 the end. happy coding! ^_^","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"外观模式的总结","date":"2017-09-09T16:00:00.000Z","path":"2017/09/10/Facade-pattern/","text":"前言外观模式(Facade Pattern)是一个比较简单的概念，它只是为一个子系统创建一个单一的入口。这样的好处是有助于分离项目中不同的部分，其次，会使得我们在访问代码时变得简洁方便。另外，由于只在一个地方调用子系统，减少了出错的可能性。 外观模式比较简单，这里就不做过多的赘述了，主要是要吸收该模式减少耦合的思想，直接上代码。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass SystemA&#123; public function operationA() &#123; echo \"operationA &lt;br&gt;\"; &#125;&#125;class SystemB&#123; public function operationB() &#123; echo \"operationB &lt;br&gt;\"; &#125;&#125;class SystemC&#123; public function operationC() &#123; echo \"operationC &lt;br&gt;\"; &#125;&#125;class Facade&#123; protected $systemA; protected $systemB; protected $systemC; function __construct() &#123; $this-&gt;systemA = new SystemA(); $this-&gt;systemB = new SystemB(); $this-&gt;systemC = new SystemC(); &#125; public function myOperation() &#123; $this-&gt;systemA-&gt;operationA(); $this-&gt;systemB-&gt;operationB(); $this-&gt;systemC-&gt;operationC(); &#125;&#125;$facade = new Facade();$facade-&gt;myOperation();//只通过一个入口调用 总结使用外观模式最大的优点就是子系统与客户端之间是松耦合的关系，客户端不必知道具体有哪些子系统，也无需知道他们是如何工作的，通过引入一个外观类，提供一个客户端间接访问子系统的高级接口。子系统和外观类可以独立运作，修改某一个子系统的内容，不会影响到其他子系统，也不会影响到外观对象。 不过它的缺点就是它不够灵活，当需要增加一个子系统的时候，需要修改外观类。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"使用 Vagrant 并搭建 LNMP 环境","date":"2017-09-02T16:00:00.000Z","path":"2017/09/03/use-vagrant/","text":"Vagrant介绍 Vagrant 是一个自动化构建虚拟机环境的工具，可以自动化虚拟机的安装和配置流程。 在团队开发的情况下，我们常常需要在多台机器间同步开发时，有的同事用的 wamp ,有的同事是用的 xampp ，可能在某些配置上的些许不同会导致些许不同或者bug，通过使用 Vagrant ，我们只需要同步 Vagrantfile ，就可以保证各台机器拥有一致的开发环境。也可以通过打包好一个Vagrant box ,供团队的同事使用，这样就能最大程度的保证开发环境一致，避免出现一些没必要的问题从而浪费精力去解决。 安装 Vagrant1、安装 VirtualBox ,具体安装包直接从官网下载（要下载顺畅的话需翻墙）：https://www.virtualbox.org/wiki/Downloads 2、安装 Vagrant，下载地址：https://releases.hashicorp.com/vagrant/ 3、下载box镜像，这里我是下载的Ubuntu的box,可以到这个网址上去查找想下载的box：https://app.vagrantup.com/boxes/search 切换到自己的文件夹下，初始化vagrant环境，生成一个vagrantfile文件，命令如下： 用 vagrant 命令加 box 1$ vagrant box add testUbuntu ~/Downloads/ubuntu-14.04-amd64.box 初始化虚拟机 1$ vagrant init testUbuntu 启动虚拟机 1$ vagrant up 进入虚拟机的 Ubuntu 系统 1$ vagrant ssh 接下来还要对虚拟机进行一些配置。 打开 vagrantfile 文件进行配置，我的配置如下： 到这里，利用 vagrant 搭建虚拟机环境就基本完成了。 vagrant 常用命令 123456789vagrant box add 添加box，自动帮你生成vagrantfilevagrant init 初始化vagrantfilevagrant halt 关闭虚拟机vagrant destroy 销毁虚拟机vagrant ssh 连接虚拟机vagrant reload 重新加载vagarntfile文件vagrant suspend 暂时挂起虚拟机vagrant status 查看虚拟机运行状态vagrant package --output 打包导出box 搭建 LNMP 环境使用 vagrant ssh 登录到虚拟机的 Linux 系统上，就可以开始搭建 LNMP 的环境了。 在安装软件之前，需要对 Ubuntu 系统的镜像源文件 source.list 进行修改一下，可以在网上找一下网易的镜像源或者是阿里搜狐等的镜像源，然后写入 source.list 文件夹里（对源文件先进行下备份）。修改完之后还要运行一下 apt-get update 命令来更新一下镜像源。 安装 Nginx使用apt-get install nginx便可以安装nginx。非常简单。安转完之后，可以使用 curl -I &#39;127.0.0.1&#39;访问一下，看看是否安装成功。 安装 MySQL使用 apt-get install mysql-server mysql-cli 安装MySQL的服务端可客户端，安装的时候需要设置一下密码。安装完之后，通过命令 mysql -uroot -ppassword 命令来登录数据库。 安装PHP 7.0在这里，我使用 Ubuntu 的 PPA 源来安装 PHP 7.0。 先介绍一下 PPA源 PPA 全称为 Personal Package（个人软件包档案），是 Ubuntu Launchpad 网站提供的一项服务，当然不仅限于 Launchpad 。它允许个人用户上传软件源代码，通过 Launchpad 进行编译并发布为二进制软件包，作为 apt/新立得源供其他用户下载和更新。在Launchpad网站上的每一个用户和团队都可以拥有一个或多个PPA。通常 PPA 源里的软件是官方源里没有的，或者是最新版本的软件。相对于通过 Deb 包安装来说，使用 PPA 的好处是，一旦软件有更新，通过 sudo apt-get upgrade 这样命令就可以直接升级到新版本。 如何通过 PPA 源来安装软件： 我们可以通过 Google 来搜索一些常用软件的 PPA 源，通常的搜索方法是软件名称关键字 + PPA ，或者也可直接到 launchpad.net 上去搜索，搜索到后我们就可以直接用 sudo apt-add-repository 命令把 PPA 源添加到 Source list 中了。比如 FireFox PPA 源：https://launchpad.net/~ubuntu-mozilla-daily/+archive/ppa ，我们可以在这里找到 ppa:ubuntu-mozilla-daily/ppa 的字样，然后我们通过以下命令把这个源加入到 source list 中。 sudo apt-add-repository ppa:ubuntu-mozilla-daily/ppa 开始安装 PHP 7.0 第一次使用PPA时，需要先安装一下 python-software-properties 和 software-properties-common apt-get install python-software-properties software-properties-common 然后便可以开始安装PHP 7.0 了 123$ add-apt-repository ppa:ondrej/php$ apt-get update 安装PHP的一些扩展 $ apt-get install php7.0-fpm php7.0-mysql php7.0-common php7.0-curl php7.0-cli php7.0-mbstring php7.0-dom 打开 php.ini进行配置 vim /etc/php/7.0/fpm/php.ini 将cgi.fixpathinfo=1 改成cgi.fixpathinfo=0,这个配置是为了避免 nginx 产生某个漏洞。具体参考鸟哥的文章http://www.laruence.com/2010/05/20/1495.html cgi.fix_pathinfo=0 然后重启一下 php-fpm 服务。 到这里就成功搭建好了 LNMP环境了。 happy codding ! ^_^","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.tenpercent.top/tags/Linux/"},{"name":"Vagrant","slug":"Vagrant","permalink":"http://www.tenpercent.top/tags/Vagrant/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://www.tenpercent.top/tags/虚拟机/"}]},{"title":"PSR编程规范摘录","date":"2017-08-26T16:00:00.000Z","path":"2017/08/27/PSR-reference/","text":"这篇文章记录一下PHP的编程代码规范，做一个规范的PHPer。 PSR：即PHP Standards recommendation(PHP推荐标准)。 PSR-1:基本的代码风格 PHP标签： PHP标签只使用&lt;?php ?&gt;和&lt;?= ?&gt;，不得使用其他PHP标签句法。 编码： PHP所有文件都必须使用UTF-8字符集编码。 目的： 一个PHP文件可以定义符号（类、性状、函数和常量），或者执行有副作用的操作（例如，生成结果或处理数据），但是不能同时做这两件事。 自动加载： PHP命名空间和类必须遵守PSR-4自动加载器标准。 类的名称： PHP类的名称必须使用CamelCase这种驼峰式。 常量的名称：PHP常量的名称必须全部使用大写字母。如果需要，可以使用下划线把单词分开。例如：THIS_VARIABLE 方法的命名： PHP方法的名称必须使用camelCase这种驼峰式，首字母是小写的，后续的所有单词的首字母都是大写的。如：phpIsAwesome PSR-2:严格的代码风格PSR-2是在PSR-1的基础上进一步的要求。 缩进 PSR-2推荐的规范要求是使用4个空格缩进（因为空格最可靠，在不同的代码编辑器中渲染的效果基本一致） 文件和代码 PHP文件的最后一行要有一个空行，而且不能使用PHP关闭标签?&gt;，每行末尾都不能有空格。（这些要求大多数编辑器能帮你做好） 注：PHP文件不写关闭标签的目的是能避免意料之外的输出错误。如果加上关闭标签?&gt;，而且在关闭标签后有空行。那么这个空行会被当成输出导致错误。（例如，设定HTTP头部时） 关键字 对于ture,false和null,PSR-2推荐这些关键字都要使用小写字母的形式。 命名空间 每个命名空间声明语句后面必须跟着一个空行。使用use关键字导入命名空间时，在一系列的use声明语句后要加一个空行。 类 PSR-2推荐类定义体的起始括号应该在类名之后新起一行写。如下代码所示： 1234567&lt;?phpclass example &#123; //类的定义&#125; 方法 （直接代码示例如下） 12345678910&lt;?phpnamespace Animals //注意这里的命名空间首字母需要大写class example&#123; public function test($params = 1, $params = 'two')//注意这里起始括号和结束括号两边都没有空格 &#123; //方法的定义 &#125;&#125; 可见性 类中的每个属性和方法都要声明可见性。abstract和final这俩关键字要放在可见性关键字前面。static关键字要放在可见性关键字后面。代码如下 12345678910class example&#123; public static $number = 0; public function __construct() &#123; static::$number++; &#125;&#125; 控制结构 控制结构中如if else switch foreach等这些关键字后面都要有一个空格。示例代码如下 12345&lt;?phpif (a == b)&#123; //注意这里的花括号不用新起一行 &#125; 虽然现在有挺多的编辑器支持根据PSR-1和PSR-2来格式化代码了，不过这些写代码中的规范还是需要记住一下，尽量让自己的代码风格规范一些，这样在日常的工作中也方便团队交流。 PSR-3：日志记录器接口PSR-3与前面得规范不同，它是一个接口，规定PHP日志记录器组件可以实现得方法。 大多数PHP框架都在某种程度上实现了日志功能。为了实现互操作性和专业化，PHP-FIG制定了PSR-3日志记录器接口。若想使用符合PSR-3规范得日志记录器，框架要做到两件重要得事：日志功能委托给第三方库实现；最终用户能选择使用他们喜欢得日志记录器组件。 编写PSR-3日志记录器符合PSR-3推荐规范的PHP日志记录器组件，必须包含一个实现Psr\\Log|LoggerInterface接口得PHP类。PSR-3接口复用了系统日志协议，规定要实现以下九个方法： 123456789101112131415&lt;?phpnamespace Psr\\Log;interface LoggerInterface&#123; public function emergency($message,array $context = array()); public function alert($message,array $context = array()); public function critial($message,array $context = array()); public function error($message,array $context = array()); public function warning($message,array $context = array()); public function notice($message,array $context = array()); public function info($message,array $context = array()); public function debug($message,array $context = array()); public function log($level,$message,array $context = array());&#125; 但是，我们现在已经不需要自己去编写一个日志记录器了，因为已经有了Monolog(可访问packagist这个网站查看介绍)这个十分出色的PHP日志记录器组件了，它几乎提供了开发过程中所有需要的功能。 PSR-4：自动加载器PSR-4描述了一个标准的自动加载器策略。自动加载器策略是指，在运行时按需查找PHP类、接口或者性状，并将其载入PHP解释器。支持PSR-4自动加载器标准的PHP组件和框架，使用同一个自动加载器就能找到相关代码 在PHP-FIG发布PSR-4推荐规范之前，PHP组件和框架的作者使用__autoload()和spl_autoload_register()函数注册自定义的自动加载器策略。可是，每个PHP组件和框架都使用独特的自动加载器，而且每个加载器使用不同的逻辑查找并加载PHP类、性状和接口。使用这些组件和框架的开发者，在引导PHP应用时必须调用每个组件各自的自动加载器时必须调用每个组件各自的自动加载器。这样在开发中很麻烦。 如今，得益于PSR-4，我们只需要使用一个自动加载器就能自动加载应用中的所有PHP组件。大多数现代的PHP组件和框架都符合PSR-4规范。 PSR自动加载策略PSR-4自动加载策略依赖PHP命名空间和文件系统目录结构查找并加载PHP类、接口，性状。 它的精髓是把命名空间的前缀和文件系统中的目录对应起来。例如，\\Oreilly\\ModernPHP\\Chapter1命名空间对应与src/chapter1目录，\\Oreilly\\ModernPHP\\Chapter1\\Example类对应于src/Chapter1/Example。 实现一个PSR-4自动加载器123456789101112131415161718192021222324252627282930313233343536&lt;?php/*** 该代码中，使用SPL注册这个自动加载函数后，遇到下述代码时，这个函数会* 自动尝试从/path/to/project/src/Baz/Qux.php文件中加载* \\Foo\\Bar\\Baz\\Quz类：* new \\Foo\\Bar\\Baz\\Qux;* */spl_autpload_register(function ($class))&#123; //这个项目的命名空间前缀 $prefix = 'Foo\\\\Bar\\\\'; //这个命名空间对应的根目录； $base_url = __DIR__.'/src/'; //参数传入的类使用这个命名空间前缀吗？ $len = strlen($prefix); if(strncmp($prefix, $class, $len) !==0)&#123; //不使用，交给注册的下一个自动加载器处理 return; &#125; //获取去掉前缀后的类名 $relative_class = substr($class, $len); //把命名空间前缀替换成根目录， //去掉前缀的类命中，把命名空间分隔符替换成目录分隔符， //然后再后面加上.php $file = $base_dir.str_replace('\\\\', '/', $relative_class).'.php'; //如果文件存在，将其导入 if(file_exists($file))&#123; require $file; &#125;&#125; 以上代码是一个PSR-4自动加载器的逻辑。不过在现在，我们也无须自己编写一个PSR-4自动加载器了，因为我们可以使用依赖管理器Composer自动生成PSR-4自动加载器。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"PSR","slug":"PSR","permalink":"http://www.tenpercent.top/tags/PSR/"}]},{"title":"现代化PHP的标准","date":"2017-08-12T16:00:00.000Z","path":"2017/08/13/php-standard/","text":"在今天，PHP组件和框架的数量很多，可以说是多如牛毛。PHP生态系统是个名副其实的大熔炉，有各种各样的代码，帮助开发者构建强大的应用。为了使这些不同的组件代码、框架能互相通信，共享代码，就诞生了PHP-FIG这个组织，PHP-FIG制定了推荐规范，PHP框架可以自愿实现这些规范，改进与其他框架的通信和共享功能。如今的很多受欢迎的大型PHP框架通常都会实现定案的PHP-FIG推荐规范。 PHP-FIG的使命是实现框架的互操作性。框架的互操作性是指，通过接口、自动加载机制和标准的风格，让框架互相操作。 接口PHP框架之间通过共用的接口合作。框架通过PHP接口假定第三方依赖提供了什么方法，而不关心依赖是如何实现接口的。 例如：假如第三方日志记录器对象实现了alert()，critical()，error()，warning()和debug()等方法，那么框架就可以放心的使用这个记录器对象。至于这些方法是如何实现的无关紧要，框架只关心第三方依赖是否实现了这些方法。 PHP开发者使用接口可以开发、共享并使用专门的组件，而无需使用庞大的框架。 自动加载PHP框架之间通过自动加载机制合作。自动加载是指，PHP解释器在运行时按需自动找到并加载PHP类的过程。 在这些PHP标准出现之前，PHP组件和框架会使用模式方法__autoload（）或最新的spl_autoload_register()方法实现各自特有的自动加载器。因此，我们要学习使用每一个组件和框架各自特有的自动加载器。而如今，多数现代的PHP组件和框架都符合同一个自动加载器标准。这意味着，我们只需使用一个自动加载器就能混合搭配多个PHP组件。 风格PHP框架之间通过标准的代码风格合作。代码风格是指如何使用空格、大小写和括号的位置（等待）。如果PHP框架都使用标准的代码风格，那么每次使用新PHP框架时，PHP开发者已经对框架所用的风格就很熟悉了，就不用适应新的风格。标准的代码风格还能降低项目新贡献者的门槛，让新贡献者把更多的时间用在解决缺陷上，而不用花太多时间学习不熟悉的风格。 标准的代码风格对我们自己的项目也有好处。每个开发者都有一些独特的风格，如果多为开发者在同一个代码基中工作，就会显露问题。使用标准的代码风格，不管作者是谁，团队中的所有成员都能立即理解代码基。 关于代码风格的规范，PHP-FIG退出了PSR，即PHP Standard Recommendation（PHP推荐标准）的简称。它包括PSR-1，PSR-2，PSR-3，PSR-4四个规范，现代的PHP框架基本都会遵守这些规范，这些个规范的具体详细内容就等下一篇总结再介绍吧。今天就先写到这里。 ^_^ happy coding!","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"PHP标准","slug":"PHP标准","permalink":"http://www.tenpercent.top/tags/PHP标准/"}]},{"title":"关于三种工厂模式的总结","date":"2017-07-09T16:00:00.000Z","path":"2017/07/10/factory-pattern/","text":"工厂模式分为简单工厂模式，工厂方法模式和抽象工厂模式，它们都属于设计模式中的创建型模式。其主要功能都是帮助我们把对象的实例化部分抽取了出来，目的是降低系统中代码耦合度，并且增强了系统的扩展性。本文对这三种模式进行了介绍并且分析它们之间的区别。 简单工厂模式简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码逻辑将会非常复杂。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php//简单工厂方法interface People&#123; public function say();&#125;class Man implements People&#123; public function say() &#123; echo 'this is a man '; &#125;&#125;class Women implements People&#123; public function say() &#123; echo 'this is a women'; &#125;&#125;class SimpleFactory&#123; public static function create($name) &#123; if ($name == 'man') &#123; return new Man(); &#125; elseif ($name == 'women') &#123; return new Women(); &#125; &#125; &#125;//具体调用$man = SimpleFactory::create('man');$man-&gt;say();$women = SimpleFactory::create('women');$women-&gt;say(); 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。 工厂方法模式此模式中，通过定义一个抽象的核心工厂类，并定义创建产品对象的接口，创建具体产品实例的工作延迟到其工厂子类去完成。这样做的好处是核心类只关注工厂类的接口定义，而具体的产品实例交给具体的工厂子类去创建。当系统需要新增一个产品是，无需修改现有系统代码，只需要添加一个具体产品类和其对应的工厂子类，使系统的扩展性变得很好，符合面向对象编程的开闭原则。体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php//工厂方法模式interface People&#123; public function say();&#125;class Man implements People&#123; public function say() &#123; echo 'this is a man'; &#125;&#125;class Women implements People&#123; public function say() &#123; echo 'this is a women'; &#125;&#125;//与简单工厂模式相比。区别在于，此处将对象的创建抽象成一个接口interface CreatePeople&#123; public function create();&#125;class FactoryMan implements CreatePeople&#123; public function create() &#123; return new Man(); &#125;&#125;class FactoryWomen implements CreatePeople&#123; public function create() &#123; return new Women(); &#125;&#125;class Client&#123; // 具体生产对象并执行对象方法测试 public function test() &#123; $factory = new FactoryMan(); $man = $factory-&gt;create(); $man-&gt;say(); $factory = new FactoryWomen(); $man = $factory-&gt;create(); $man-&gt;say(); &#125;&#125;// 执行$demo = new Client();$demo-&gt;test(); 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 此模式是对工厂方法模式的进一步扩展。在工厂方法模式中，一个具体的工厂负责生产一类具体的产品，即一对一的关系，但是，如果需要一个具体的工厂生产多种产品对象，那么就需要用到抽象工厂模式了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php interface TV&#123; public function open(); public function watch();&#125;class HaierTv implements TV&#123; public function open() &#123; echo \"Open Haier TV &lt;br&gt;\"; &#125; public function watch() &#123; echo \"I'm watching TV &lt;br&gt;\"; &#125;&#125;interface PC&#123; public function work(); public function play();&#125;class LenovoPc implements PC&#123; public function work() &#123; echo \"I'm working on a Lenovo computer &lt;br&gt;\"; &#125; public function play() &#123; echo \"Lenovo computers can be used to play games &lt;br&gt;\"; &#125;&#125;abstract class Factory&#123; abstract public static function createPc(); abstract public static function createTv();&#125;class ProductFactory extends Factory&#123; public static function createTV() &#123; return new HaierTv(); &#125; public static function createPc() &#123; return new LenovoPc(); &#125;&#125;$newTv = ProductFactory::createTV();$newTv-&gt;open();$newTv-&gt;watch();$newPc = ProductFactory::createPc();$newPc-&gt;work();$newPc-&gt;play(); 在上面的Factory抽象类中，定义了两个抽象方法，这两个抽象方法分别用来生产不同的产品（即由不同类实例化的对象）。 工厂方法模式和抽象工厂模式对比通过以上代码：我们来对比一下工厂方法模式和抽象工厂模式： 工厂方法模式中 当我需要多生产一种新的产品，比如factoryKid这个产品，我需要专门再设一个factoryKid的工厂，即添加如下代码： 1234567891011121314class Kid implements People&#123; public function say() &#123; echo 'this is a kid'; &#125;&#125;class FactoryKid implements CreatePeople&#123; public function create() &#123; return new Kid(); &#125;&#125; 抽象工厂模式中 同样当我需要多生产一种新的产品，比如生产一个iphone,此时我需要修改工厂父类里的接口，并且在具体工厂类ProductFactory这个工厂里增加一条createPhone生产线(即类里面的方法)，所需添加的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041interface Phone&#123; public function work(); public function sms();&#125;class IPhone implements Phone&#123; public function work() &#123; echo \"I'm iphone &lt;br&gt;\"; &#125; public function sms() &#123; echo \"this is an iphone &lt;br&gt;\"; &#125;&#125;//在原来的抽象工厂类中添加方法声明abstract class Factory&#123; abstract public static function createPc(); abstract public static function createTv(); abstract public static function createPhone();&#125;//在原来的工厂类里添加一个方法class ProductFactory extends Factory&#123; public static function createTV() &#123; return new HaierTv(); &#125; public static function createPc() &#123; return new LenovoPc(); &#125; public static function createPhone() &#123; return new IPhone(); &#125;&#125; 从上面的分析可以看出，要生产一个新的产品，抽象工厂模式并不比工厂方法模式更为便捷，那么抽象工厂模式的好处在哪呢?它优点就是在于是增加固定类型产品的不同具体工厂比较方便，比如我要增加一个生产同样类型产品的具体工厂Product2Factory，那么就再建一个Product2Factory类继承Factory就可以了。 最后的最后，总结一下工厂方法模式和抽象工厂模式的核心区别 工厂方法模式利用继承，抽象工厂模式利用组合 工厂方法模式产生一个对象，抽象工厂模式产生一族对象 工厂方法模式利用子类创造对象，抽象工厂模式利用接口的实现创造对象","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"PHP单例模式的总结","date":"2017-06-19T16:00:00.000Z","path":"2017/06/20/Singleton-Pattern/","text":"什么是单例模式含义单例模式是一种对象的创建模式，它用来确保某一个类只有一个实例，而且自行实例化并向整个系统全局的提供这个实例。 单例模式的特点1、有一个保存类的唯一实例的静态成员变量 2、有一个定义为私有的构造函数，表明这个类是不可能形成实例的，防止出现这个类有多个实例的情况出现（有时也可添加个声明为私有的克隆函数）。 3、提供一个能访问这个实例的声明为公共的静态方法（通常为getInstance方法），用来作为返回唯一实例的引用。 具体实现代码： 1234567891011121314151617181920212223242526272829class Preferences &#123; private $props = array(); private static $instance; private function __construct()&#123; &#125; private function __clone()&#123;&#125;; public static function getInstance()&#123; if(empty(self::$instance))&#123; self::$instance = new Preferences(); &#125; return self::$instance; &#125; public function setProperty($key,$val)&#123; $this-&gt;props[$key] = $val; &#125; public function getProperty($key)&#123; return $this-&gt;props[$key]; &#125; &#125;//调用单例 $pref = Preferences::getInstance(); $pref-&gt;setProperty('name','cjhlfy'); unset($pref); $pref2 = Preferences::getInstance(); echo $pref2-&gt;getProperty('name'); //name的属性值不会丢失,因为实例引用 $instance是静态属性 为什么要用单例模式全局变量是面向对象程序员遇到的引发bug的主要原因之一，这是因为全局变量将捆绑于特定的环境，破坏了封装。如果新的应用程序无法保证一开始就定义了相同的全局变量，那么一个依赖于全局变量的类就无法就无法从一个应用程序中提取出来并应用到新的应用程序中。所以单例模式是一种对于全局变量的改进。 不过，单例模式的使用也有不利的地方，它可能导致很难调试的依赖关系。如果改变一个实例，那么所有使用改单例的类可能都会受到影响。当单例被使用时，依赖便会隐藏在方法内部，而且并不会出现在方法声明里。这使得系统中的依赖关系更难以追踪，因此需要谨慎小心的部署单例类 单例模式应用应用场合1、应用程序与数据库的交互 一个应用中会存在大量的数据库操作，比如通过数据库句柄来连接数据库这一行为，使用单例模式可以避免大量的new操作，因为每一次new操作都会消耗内存资源和系统资源。 2、控制配置信息 如果系统中有有一个类来全局控制某些配置信息，那么使用单例模式就可以很方便实现，并且可以对配置进行统一管理。 以数据库操作为例深入理解12345678910111213141516171819202122232425262728293031323334class DB &#123; private $db; private static $instance; private function __construct()&#123; //进行数据库连接 &#125; private function __clone() &#123; &#125;; public static function getInstance()&#123; if(empty(self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; //数据库查询操作 public function select()&#123; //... &#125; //数据库插入操作 public function insert()&#123; //... &#125;&#125; //数据库编辑操作 public function update()&#123; //... &#125;&#125; //获取数据库单例类实例化之后，便可对数据库进行操作$db = DB::getInstance();$db-&gt;select();$db-&gt;insert();$db-&gt;update(); 单例模式的总结就到这里。 参考：《面向对象、模式与实践》","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"数据库查询中的exists与in分析比较","date":"2017-06-07T16:00:00.000Z","path":"2017/06/08/about-exists/","text":"最近在用Laravel的ORM写数据库查询时，用到了whereHas的写法，这个写法的背后实现的SQL语句就是select * from `table1` where exists(select * from `table2` where table1.id = table2.table1_id),于是就查清楚了一下exists的用法和特点，在这里记录一下。 exists的用法以下图的两张表关系作为分析： exists表示存在，它常常和子查询配合使用。例如对于上图，写下下面的SQL语句 SELECT FROM `user` WHERE exists (SELECT FROM `order` WHERE user.id = order.user_id) 在这里，exists用于检查查询子查询语句是否会至少返回一行数据，如果有返回数据，则返回值是true，反之是false。 放子查询返回为true时，则外层的查询语句将进行查询，反之，外层查询语句将不进行查询或者查不出任何记录。 因此：上面的SQL所实现的意义在于，搜索出所有下过单的会员。 exists和in的区别和使用场景除了exitst，in的使用也可以实现上面语句的效果。如下： SELECT * FROM `user` WHERE id in (SELECT user_id FROM `order`) 那么，它们之间有什么区别呢。 in()语句只会执行一次，它查出order表中的所有user_id字段并且缓存起来，之后，检查user表的id是否和order表中的user_id相当，如果相等则加入结果期，直到遍历完user的所有记录。用程序来表示如下： 123456789101112131415161718192021222324252627$result = [];$users = \"SELECT * FROM `user`\";$orders = \"SELECT user_id FROM `order`\";for($i = 0;$i &lt; $users.length;$i++)&#123; for($j = 0;$j &lt; $orders.length;$j++)&#123; // 此过程为内存操作，不涉及数据库查询。 if($users[$i].id == $orders[$j].user_id)&#123; $result[] = $users[$i]; break; &#125; &#125;&#125;``` 从上面的程序可以明显的看出，当order表数据很大的时候不适合用in,因为最多会将order表数据全部遍历一遍。如：user表有10000条记录,order表有1000000条记录,那么最多有可能遍历10000*1000000次,这样的话效率就很差了。* 再看exists，它的查询过程类似如下：```php $result = [];$users = \"SELECT * FROM `user`\";for($i=0;$i&lt;$users.length;$i++)&#123; if(exists($users[$i].id))&#123;// 执行SELECT * FROM `order` WHERE user.id = order.user_id $result[] = $users[$i]; &#125;&#125; 显而易见：当order表比user表大很多的时候，使用exists是再恰当不过了，它没有那么多遍历操作,只需要再执行一次查询就行。查询次数的多少完全取决于user表的记录条数。 但是：如果说user表有10000条记录,order表有100条记录,那么exists()还是执行10000次,反而不如使用in()遍历10000*100次,因为in()是在内存里遍历,而exists()需要查询数据库,我们都知道查询数据库所消耗的性能比较大,而操作内存的话会比较快. 因此，可以得出总结： 若外层查询表小于子查询表，则用exists。 若外层查询表(记录条数很多)远大于子查询表，则考虑用in。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"}]},{"title":"PHP的匿名函数和闭包","date":"2017-05-23T16:00:00.000Z","path":"2017/05/24/php-closure/","text":"匿名函数匿名函数（Anonymous function），也叫闭包函数（closures），允许临时创建一个没有指定名称的函数，最经常用作回调函数（callback）参数的值。 匿名函数的实现匿名函数是目前是通过Closure类来实现，匿名函数会产生这个类的对象。自PHP 5.4起，这个类带有一些方法，允许在匿名函数创建后对其进行更多的控制。 注意：PHP手册特别说明__invoke()这个魔术方法与匿名函数的实现过程无关。 Closure类如下： 12345678910Closure &#123; /* 方法 */ __construct ( void ) public static Closure bind ( Closure $closure , object $newthis [, mixed $newscope = 'static' ] ) public Closure bindTo ( object $newthis [, mixed $newscope = 'static' ] ) &#125;Closure::__construct — 用于禁止实例化的构造函数Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。 匿名函数例子： 1234$func = function($str)&#123; echo $str;&#125;;$func('hello'); 闭包闭包是指在创建时封装周围状态(如变量)的函数，即使闭包所在的环境的不存在了，闭包中封装的状态依然存在。 闭包的实现将匿名函数放在一个普通函数中（也可以将匿名函数返回），就构成了一个闭包。 1234567function closureFunc()&#123; $func = function()&#123; echo 'hello'; &#125; $func();&#125;closureFunc();//输出:hello 闭包的使用在匿名函数中引入局部变量时需要用到use关键字。这是因为PHP中的变量范围只在它的生效范围中。在匿名函数里并没有对变量进行定义，所以需要使用use关键字 123456789function closureFunc1()&#123; $num = 1; $func = function() use($num)&#123; echo $num; &#125;; $func();&#125;closureFunc2();//输出 闭包返回匿名函数并传参 12345678910function closureFunc2()&#123; $num = 1; $func = function($str) use($num)&#123; echo $num; echo $str; &#125;; return $func;&#125;$func = $closureFunc2();$func('hello');//输出 1 hello","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP手册【4】——类与对象（二）","date":"2017-05-09T16:00:00.000Z","path":"2017/05/10/review-php-04/","text":"Final关键字如果父类中的方法被声明为final,则子类无法继承。如果一个类被声明为final，则不能被继承。 NOTE: 属性不能被定义为final,只有类和方法才能被定义为final. 类型约束类型约束即函数的参数可以指定必须为对象、接口、数组或者callable。如果一个类或接口。类型约束不能用于标量类型如int或string。Trait也不允许。例子如下： 1234567891011121314151617181920212223242526272829303132class MyClass&#123; /** * 测试函数 * 第一个参数必须为 OtherClass 类的一个对象 */ public function test(OtherClass $otherclass)&#123; echo $otherclass-&gt;var; &#125; /** * 另一个测试函数 * 第一个参数必须为数组 */ public function test_array(array $input_array) &#123; print_r($input_array); &#125; /** * 第一个参数必须为递归类型 */ public function test_interface(Traversable $iterator) &#123; echo get_class($iterator); &#125; /** * 第一个参数必须为回调类型 */ public function test_callable(callable $callback, $data) &#123; call_user_func($callback, $data); &#125;&#125; 当函数调用的参数与定义的参数类型不一致时，会抛出一个致命的错误。 后期静态绑定这个目前不知道什么用处，先直接看例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Example #1 self:: 用法&lt;?phpclass A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; self::who(); &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test();?&gt;以上例程会输出：AExample #2 static:: 简单用法&lt;?phpclass A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; static::who(); // 后期静态绑定从这里开始 &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test();?&gt;以上例程会输出：B","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP手册【3】——类与对象（一）","date":"2017-04-22T16:00:00.000Z","path":"2017/04/23/review-php-03/","text":"类与对象构造函数和析构函数 构造函数 具有构造函数的类会在每次创建新对象时先调用此方法，所以适合在使用对象前做一些初始化工作。 Note: 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承。 析构函数 析构函数会在某个对象的所有引用都被删除或者当对象被显式销毁时执行。 访问控制被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其自身访问。例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** * Define MyClass */class MyClass&#123; public $public = 'Public'; protected $protected = 'Protected'; private $private = 'Private'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj = new MyClass();echo $obj-&gt;public; // 这行能被正常执行echo $obj-&gt;protected; // 这行会产生一个致命错误echo $obj-&gt;private; // 这行也会产生一个致命错误$obj-&gt;printHello(); // 输出 Public、Protected 和 Private/** * Define MyClass2 */class MyClass2 extends MyClass&#123; // 可以对 public 和 protected 进行重定义，但 private 而不能 protected $protected = 'Protected2'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj2 = new MyClass2();echo $obj2-&gt;public; // 这行能被正常执行echo $obj2-&gt;private; // 未定义 privateecho $obj2-&gt;protected; // 这行会产生一个致命错误$obj2-&gt;printHello(); // 输出 Public、Protected2 和 Undefined 抽象类定义为抽象的类不能被实例化。如果某个类里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。 继承一个抽象类时，子类必须定义父类中的所有抽象方法；另外这些方法的访问控制必须和父类中一样（或者更为宽松） TraitPHP是单继承语言，trait是为这种单继承语言而准备的一种代码复用机制，Trait使开发人员可以自由的在不同层次结构内独立的类中复用方法。示例如下： 1234567891011121314151617&lt;?phptrait ezcReflectionReturnInfo &#123; function getReturnType() &#123; /*1*/ &#125; function getReturnDescription() &#123; /*2*/ &#125;&#125;class ezcReflectionMethod extends ReflectionMethod &#123; use ezcReflectionReturnInfo; /* ... */&#125;class ezcReflectionFunction extends ReflectionFunction &#123; use ezcReflectionReturnInfo; /* ... */&#125;?&gt; 优先级从基类继承的成员会被trait插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了trait的方法，而trait则覆盖了被继承的方法。例： 1234567891011121314151617&lt;?phptrait HelloWorld &#123; public function sayHello() &#123; echo 'Hello World!'; &#125;&#125;class TheWorldIsNotEnough &#123; use HelloWorld; public function sayHello() &#123; echo 'Hello Universe!'; &#125;&#125;$o = new TheWorldIsNotEnough();$o-&gt;sayHello();?&gt; 以上例程会输出： Hello Universe! 重载重载是指动态的”创建”类属性和方法。是通过魔术方法来实现的。 当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。 属性重载 在给不可访问（或未定义）属性赋值时，__set()会被调用 在读取不可访问（或未定义）属性时，__get()会被调用 当对不可访问（或未定义）属性调用isset()或empty()时，__isset()会被调用 当对不可访问（或未定义）属性调用unset()时，__unset()会被调用 方法重载使用__call()函数和__callStatic()函数 在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP手册【2】——变量、常量、函数","date":"2017-04-09T16:00:00.000Z","path":"2017/04/10/review-php-02/","text":"变量变量范围变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的PHP变量只有一个单独的范围。这个单独的范围跨度同样包含了include和require引入的文件。例如： 1234&lt;?php $a = 1; include 'b.php';?&gt; 这里变量$a将会在包含文件b.php中生效。但是，在用户自定义函数中，一个局部函数范围将被引入，任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。例如 123456789&lt;?php $a =1;//全局 function Test() &#123; echo $a; //位于函数内部 &#125; Test()； ?&gt; 这个脚本将不会有任何输出，因为echo语句引用了一个局部版本的变量$a，它并没有被赋值。PHP的全局变量和C语言的有一点点不同，在C语言中，全局变量在函数中自动生效，除非被局部变量覆盖。而PHP中全局变量在函数中使用时必须声明为global。 global关键字例： 1234567891011&lt;？php $a = 1; $b = 2; function sum() &#123; global $a,$b; $b = $a + $b; &#125; sum(); echo $b;?&gt; 以上脚本的输出将是3。 在函数中声明了全局变量 $a 和 $b 之后，对任一变量的所有引用都会指向其全局版本。对于一个函数能够声明的全局变量的最大个数，PHP 没有限制。 在全局范围内访问变量的第二个办法，是用特殊的 PHP 自定义 $GLOBALS 数组。 使用静态变量变量范围的另一个重要特性是静态变量（static variable）。静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不会丢失。例如： 12345678&lt;?php function test() &#123; $a = 0; echo $a; $a++; &#125;?&gt; 该函数没什么用处，因为每次调用时都会将$a的值设为0并输出0。将变量加一的$a++没有作用，因为一旦退出本函数则变量$a就不存在了。要写一个不会丢失本次计数值的技术函数，要将变量$a定义为静态的。如下例子： 12345678&lt;?php function test() &#123; static $a = 0; echo $a; $a++; &#125;?&gt; 现在，变量$a仅在第一次调用test()函数时被初始化，之后每次调用test()函数都会输出$a的值并加一。 静态变量也提供了一种处理递归函数的方法。写递归函数的时候，可能会无穷递归下去。必须确保有充分的方法来终止递归。以下的简单的例子说明使用静态变量来判断何时停止。 12345678910111213&lt;?php function test() &#123; static $count = 0; $count++; echo $count; if($count &lt; 10) &#123; test(); &#125; $count--; &#125;?&gt; 可变变量将变量名再赋予某个变量 可变函数将函数名赋予某个变量，当调用该变量外加括号时，即调用该函数。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"计算机组成","date":"2017-03-21T16:00:00.000Z","path":"2017/03/22/Computer/","text":"冯诺依曼结构的工作原理计算机组成的依据是冯诺依曼结构，它将计算机分为以下五大组成部分： 运算器+控制器（CPU） 存储器（内存） 输入设备 输出设备 数据和指令以二进制形式，不加区别的存放在存储器中。 速度不匹配问题由于CPU的运行速度非常快，与主存储器，磁盘的I/O速度相差非常大（千百倍以上），为了解决这个问题，计算机采用将CPU “忙死” 的方法。对于程序的执行采用以下方案： 同步 =&gt; 异步 即CPU在运行程序时，当某个程序需要它来运行时它才动作，不需要它运行时，CPU去运行别的程序去。 顺序 =&gt; 并发 将多个程序并发执行，CPU在这些程序里进行很快速的切换（由操作系统控制），这样会使人觉得好像每个程序同时运行一样，其实在每个时间点时（极短），CPU只执行一个程序。 增加中间层：缓存 1、当CPU要读取一个数据时，首先从CPU缓存中查找，找到就立刻读取并送给CPU处理；2、没有找到，就从速率相对较慢的内存中读取并送给CPU处理，同时把这个数据所在的数据块调入缓存中，可以使得以后对CPU数据的读取都从缓存中进行，不必在调用内存。 按下电源之后发生了什么 按下电源，主板开始供电 主板向CPU发出RESET信号 当RESET信号撤去后，CPU开始干活，去一个特定的内存地址查找第一条指令（这是一条跳转指令，跳转到系统BIOS中真正的启动代码处） BIOS的代码对系统进行自检：内存，硬盘，显卡..如果硬件出现问题，主板会发出不同含义的蜂鸣，启动终止。如果没有问题，屏幕就会出现CPU、内存、硬盘等信息。 hello world的一生 程序写好了以后，编译成二进制文件（包含机器语言指令），存放在硬盘中。 运行hello world程序，操作系统吧helloworld从硬盘读到内存 CPU开始执行main程序中的机器语言指令 机器语言指令把”helloworld”字符串从内存复制到寄存器 机器语言把寄存器数据复制到显示设备，显示在屏幕上。","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://www.tenpercent.top/tags/计算机基础/"}]},{"title":"重温PHP手册【1】——基础句法和类型","date":"2017-03-10T16:00:00.000Z","path":"2017/03/11/review-php-01/","text":"前言：最近想开始好好提升一下自己的英语水平，因为感觉熟练的英语是每一个优秀软件工程师的基本功，虽然是一枚过了六级的选手，但是感觉英文阅读和写作都还是有些压力。正巧听闻有个PHP高手说他把PHP官方手册读了不下8遍，深以为然，孰能生巧这个道理放在哪里都没有错。所以第一步我打算开始重温PHP手册，在加强自己英语水平的同时来达到温故而知新的目的。 1、PHP tagsWhen PHP parses a file, it look for opening and closing tags, which are &lt;?phpand ?&gt; which tell PHP to start and stop interpreting the code between them.if a file is pure PHP code, it is preferable to omit the PHP closing tag at the end of the file. This prevents accidental whitespace or new lines being added after the PHP closing tag, which may cause unwanted effects because PHP will start output buffering when there is no intention from the programmer to send any output at that point in the script. 12345&lt;?php echo \"hello chenjiehui!\"; //...more code echo \"last statement.\"; // the script ends here with no PHP closing tag 2、Escaping from HTMLEverything outside of a pair of opening and closing tags is ignored by the PHP parser which allows PHP files to have mixed content. This allows PHP to be embedded in HTML documents.But there is one exception that in the middle of a conditional statement in which case the interpreter will determine the outcome of the confitional before making a decision of what to skip over. See the next example. Using structures with conditions. 12345&lt;?php if($expression == true) : ?&gt; This will show if the expression is true.&lt;?php else : ?&gt; Otherwise this will show.&lt;?php endif; ?&gt; In this example PHP will ship the blocks where the condition is not met, even though they are outside of the PHP open/close tags;For outputting large blocks of text, dropping out of PHP parsing mode is generally more effcient than sending all of text through echo or print. Starting with PHP 5.4, short echo tag &lt;?= is always recongnized and vaild, regardless of the short_open_tag setting. 3、CommentsPHP support ‘C’,’C++’ and Unix shell-style(Perl style) comments. For example: 1234567&lt;?php echo 'this is a test'; //this is a one line c++ style comment /* This is a multi line comment yet another line of comment */ echo 'This is yet another test'; echo 'one Final Test'; # This is a one-line shell-style comment?&gt; ##4、typePHP supports eight primitive types(原始数据类型): Four scalar types(标量类型): boolean integer float(aka(又称作) double) string Three compound types: array object callable And finally two special types resource NULL This manual also introduces some pseudo-types(伪类型) for readability reasons： mixed number callback array|object void And the pseudo-variable $…The type of the variable is not usually set by programmer; rather(确切的说), it is decided at runtime by PHP depending on the context in which that variable is used. Note: To check the type and variable of the expression, use the var_dump() function.To get a human-readable representation of a type for debugging, use the gettype() function. To check for a certain type, do not use gettype(), but rather the is_type functions. Some examples: 123456789101112131415&lt;?php $a_bool = TRUE ; $a_str = \"foo\"; $a_str2 = 'foo'; $an_int = 12; echo gettype($a_bool);//print out: boolean echo gettype($a_str);//print out: string if(is_int($an_int))&#123; $an_int+=4; &#125; if (is_string($a_bool)) &#123; echo \"String: $a_bool\"; &#125;?&gt;&gt; To forcibly(强制地) convert a variable to a certain type, either cast(eg: (bool)$a_str) or use the settype() function on it.Note that a variable may be evaluated(被评估) with diffrent values in certain situations, depending on what type it is at the time.","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]}]