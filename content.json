[{"title":"重温PHP【3】——类与对象（-）","date":"2017-04-21T16:00:00.000Z","path":"2017/04/22/review-php-03/","text":"类与对象构造函数和析构函数 构造函数 具有构造函数的类会在每次创建新对象时先调用此方法，所以适合在使用对象前做一些初始化工作。 Note: 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承。 析构函数 析构函数会在某个对象的所有引用都被删除或者当对象被显式销毁时执行。 访问控制被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其自身访问。例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** * Define MyClass */class MyClass&#123; public $public = 'Public'; protected $protected = 'Protected'; private $private = 'Private'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj = new MyClass();echo $obj-&gt;public; // 这行能被正常执行echo $obj-&gt;protected; // 这行会产生一个致命错误echo $obj-&gt;private; // 这行也会产生一个致命错误$obj-&gt;printHello(); // 输出 Public、Protected 和 Private/** * Define MyClass2 */class MyClass2 extends MyClass&#123; // 可以对 public 和 protected 进行重定义，但 private 而不能 protected $protected = 'Protected2'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj2 = new MyClass2();echo $obj2-&gt;public; // 这行能被正常执行echo $obj2-&gt;private; // 未定义 privateecho $obj2-&gt;protected; // 这行会产生一个致命错误$obj2-&gt;printHello(); // 输出 Public、Protected2 和 Undefined 抽象类定义为抽象的类不能被实例化。如果某个类里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。 继承一个抽象类时，子类必须定义父类中的所有抽象方法；另外这些方法的访问控制必须和父类中一样（或者更为宽松） TraitPHP是单继承语言，trait是为这种单继承语言而准备的一种代码复用机制，Trait使开发人员可以自由的在不同层次结构内独立的类中复用方法。示例如下： 1234567891011121314151617&lt;?phptrait ezcReflectionReturnInfo &#123; function getReturnType() &#123; /*1*/ &#125; function getReturnDescription() &#123; /*2*/ &#125;&#125;class ezcReflectionMethod extends ReflectionMethod &#123; use ezcReflectionReturnInfo; /* ... */&#125;class ezcReflectionFunction extends ReflectionFunction &#123; use ezcReflectionReturnInfo; /* ... */&#125;?&gt; 优先级从基类继承的成员会被trait插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了trait的方法，而trait则覆盖了被继承的方法。例： 1234567891011121314151617&lt;?phptrait HelloWorld &#123; public function sayHello() &#123; echo 'Hello World!'; &#125;&#125;class TheWorldIsNotEnough &#123; use HelloWorld; public function sayHello() &#123; echo 'Hello Universe!'; &#125;&#125;$o = new TheWorldIsNotEnough();$o-&gt;sayHello();?&gt; 以上例程会输出： Hello Universe! 重载重载是指动态的”创建”类属性和方法。是通过魔术方法来实现的。 当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。 属性重载 在给不可访问（或未定义）属性赋值时，__set()会被调用 在读取不可访问（或未定义）属性时，__get()会被调用 当对不可访问（或未定义）属性调用isset()或empty()时，__isset()会被调用 当对不可访问（或未定义）属性调用unset()时，__unset()会被调用 方法重载使用__call()函数和__callsStatic()函数 在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP【2】——变量、常量、函数","date":"2017-04-09T16:00:00.000Z","path":"2017/04/10/review-php-02/","text":"变量变量范围变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的PHP变量只有一个单独的范围。这个单独的范围跨度同样包含了include和require引入的文件。例如： 1234&lt;?php $a = 1; include 'b.php';?&gt; 这里变量$a将会在包含文件b.php中生效。但是，在用户自定义函数中，一个局部函数范围将被引入，任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。例如 123456789&lt;?php $a =1;//全局 function Test() &#123; echo $a; //位于函数内部 &#125; Test()； ?&gt; 这个脚本将不会有任何输出，因为echo语句引用了一个局部版本的变量$a，它并没有被赋值。PHP的全局变量和C语言的有一点点不同，在C语言中，全局变量在函数中自动生效，除非被局部变量覆盖。而PHP中全局变量在函数中使用时必须声明为global。 global关键字例： 1234567891011&lt;？php $a = 1; $b = 2; function sum() &#123; global $a,$b; $b = $a + $b; &#125; sum(); echo $b;?&gt; 以上脚本的输出将是3。 在函数中声明了全局变量 $a 和 $b 之后，对任一变量的所有引用都会指向其全局版本。对于一个函数能够声明的全局变量的最大个数，PHP 没有限制。 在全局范围内访问变量的第二个办法，是用特殊的 PHP 自定义 $GLOBALS 数组。 使用静态变量变量范围的另一个重要特性是静态变量（static variable）。静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不会丢失。例如： 12345678&lt;?php function test() &#123; $a = 0; echo $a; $a++; &#125;?&gt; 该函数没什么用处，因为每次调用时都会将$a的值设为0并输出0。将变量加一的$a++没有作用，因为一旦退出本函数则变量$a就不存在了。要写一个不会丢失本次计数值的技术函数，要将变量$a定义为静态的。如下例子： 12345678&lt;?php function test() &#123; static $a = 0; echo $a; $a++; &#125;?&gt; 现在，变量$a仅在第一次调用test()函数时被初始化，之后每次调用test()函数都会输出$a的值并加一。 静态变量也提供了一种处理递归函数的方法。写递归函数的时候，可能会无穷递归下去。必须确保有充分的方法来终止递归。以下的简单的例子说明使用静态变量来判断何时停止。 12345678910111213&lt;?php function test() &#123; static $count = 0; $count++; echo $count; if($count &lt; 10) &#123; test(); &#125; $count--; &#125;?&gt; 可变变量将变量名再赋予某个变量 可变函数将函数名赋予某个变量，当调用该变量外加括号时，即调用该函数。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"计算机组成","date":"2017-03-21T16:00:00.000Z","path":"2017/03/22/Computer/","text":"冯诺依曼结构的工作原理计算机组成的依据是冯诺依曼结构，它将计算机分为以下五大组成部分： 运算器+控制器（CPU） 存储器（内存） 输入设备 输出设备 数据和指令以二进制形式，不加区别的存放在存储器中。 速度不匹配问题由于CPU的运行速度非常快，与主存储器，磁盘的I/O速度相差非常大（千百倍以上），为了解决这个问题，计算机采用将CPU “忙死” 的方法。对于程序的执行采用以下方案： 同步 =&gt; 异步 即CPU在运行程序时，当某个程序需要它来运行时它才动作，不需要它运行时，CPU去运行别的程序去。 顺序 =&gt; 并发 将多个程序并发执行，CPU在这些程序里进行很快速的切换（由操作系统控制），这样会使人觉得好像每个程序同时运行一样，其实在每个时间点时（极短），CPU只执行一个程序。 增加中间层：缓存 1、当CPU要读取一个数据时，首先从CPU缓存中查找，找到就立刻读取并送给CPU处理；2、没有找到，就从速率相对较慢的内存中读取并送给CPU处理，同时把这个数据所在的数据块调入缓存中，可以使得以后对CPU数据的读取都从缓存中进行，不必在调用内存。 按下电源之后发生了什么 按下电源，主板开始供电 主板向CPU发出RESET信号 当RESET信号撤去后，CPU开始干活，去一个特定的内存地址查找第一条指令（这是一条跳转指令，跳转到系统BIOS中真正的启动代码处） BIOS的代码对系统进行自检：内存，硬盘，显卡..如果硬件出现问题，主板会发出不同含义的蜂鸣，启动终止。如果没有问题，屏幕就会出现CPU、内存、硬盘等信息。 hello world的一生 程序写好了以后，编译成二进制文件（包含机器语言指令），存放在硬盘中。 运行hello world程序，操作系统吧helloworld从硬盘读到内存 CPU开始执行main程序中的机器语言指令 机器语言指令把”helloworld”字符串从内存复制到寄存器 机器语言把寄存器数据复制到显示设备，显示在屏幕上。","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://www.tenpercent.top/tags/计算机基础/"}]},{"title":"重温PHP【1】——基础句法和类型","date":"2017-03-10T16:00:00.000Z","path":"2017/03/11/review-php-01/","text":"前言：最近想开始好好提升一下自己的英语水平，因为感觉熟练的英语是每一个优秀软件工程师的基本功，虽然是一枚过了六级的选手，但是感觉英文阅读和写作都还是有些压力。正巧听闻有个PHP高手说他把PHP官方手册读了不下8遍，深以为然，孰能生巧这个道理放在哪里都没有错。所以第一步我打算开始重温PHP手册，在加强自己英语水平的同时来达到温故而知新的目的。 1、PHP tagsWhen PHP parses a file, it look for opening and closing tags, which are &lt;?phpand ?&gt; which tell PHP to start and stop interpreting the code between them.if a file is pure PHP code, it is preferable to omit the PHP closing tag at the end of the file. This prevents accidental whitespace or new lines being added after the PHP closing tag, which may cause unwanted effects because PHP will start output buffering when there is no intention from the programmer to send any output at that point in the script. 12345&lt;?php echo \"hello chenjiehui!\"; //...more code echo \"last statement.\"; // the script ends here with no PHP closing tag 2、Escaping from HTMLEverything outside of a pair of opening and closing tags is ignored by the PHP parser which allows PHP files to have mixed content. This allows PHP to be embedded in HTML documents.But there is one exception that in the middle of a conditional statement in which case the interpreter will determine the outcome of the confitional before making a decision of what to skip over. See the next example. Using structures with conditions. 12345&lt;?php if($expression == true) : ?&gt; This will show if the expression is true.&lt;?php else : ?&gt; Otherwise this will show.&lt;?php endif; ?&gt; In this example PHP will ship the blocks where the condition is not met, even though they are outside of the PHP open/close tags;For outputting large blocks of text, dropping out of PHP parsing mode is generally more effcient than sending all of text through echo or print. Starting with PHP 5.4, short echo tag &lt;?= is always recongnized and vaild, regardless of the short_open_tag setting. 3、CommentsPHP support ‘C’,’C++’ and Unix shell-style(Perl style) comments. For example: 1234567&lt;?php echo 'this is a test'; //this is a one line c++ style comment /* This is a multi line comment yet another line of comment */ echo 'This is yet another test'; echo 'one Final Test'; # This is a one-line shell-style comment?&gt; ##4、typePHP supports eight primitive types(原始数据类型): Four scalar types(标量类型): boolean integer float(aka(又称作) double) string Three compound types: array object callable And finally two special types resource NULL This manual also introduces some pseudo-types(伪类型) for readability reasons： mixed number callback array|object void And the pseudo-variable $…The type of the variable is not usually set by programmer; rather(确切的说), it is decided at runtime by PHP depending on the context in which that variable is used. Note: To check the type and variable of the expression, use the var_dump() function.To get a human-readable representation of a type for debugging, use the gettype() function. To check for a certain type, do not use gettype(), but rather the is_type functions. Some examples: 123456789101112131415&lt;?php $a_bool = TRUE ; $a_str = \"foo\"; $a_str2 = 'foo'; $an_int = 12; echo gettype($a_bool);//print out: boolean echo gettype($a_str);//print out: string if(is_int($an_int))&#123; $an_int+=4; &#125; if (is_string($a_bool)) &#123; echo \"String: $a_bool\"; &#125;?&gt;&gt; To forcibly(强制地) convert a variable to a certain type, either cast(eg: (bool)$a_str) or use the settype() function on it.Note that a variable may be evaluated(被评估) with diffrent values in certain situations, depending on what type it is at the time.","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"操作系统【1】——导论","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/operating-system-01/","text":"操作系统是管理计算机硬件的程序，它还为应用程序提供基础，并充当计算机硬件和计算机用户的中介。大型机的操作系统设计主要目的是为了充分优化硬件的使用率，个人计算机的操作系统是为了能够支持从复杂游戏到商业应用的各种事物，手持计算机的操作系统是为了给用户一个可以与计算机方便的交互并执行程序的环境。因此，有的操作系统设计是为了方便，有的是为了高效，而有的设计目标则是兼而有之。 本章目标 提供对操作系统主要部件的浏览 提供基本的计算机系统体系结构的概述 1.1 操作系统做什么从计算机的角度来看，操作系统是与硬件最为密切的程序。计算机系统可能有许多资源，用来解决CPU时间、内存时间、文件存储空间、I/O设备等问题。操作系统管理这些资源。面对许多甚至冲突的请求，操作系统必须决定如何为各个程序和用户分配资源，以便计算机系统能够有效而公平的运行。众所周知，资源分配对多用户访问主机或微型计算机特别重要。操作系统是控制程序。控制程序管理用户程序的执行以防止计算机资源的错误使用或使用不当。它特别关注I/O设备的操作和控制。 1.1.1 定义操作系统一个比较公认的定义是，操作系统是一直运行在计算机上的程序（通常称之为内核），其他程序为系统程序和应用程序。 1.2 计算机系统组织1.2.1 计算机系统操作当计算机打开电源或重启时，计算机开始运行，它需要运行一个初始化程序，该初始化程序或引导程序（bootstrap program）比较简单，通常位于ROM或EEPROM中，称为计算机硬件中的固件。它初始化系统中的所有部分，包括CPU寄存器、设备控制器和内存内容。引导程序必须知道如何装入操作系统并开始执行系统。为了完成这一目标，引导程序必须定位操作系统内核并把它转入内存，接着，操作系统孔i是执行第一个进程如init，并等待事件的发生。事件的发生通常通过硬件或软件中断（interrupt）。硬件可随时通过系统总线向CPU发出信号，以触发中断。软件通过执行特别操作如系统调用（system call）也称为监视器调用（monitor call））也能触发中断。 1.2.2 存储结构计算机程序必须在内存（或随机访问内存（random access memory）RAM ）中以便于运行。内存是处理器可以直接访问的唯一的大容量存储区域（数兆到数千兆字节）。它通常是用被称为动态随机访问内存（dynamic random access memory,DRAM）的半导体技术来实现的，是一组内存字的数组，每个字都有其地址。通过对特定内存地址执行一系列load或store指令来实现交互。指令load能将内存中的字转移到CPU的寄存器中，而指令store能将寄存器的内容移到内存。除了显式使用load和store外，CPU可自动从内存中装入指令来执行。 一个典型指令执行周期（在冯诺依曼体系结构上执行时）首先从内存中获取指令，并保存在指令寄存器中。接着，指令被解码，并可能导致从内存中获取操作数或将操作数保存在内部寄存器中。在指令完成对操作数的执行，其结果可以存回到内存。注意内存单元只看见内存地址流，它并不知道它们是如何产生，或者它们是什么地址。相应地，可忽视程序如何产生内存地址，只对程序运行所产生的地址序列感兴趣。 由于内存太小以及内存是易失性存储设备，所以绝大多数计算机需要提供辅存，最常用的辅存设备为磁盘，它能存储程序和数据。绝大多数程序（浏览器，编译器，制表软件等）保存在磁盘上，直到要执行时才装入到内存中。许多程序都是使用磁盘来作为它们所处理信息的来源和目的。因此，适当的管理磁盘存储对计算机系统来说十分重要。 存储设备层次 寄存器 =&gt; 高速缓存 =&gt; 主存 =&gt; 电子磁盘 =&gt; 磁盘 =&gt; 光盘 =&gt; 磁带 1.3 计算机系统体系结构 单处理器系统 绝大多数系统采用单处理器，在单处理器系统中，有一个主CPU能够执行一个通用的指令集，包括来自于用户进程的指令。 多处理器系统 多处理器系统有多个紧密通信的CPU，它们共享计算机总线，有时还有时钟、没存和外设等。多处理器系统主要有三个优点： 1、增加吞吐量：通过增加处理器的数量，希望能够在更短的时间内做更多的事情。用N个处理器的加速比不是N，而是比N小。当多个CPU在同一件事情上时，为了使得各部分能正确工作，会产生一定的额外开销。这些开销，加上对共享资源的竞争，会降低因为增加了CPU的期望增益。这与一组N为程序员在一起紧密地工作，并不能完成N倍的单个程序员的工作量类似。 2、规模经济：多处理器系统比单个处理器系统能节省资金。 3、增加可靠性：如果将功能分布在多个处理器上，那么单个处理器的失灵将不会使得整个系统停止，只会使它变慢。如果有一个处理器出现故障，那么剩下的处理器会分担起故障处理器的那部分工作。 1.3.1 集群系统多CPU系统的另一种类型是集群系统（clustered system）。与多处理器系统一样，集群系统将多个CPU集中起来完成计算任务。然而，集群系统与多处理器系统不同，它是由两个或多个独立的系统耦合起来的。集群系统通常用来提供高可用服务，这意味着即使集群中的一个或多个系统出错，服务仍在运行。 集群分为非对称集群和对称集群 非对称集群 一台机器处于热备份模式（hot standby mode），而另一台运行应用程序。热备份主机只监视活动服务器。如果该服务器失效，那么热备份主机会成为现行服务器 对称集群 两个或者多个主机都运行应用程序，它们互相监视。这种模式因为充分使用了现有硬件，所以更为高效。","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://www.tenpercent.top/tags/计算机基础/"}]}]