[{"title":"PHP单例模式的学习和总结","date":"2017-06-19T16:00:00.000Z","path":"2017/06/20/Singleton-Pattern/","text":"什么是单例模式含义单例模式是一种对象的创建模式，它用来确保某一个类只有一个实例，而且自行实例化并向整个系统全局的提供这个实例。 单例模式的特点1、有一个保存类的唯一实例的静态成员变量 2、有一个定义为私有的构造函数，表明这个类是不可能形成实例的，防止出现这个类有多个实例的情况出现（有时也可添加个声明为私有的克隆函数）。 3、提供一个能访问这个实例的声明为公共的静态方法（通常为getInstance方法），用来作为返回唯一实例的引用。 具体实现代码： 1234567891011121314151617181920212223242526272829class Preferences &#123; private $props = array(); private static $instance; private function __construct()&#123; &#125; private function __clone()&#123;&#125;; public static function getInstance()&#123; if(empty(self::$instance))&#123; self::$instance = new Preferences(); &#125; return self::$instance; &#125; public function setProperty($key,$val)&#123; $this-&gt;props[$key] = $val; &#125; public function getProperty($key)&#123; return $this-&gt;props[$key]; &#125; &#125;//调用单例 $pref = Preferences::getInstance(); $pref-&gt;setProperty('name','cjhlfy'); unset($pref); $pref2 = Preferences::getInstance(); echo $pref2-&gt;getProperty('name'); //name的属性值不会丢失,因为实例引用 $instance是静态属性 为什么要用单例模式全局变量是面向对象程序员遇到的引发bug的主要原因之一，这是因为全局变量将捆绑于特定的环境，破坏了封装。如果新的应用程序无法保证一开始就定义了相同的全局变量，那么一个依赖于全局变量的类就无法就无法从一个应用程序中提取出来并应用到新的应用程序中。所以单例模式是一种对于全局变量的改进。 不过，单例模式的使用也有不利的地方，它可能导致很难调试的依赖关系。如果改变一个实例，那么所有使用改单例的类可能都会受到影响。当单例被使用时，依赖便会隐藏在方法内部，而且并不会出现在方法声明里。这使得系统中的依赖关系更难以追踪，因此需要谨慎小心的部署单例类 单例模式应用应用场合1、应用程序与数据库的交互 一个应用中会存在大量的数据库操作，比如通过数据库句柄来连接数据库这一行为，使用单例模式可以避免大量的new操作，因为每一次new操作都会消耗内存资源和系统资源。 2、控制配置信息 如果系统中有有一个类来全局控制某些配置信息，那么使用单例模式就可以很方便实现，并且可以对配置进行同意管理。 以数据库操作为例深入理解12345678910111213141516171819202122232425262728293031323334class DB &#123; private $db; private static $instance; private function __construct()&#123; //进行数据库连接 &#125; private function __clone() &#123; &#125;; public static function getInstance()&#123; if(empty(self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; //数据库查询操作 public function select()&#123; //... &#125; //数据库插入操作 public function insert()&#123; //... &#125;&#125; //数据库编辑操作 public function update()&#123; //... &#125;&#125; //获取数据库单例类实例化之后，便可对数据库进行操作$db = DB::getInstance();$db-&gt;select();$db-&gt;insert();$db-&gt;update(); 单例模式的总结就到这里。 参考：《面向对象、模式与实践》","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"数据库查询中的exists与in分析比较","date":"2017-06-07T16:00:00.000Z","path":"2017/06/08/about-exists/","text":"最近在用Laravel的ORM写数据库查询时，用到了whereHas的写法，这个写法的背后实现的SQL语句就是select * from `table1` where exists(select * from `table2` where table1.id = table2.table1_id),于是就查清楚了一下exists的用法和特点，在这里记录一下。 exists的用法以下图的两张表关系作为分析： exists表示存在，它常常和子查询配合使用。例如对于上图，写下下面的SQL语句 SELECT FROM `user` WHERE exists (SELECT FROM `order` WHERE user.id = order.user_id) 在这里，exists用于检查查询子查询语句是否会至少返回一行数据，如果有返回数据，则返回值是true，反之是false。 放子查询返回为true时，则外层的查询语句将进行查询，反之，外层查询语句将不进行查询或者查不出任何记录。 因此：上面的SQL所实现的意义在于，搜索出所有下过单的会员。 exists和in的区别和使用场景除了exitst，in的使用也可以实现上面语句的效果。如下： SELECT * FROM `user` WHERE id in (SELECT user_id FROM `order`) 那么，它们之间有什么区别呢。 in()语句只会执行一次，它查出order表中的所有user_id字段并且缓存起来，之后，检查user表的id是否和order表中的user_id相当，如果相等则加入结果期，直到遍历完user的所有记录。用程序来表示如下： 123456789101112131415161718192021222324252627$result = [];$users = \"SELECT * FROM `user`\";$orders = \"SELECT user_id FROM `order`\";for($i = 0;$i &lt; $users.length;$i++)&#123; for($j = 0;$j &lt; $orders.length;$j++)&#123; // 此过程为内存操作，不涉及数据库查询。 if($users[$i].id == $orders[$j].user_id)&#123; $result[] = $users[$i]; break; &#125; &#125;&#125;``` 从上面的程序可以明显的看出，当order表数据很大的时候不适合用in,因为最多会将order表数据全部遍历一遍。如：user表有10000条记录,order表有1000000条记录,那么最多有可能遍历10000*1000000次,这样的话效率就很差了。* 再看exists，它的查询过程类似如下：```php $result = [];$users = \"SELECT * FROM `user`\";for($i=0;$i&lt;$users.length;$i++)&#123; if(exists($users[$i].id))&#123;// 执行SELECT * FROM `order` WHERE user.id = order.user_id $result[] = $users[$i]; &#125;&#125; 显而易见：当order表比user表大很多的时候，使用exists是再恰当不过了，它没有那么多遍历操作,只需要再执行一次查询就行。查询次数的多少完全取决于user表的记录条数。 但是：如果说user表有10000条记录,order表有100条记录,那么exists()还是执行10000次,反而不如使用in()遍历10000*100次,因为in()是在内存里遍历,而exists()需要查询数据库,我们都知道查询数据库所消耗的性能比较大,而操作内存的话会比较快. 因此，可以得出总结： 若外层查询表小于子查询表，则用exists。 若外层查询表(记录条数很多)远大于子查询表，则考虑用in。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"}]},{"title":"PHP的匿名函数和闭包","date":"2017-05-23T16:00:00.000Z","path":"2017/05/24/php-closure/","text":"匿名函数匿名函数（Anonymous function），也叫闭包函数（closures），允许临时创建一个没有指定名称的函数，最经常用作回调函数（callback）参数的值。 匿名函数的实现匿名函数是目前是通过Closure类来实现，匿名函数会产生这个类的对象。自PHP 5.4起，这个类带有一些方法，允许在匿名函数创建后对其进行更多的控制。 注意：PHP手册特别说明__invoke()这个魔术方法与匿名函数的实现过程无关。 Closure类如下： 12345678910Closure &#123; /* 方法 */ __construct ( void ) public static Closure bind ( Closure $closure , object $newthis [, mixed $newscope = 'static' ] ) public Closure bindTo ( object $newthis [, mixed $newscope = 'static' ] ) &#125;Closure::__construct — 用于禁止实例化的构造函数Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。 匿名函数例子： 1234$func = function($str)&#123; echo $str;&#125;;$func('hello'); 闭包闭包是指在创建时封装周围状态(如变量)的函数，即使闭包所在的环境的不存在了，闭包中封装的状态依然存在。 闭包的实现将匿名函数放在一个普通函数中（也可以将匿名函数返回），就构成了一个闭包。 1234567function closureFunc()&#123; $func = function()&#123; echo 'hello'; &#125; $func();&#125;closureFunc();//输出:hello 闭包的使用在匿名函数中引入局部变量时需要用到use关键字。这是因为PHP中的变量范围只在它的生效范围中。在匿名函数里并没有对变量进行定义，所以需要使用use关键字 123456789function closureFunc1()&#123; $num = 1; $func = function() use($num)&#123; echo $num; &#125;; $func();&#125;closureFunc2();//输出 闭包返回匿名函数并传参 12345678910function closureFunc2()&#123; $num = 1; $func = function($str) use($num)&#123; echo $num; echo $str; &#125;; return $func;&#125;$func = $closureFunc2();$func('hello');//输出 1 hello","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP手册【4】——类与对象（二）","date":"2017-05-09T16:00:00.000Z","path":"2017/05/10/review-php-04/","text":"Final关键字如果父类中的方法被声明为final,则子类无法继承。如果一个类被声明为final，则不能被继承。 NOTE: 属性不能被定义为final,只有类和方法才能被定义为final. 类型约束类型约束即函数的参数可以指定必须为对象、接口、数组或者callable。如果一个类或接口。类型约束不能用于标量类型如int或string。Trait也不允许。例子如下： 1234567891011121314151617181920212223242526272829303132class MyClass&#123; /** * 测试函数 * 第一个参数必须为 OtherClass 类的一个对象 */ public function test(OtherClass $otherclass)&#123; echo $otherclass-&gt;var; &#125; /** * 另一个测试函数 * 第一个参数必须为数组 */ public function test_array(array $input_array) &#123; print_r($input_array); &#125; /** * 第一个参数必须为递归类型 */ public function test_interface(Traversable $iterator) &#123; echo get_class($iterator); &#125; /** * 第一个参数必须为回调类型 */ public function test_callable(callable $callback, $data) &#123; call_user_func($callback, $data); &#125;&#125; 当函数调用的参数与定义的参数类型不一致时，会抛出一个致命的错误。 后期静态绑定这个目前不知道什么用处，先直接看例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Example #1 self:: 用法&lt;?phpclass A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; self::who(); &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test();?&gt;以上例程会输出：AExample #2 static:: 简单用法&lt;?phpclass A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; static::who(); // 后期静态绑定从这里开始 &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test();?&gt;以上例程会输出：B","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP手册【3】——类与对象（-）","date":"2017-04-22T16:00:00.000Z","path":"2017/04/23/review-php-03/","text":"类与对象构造函数和析构函数 构造函数 具有构造函数的类会在每次创建新对象时先调用此方法，所以适合在使用对象前做一些初始化工作。 Note: 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承。 析构函数 析构函数会在某个对象的所有引用都被删除或者当对象被显式销毁时执行。 访问控制被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其自身访问。例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** * Define MyClass */class MyClass&#123; public $public = 'Public'; protected $protected = 'Protected'; private $private = 'Private'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj = new MyClass();echo $obj-&gt;public; // 这行能被正常执行echo $obj-&gt;protected; // 这行会产生一个致命错误echo $obj-&gt;private; // 这行也会产生一个致命错误$obj-&gt;printHello(); // 输出 Public、Protected 和 Private/** * Define MyClass2 */class MyClass2 extends MyClass&#123; // 可以对 public 和 protected 进行重定义，但 private 而不能 protected $protected = 'Protected2'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj2 = new MyClass2();echo $obj2-&gt;public; // 这行能被正常执行echo $obj2-&gt;private; // 未定义 privateecho $obj2-&gt;protected; // 这行会产生一个致命错误$obj2-&gt;printHello(); // 输出 Public、Protected2 和 Undefined 抽象类定义为抽象的类不能被实例化。如果某个类里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。 继承一个抽象类时，子类必须定义父类中的所有抽象方法；另外这些方法的访问控制必须和父类中一样（或者更为宽松） TraitPHP是单继承语言，trait是为这种单继承语言而准备的一种代码复用机制，Trait使开发人员可以自由的在不同层次结构内独立的类中复用方法。示例如下： 1234567891011121314151617&lt;?phptrait ezcReflectionReturnInfo &#123; function getReturnType() &#123; /*1*/ &#125; function getReturnDescription() &#123; /*2*/ &#125;&#125;class ezcReflectionMethod extends ReflectionMethod &#123; use ezcReflectionReturnInfo; /* ... */&#125;class ezcReflectionFunction extends ReflectionFunction &#123; use ezcReflectionReturnInfo; /* ... */&#125;?&gt; 优先级从基类继承的成员会被trait插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了trait的方法，而trait则覆盖了被继承的方法。例： 1234567891011121314151617&lt;?phptrait HelloWorld &#123; public function sayHello() &#123; echo 'Hello World!'; &#125;&#125;class TheWorldIsNotEnough &#123; use HelloWorld; public function sayHello() &#123; echo 'Hello Universe!'; &#125;&#125;$o = new TheWorldIsNotEnough();$o-&gt;sayHello();?&gt; 以上例程会输出： Hello Universe! 重载重载是指动态的”创建”类属性和方法。是通过魔术方法来实现的。 当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。 属性重载 在给不可访问（或未定义）属性赋值时，__set()会被调用 在读取不可访问（或未定义）属性时，__get()会被调用 当对不可访问（或未定义）属性调用isset()或empty()时，__isset()会被调用 当对不可访问（或未定义）属性调用unset()时，__unset()会被调用 方法重载使用__call()函数和__callStatic()函数 在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP手册【2】——变量、常量、函数","date":"2017-04-09T16:00:00.000Z","path":"2017/04/10/review-php-02/","text":"变量变量范围变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的PHP变量只有一个单独的范围。这个单独的范围跨度同样包含了include和require引入的文件。例如： 1234&lt;?php $a = 1; include 'b.php';?&gt; 这里变量$a将会在包含文件b.php中生效。但是，在用户自定义函数中，一个局部函数范围将被引入，任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。例如 123456789&lt;?php $a =1;//全局 function Test() &#123; echo $a; //位于函数内部 &#125; Test()； ?&gt; 这个脚本将不会有任何输出，因为echo语句引用了一个局部版本的变量$a，它并没有被赋值。PHP的全局变量和C语言的有一点点不同，在C语言中，全局变量在函数中自动生效，除非被局部变量覆盖。而PHP中全局变量在函数中使用时必须声明为global。 global关键字例： 1234567891011&lt;？php $a = 1; $b = 2; function sum() &#123; global $a,$b; $b = $a + $b; &#125; sum(); echo $b;?&gt; 以上脚本的输出将是3。 在函数中声明了全局变量 $a 和 $b 之后，对任一变量的所有引用都会指向其全局版本。对于一个函数能够声明的全局变量的最大个数，PHP 没有限制。 在全局范围内访问变量的第二个办法，是用特殊的 PHP 自定义 $GLOBALS 数组。 使用静态变量变量范围的另一个重要特性是静态变量（static variable）。静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不会丢失。例如： 12345678&lt;?php function test() &#123; $a = 0; echo $a; $a++; &#125;?&gt; 该函数没什么用处，因为每次调用时都会将$a的值设为0并输出0。将变量加一的$a++没有作用，因为一旦退出本函数则变量$a就不存在了。要写一个不会丢失本次计数值的技术函数，要将变量$a定义为静态的。如下例子： 12345678&lt;?php function test() &#123; static $a = 0; echo $a; $a++; &#125;?&gt; 现在，变量$a仅在第一次调用test()函数时被初始化，之后每次调用test()函数都会输出$a的值并加一。 静态变量也提供了一种处理递归函数的方法。写递归函数的时候，可能会无穷递归下去。必须确保有充分的方法来终止递归。以下的简单的例子说明使用静态变量来判断何时停止。 12345678910111213&lt;?php function test() &#123; static $count = 0; $count++; echo $count; if($count &lt; 10) &#123; test(); &#125; $count--; &#125;?&gt; 可变变量将变量名再赋予某个变量 可变函数将函数名赋予某个变量，当调用该变量外加括号时，即调用该函数。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"计算机组成","date":"2017-03-21T16:00:00.000Z","path":"2017/03/22/Computer/","text":"冯诺依曼结构的工作原理计算机组成的依据是冯诺依曼结构，它将计算机分为以下五大组成部分： 运算器+控制器（CPU） 存储器（内存） 输入设备 输出设备 数据和指令以二进制形式，不加区别的存放在存储器中。 速度不匹配问题由于CPU的运行速度非常快，与主存储器，磁盘的I/O速度相差非常大（千百倍以上），为了解决这个问题，计算机采用将CPU “忙死” 的方法。对于程序的执行采用以下方案： 同步 =&gt; 异步 即CPU在运行程序时，当某个程序需要它来运行时它才动作，不需要它运行时，CPU去运行别的程序去。 顺序 =&gt; 并发 将多个程序并发执行，CPU在这些程序里进行很快速的切换（由操作系统控制），这样会使人觉得好像每个程序同时运行一样，其实在每个时间点时（极短），CPU只执行一个程序。 增加中间层：缓存 1、当CPU要读取一个数据时，首先从CPU缓存中查找，找到就立刻读取并送给CPU处理；2、没有找到，就从速率相对较慢的内存中读取并送给CPU处理，同时把这个数据所在的数据块调入缓存中，可以使得以后对CPU数据的读取都从缓存中进行，不必在调用内存。 按下电源之后发生了什么 按下电源，主板开始供电 主板向CPU发出RESET信号 当RESET信号撤去后，CPU开始干活，去一个特定的内存地址查找第一条指令（这是一条跳转指令，跳转到系统BIOS中真正的启动代码处） BIOS的代码对系统进行自检：内存，硬盘，显卡..如果硬件出现问题，主板会发出不同含义的蜂鸣，启动终止。如果没有问题，屏幕就会出现CPU、内存、硬盘等信息。 hello world的一生 程序写好了以后，编译成二进制文件（包含机器语言指令），存放在硬盘中。 运行hello world程序，操作系统吧helloworld从硬盘读到内存 CPU开始执行main程序中的机器语言指令 机器语言指令把”helloworld”字符串从内存复制到寄存器 机器语言把寄存器数据复制到显示设备，显示在屏幕上。","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://www.tenpercent.top/tags/计算机基础/"}]},{"title":"重温PHP手册【1】——基础句法和类型","date":"2017-03-10T16:00:00.000Z","path":"2017/03/11/review-php-01/","text":"前言：最近想开始好好提升一下自己的英语水平，因为感觉熟练的英语是每一个优秀软件工程师的基本功，虽然是一枚过了六级的选手，但是感觉英文阅读和写作都还是有些压力。正巧听闻有个PHP高手说他把PHP官方手册读了不下8遍，深以为然，孰能生巧这个道理放在哪里都没有错。所以第一步我打算开始重温PHP手册，在加强自己英语水平的同时来达到温故而知新的目的。 1、PHP tagsWhen PHP parses a file, it look for opening and closing tags, which are &lt;?phpand ?&gt; which tell PHP to start and stop interpreting the code between them.if a file is pure PHP code, it is preferable to omit the PHP closing tag at the end of the file. This prevents accidental whitespace or new lines being added after the PHP closing tag, which may cause unwanted effects because PHP will start output buffering when there is no intention from the programmer to send any output at that point in the script. 12345&lt;?php echo \"hello chenjiehui!\"; //...more code echo \"last statement.\"; // the script ends here with no PHP closing tag 2、Escaping from HTMLEverything outside of a pair of opening and closing tags is ignored by the PHP parser which allows PHP files to have mixed content. This allows PHP to be embedded in HTML documents.But there is one exception that in the middle of a conditional statement in which case the interpreter will determine the outcome of the confitional before making a decision of what to skip over. See the next example. Using structures with conditions. 12345&lt;?php if($expression == true) : ?&gt; This will show if the expression is true.&lt;?php else : ?&gt; Otherwise this will show.&lt;?php endif; ?&gt; In this example PHP will ship the blocks where the condition is not met, even though they are outside of the PHP open/close tags;For outputting large blocks of text, dropping out of PHP parsing mode is generally more effcient than sending all of text through echo or print. Starting with PHP 5.4, short echo tag &lt;?= is always recongnized and vaild, regardless of the short_open_tag setting. 3、CommentsPHP support ‘C’,’C++’ and Unix shell-style(Perl style) comments. For example: 1234567&lt;?php echo 'this is a test'; //this is a one line c++ style comment /* This is a multi line comment yet another line of comment */ echo 'This is yet another test'; echo 'one Final Test'; # This is a one-line shell-style comment?&gt; ##4、typePHP supports eight primitive types(原始数据类型): Four scalar types(标量类型): boolean integer float(aka(又称作) double) string Three compound types: array object callable And finally two special types resource NULL This manual also introduces some pseudo-types(伪类型) for readability reasons： mixed number callback array|object void And the pseudo-variable $…The type of the variable is not usually set by programmer; rather(确切的说), it is decided at runtime by PHP depending on the context in which that variable is used. Note: To check the type and variable of the expression, use the var_dump() function.To get a human-readable representation of a type for debugging, use the gettype() function. To check for a certain type, do not use gettype(), but rather the is_type functions. Some examples: 123456789101112131415&lt;?php $a_bool = TRUE ; $a_str = \"foo\"; $a_str2 = 'foo'; $an_int = 12; echo gettype($a_bool);//print out: boolean echo gettype($a_str);//print out: string if(is_int($an_int))&#123; $an_int+=4; &#125; if (is_string($a_bool)) &#123; echo \"String: $a_bool\"; &#125;?&gt;&gt; To forcibly(强制地) convert a variable to a certain type, either cast(eg: (bool)$a_str) or use the settype() function on it.Note that a variable may be evaluated(被评估) with diffrent values in certain situations, depending on what type it is at the time.","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"操作系统【1】——导论","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/operating-system-01/","text":"操作系统是管理计算机硬件的程序，它还为应用程序提供基础，并充当计算机硬件和计算机用户的中介。大型机的操作系统设计主要目的是为了充分优化硬件的使用率，个人计算机的操作系统是为了能够支持从复杂游戏到商业应用的各种事物，手持计算机的操作系统是为了给用户一个可以与计算机方便的交互并执行程序的环境。因此，有的操作系统设计是为了方便，有的是为了高效，而有的设计目标则是兼而有之。 本章目标 提供对操作系统主要部件的浏览 提供基本的计算机系统体系结构的概述 1.1 操作系统做什么从计算机的角度来看，操作系统是与硬件最为密切的程序。计算机系统可能有许多资源，用来解决CPU时间、内存时间、文件存储空间、I/O设备等问题。操作系统管理这些资源。面对许多甚至冲突的请求，操作系统必须决定如何为各个程序和用户分配资源，以便计算机系统能够有效而公平的运行。众所周知，资源分配对多用户访问主机或微型计算机特别重要。操作系统是控制程序。控制程序管理用户程序的执行以防止计算机资源的错误使用或使用不当。它特别关注I/O设备的操作和控制。 1.1.1 定义操作系统一个比较公认的定义是，操作系统是一直运行在计算机上的程序（通常称之为内核），其他程序为系统程序和应用程序。 1.2 计算机系统组织1.2.1 计算机系统操作当计算机打开电源或重启时，计算机开始运行，它需要运行一个初始化程序，该初始化程序或引导程序（bootstrap program）比较简单，通常位于ROM或EEPROM中，称为计算机硬件中的固件。它初始化系统中的所有部分，包括CPU寄存器、设备控制器和内存内容。引导程序必须知道如何装入操作系统并开始执行系统。为了完成这一目标，引导程序必须定位操作系统内核并把它转入内存，接着，操作系统孔i是执行第一个进程如init，并等待事件的发生。事件的发生通常通过硬件或软件中断（interrupt）。硬件可随时通过系统总线向CPU发出信号，以触发中断。软件通过执行特别操作如系统调用（system call）也称为监视器调用（monitor call））也能触发中断。 1.2.2 存储结构计算机程序必须在内存（或随机访问内存（random access memory）RAM ）中以便于运行。内存是处理器可以直接访问的唯一的大容量存储区域（数兆到数千兆字节）。它通常是用被称为动态随机访问内存（dynamic random access memory,DRAM）的半导体技术来实现的，是一组内存字的数组，每个字都有其地址。通过对特定内存地址执行一系列load或store指令来实现交互。指令load能将内存中的字转移到CPU的寄存器中，而指令store能将寄存器的内容移到内存。除了显式使用load和store外，CPU可自动从内存中装入指令来执行。 一个典型指令执行周期（在冯诺依曼体系结构上执行时）首先从内存中获取指令，并保存在指令寄存器中。接着，指令被解码，并可能导致从内存中获取操作数或将操作数保存在内部寄存器中。在指令完成对操作数的执行，其结果可以存回到内存。注意内存单元只看见内存地址流，它并不知道它们是如何产生，或者它们是什么地址。相应地，可忽视程序如何产生内存地址，只对程序运行所产生的地址序列感兴趣。 由于内存太小以及内存是易失性存储设备，所以绝大多数计算机需要提供辅存，最常用的辅存设备为磁盘，它能存储程序和数据。绝大多数程序（浏览器，编译器，制表软件等）保存在磁盘上，直到要执行时才装入到内存中。许多程序都是使用磁盘来作为它们所处理信息的来源和目的。因此，适当的管理磁盘存储对计算机系统来说十分重要。 存储设备层次 寄存器 =&gt; 高速缓存 =&gt; 主存 =&gt; 电子磁盘 =&gt; 磁盘 =&gt; 光盘 =&gt; 磁带 1.3 计算机系统体系结构 单处理器系统 绝大多数系统采用单处理器，在单处理器系统中，有一个主CPU能够执行一个通用的指令集，包括来自于用户进程的指令。 多处理器系统 多处理器系统有多个紧密通信的CPU，它们共享计算机总线，有时还有时钟、没存和外设等。多处理器系统主要有三个优点： 1、增加吞吐量：通过增加处理器的数量，希望能够在更短的时间内做更多的事情。用N个处理器的加速比不是N，而是比N小。当多个CPU在同一件事情上时，为了使得各部分能正确工作，会产生一定的额外开销。这些开销，加上对共享资源的竞争，会降低因为增加了CPU的期望增益。这与一组N为程序员在一起紧密地工作，并不能完成N倍的单个程序员的工作量类似。 2、规模经济：多处理器系统比单个处理器系统能节省资金。 3、增加可靠性：如果将功能分布在多个处理器上，那么单个处理器的失灵将不会使得整个系统停止，只会使它变慢。如果有一个处理器出现故障，那么剩下的处理器会分担起故障处理器的那部分工作。 1.3.1 集群系统多CPU系统的另一种类型是集群系统（clustered system）。与多处理器系统一样，集群系统将多个CPU集中起来完成计算任务。然而，集群系统与多处理器系统不同，它是由两个或多个独立的系统耦合起来的。集群系统通常用来提供高可用服务，这意味着即使集群中的一个或多个系统出错，服务仍在运行。 集群分为非对称集群和对称集群 非对称集群 一台机器处于热备份模式（hot standby mode），而另一台运行应用程序。热备份主机只监视活动服务器。如果该服务器失效，那么热备份主机会成为现行服务器 对称集群 两个或者多个主机都运行应用程序，它们互相监视。这种模式因为充分使用了现有硬件，所以更为高效。","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://www.tenpercent.top/tags/计算机基础/"}]}]