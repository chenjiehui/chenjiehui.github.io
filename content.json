[{"title":"PHP-FPM 与 Nginx 的通信机制总结","date":"2018-11-20T16:00:00.000Z","path":"2018/11/21/php-fpm and nginx /","text":"PHP-fpm 介绍 CGI 协议与 FastCGI 协议 每种动态语言（ PHP,Python 等）的代码文件需要通过对应的解析器才能被服务器识别，而 CGI 协议就是用来使解释器与服务器可以互相通信。PHP 文件在服务器上的解析需要用到 PHP 解释器，再加上对应的 CGI 协议，从而使服务器可以解析到 PHP 文件。 由于 CGI 的机制是每处理一个请求需要 fork 一个 CGI 进程，请求结束再kill掉这个进程，在实际应用上比较浪费资源，于是就出现了CGI 的改良版本 FastCGI，FastCGI 在请求处理完后，不会 kill 掉进程，而是继续处理多个请求，这样就大大提高了效率。 PHP-FPM 是什么 PHP-FPM 即 PHP-FastCGI Process Manager， 它是 FastCGI 的实现，并提供了进程管理的功能。进程包含 master 进程和 worker 进程两种；master 进程只有一个，负责监听端口，接收来自服务器的请求，而 worker 进程则一般有多个（具体数量根据实际需要进行配置），每个进程内部都会嵌入一个 PHP 解释器，是代码真正执行的地方。 Nginx 与 php-fpm 通信机制当我们访问一个网站（如 www.test.com）的时候，处理流程是这样的： 12345678910111213141516171819 www.test.com | | Nginx | |路由到www.test.com/index.php | |加载nginx的fast-cgi模块 | |fast-cgi监听127.0.0.1:9000地址 | |www.test.com/index.php请求到达127.0.0.1:9000 | | 等待处理... Nginx 与 php-fpm 结合 在 Linux 上，Nginx 与 php-fpm 的通信有 tcp 和 unix socket 两种方式。 tcp 的优点是可以跨服务器，当 Nginx 和 PHP-fpm 不在同一台机器上时，只能使用这种方式。 Unix socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信，这种方式需要在 nginx配置文件中填写 php-fpm 的 socket 文件位置。 两种方式的数据传输过程如下图所示： 二者的不同： 由于 Unix socket 不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。所以其效率比 tcp 的方式要高，可减少不必要的 tcp 开销。不过，Unix socket 高并发时不稳定，连接数爆发时，会产生大量的长时缓存，在没有面向连接协议的支撑下，大数据包可能会直接出错不返回异常。而 tcp 这样的面向连接的协议，可以更好的保证通信的正确性和完整性。 Nginx 与 php-fpm 结合只需要在各自的配置文件中做设置即可： 1） Nginx 中的配置 以 tcp 通信为例 12345678910111213141516171819server &#123; listen 80; #监听80端口，接收http请求 server_name www.example.com; #就是网站地址 root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径 #路由到网站根目录www.example.com时候的处理 location / &#123; index index.php; #跳转到www.example.com/index.php autoindex on; &#125; #当请求网站下php文件的时候，反向代理到php-fpm location ~ \\.php$ &#123; include /usr/local/etc/nginx/fastcgi.conf; #加载nginx的fastcgi模块 fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; # tcp 方式，PHP-fpm 监听的IP地址和端口 # fasrcgi_pass /usr/run/php-fpm.sock # unix socket 连接方式 &#125;&#125; 2) php-fpm 的配置 123listen = 127.0.0.1:9000# 或者下面这样listen = /var/run/php-fpm.sock 注意，在使用 Unix socket 方式连接时，由于 socket 文件本质上是一个文件，存在权限控制的问题，所以需要注意 Nginx 进程的权限与 php-fpm 的权限问题，不然会提示无权限访问。（在各自的配置文件里设置用户）","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"Nginx","slug":"Nginx","permalink":"http://www.tenpercent.top/tags/Nginx/"},{"name":"PHP-FPM","slug":"PHP-FPM","permalink":"http://www.tenpercent.top/tags/PHP-FPM/"}]},{"title":"Linux 性能监控工具","date":"2018-07-09T16:00:00.000Z","path":"2018/07/10/Linux-performance-monitor/","text":"最近了解了下 Linux 性能相关的东西，主要是如何查看服务器性能的一些工具，在这里做个记录，以后遇到相关使用场景的时候，方便查看。 Linux 性能指标 CPU CPU利用率、用户时间（表示CPU在用户进程上的时间百分比）、系统时间（表示CPU花在内核操作上的时间百分比）、空闲时间、平均负载、阻塞、上下文切换、中断等 内存 空闲内存、Swap利用率、缓冲和缓存、活动和非活动内存等 磁盘IO IO等待、平均队列长度、每秒传输（TPS）等 网络 接收和发送的包、每秒碰撞（各个网络接口所连接网络的所发生的冲突数量）、丢包、错误等 监测工具以下是对 Linux 的性能进行监控的常用工具： 工具 简介 top 查看进程活动状态以及一些系统状况 vmstat 查看系统状态、硬件和系统信息等 iostat 查看 CPU 负载、硬盘状况 sar 综合工具，查看系统状况 mpstat 查看多处理器状况 netstat 查看网络状况 iptraf 实时网络状态监测 tcpdump 抓取网络数据包，详细分析 tcptrace 网络包分析工具 netperf 网络带宽工具 dstat 综合了 vmstat、iostat、ifstat、netstat 等多个信息 这里介绍其中几个。 top 工具top是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。 PID：进程的ID USER：进程所有者 PR：进程的优先级别，越小越优先被执行 NI：nice值 VIRT：进程占用的虚拟内存 RES：进程占用的物理内存 SHR：进程使用的共享内存 S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数 %CPU：进程占用CPU的使用率 %MEM：进程使用的物理内存和总内存的百分比 TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。 COMMAND：进程启动命令名称 vmstat 工具vmstat 是个查看系统整体性能的小工具，小巧，即使在机器负载很高的情况下也运行良好，并且可以用时间间隔采集得到连续的性能数据。 参数介绍： r，可运行队列的线程数，这些线程都是可运行状态，只不过 CPU 暂时不可用 b，被 blocked 的进程数，正在等待 IO 请求 in，被处理过的中断数 cs，系统上正在做上下文切换的数目 us，用户占用 CPU 的百分比 sys，内核和中断占用 CPU 的百分比 wa，所有可运行的线程被 blocked 以后都在等待 IO，这时候 CPU 空闲的百分比 id，CPU 完全空闲的百分比 举两个例子来分析一下 12345678$ vmstat 1procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------ r b swpd free buff cache si so bi bo in cs us sy id wa st 4 0 140 2915476 341288 3951700 0 0 0 0 1057 523 89 21 0 0 0 4 0 140 2915724 341296 3951700 0 0 0 0 1048 546 79 11 0 0 0 4 0 140 2915848 341296 3951700 0 0 0 0 1044 514 88 22 0 0 0 4 0 140 2915848 341296 3951700 0 0 0 24 1044 564 80 20 0 0 0 4 0 140 2915848 341296 3951700 0 0 0 0 1060 546 78 12 0 0 0 从上面的数据可以看出几点： interrupts(in) 非常高，context switch(cs) 比较低，说明这个 CPU 一直在不停的请求资源 user time(us) 一直保持在 80% 以上，而且上下文切换较低 (cs)，说明某个进程可能一直霸占着 CPU run queue(r) 刚好在 4 个 12345678$ vmstat 1procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------ r b swpd free buff cache si so bi bo in cs us sy id wa st14 0 140 2904316 341912 3952308 0 0 0 460 1106 9593 36 64 1 0 017 0 140 2903492 341912 3951780 0 0 0 0 1037 9614 35 65 1 0 020 0 140 2902016 341912 3952000 0 0 0 0 1046 9739 35 64 1 0 017 0 140 2903904 341912 3951888 0 0 0 76 1044 9879 37 63 0 0 016 0 140 2904580 341912 3952108 0 0 0 0 1055 9808 34 65 1 0 0 从上面的数据可以看出几点： context switch(cs) 比 interrupts(in) 要高的多，说明内核不得不来回切换进程 进一步观察发现 system time(sy) 很高而 user time(us) 很低，而且加上高频度的上下文切换 (cs)，说明正在运行的应用程序调用了大量的系统调用 run queue(r) 在 14 个线程以上，而这个机器的硬件配置 (4 核），应该保持在 12 以内。 iostat 工具iostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。iostat属于sysstat软件包。可以用yum install sysstat 直接安装。 cpu属性值说明： %user：CPU处在用户模式下的时间百分比。 %nice：CPU处在带NICE值的用户模式下的时间百分比。 %system：CPU处在系统模式下的时间百分比。 %iowait：CPU等待输入输出完成时间的百分比。 %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。 %idle：CPU空闲时间百分比。 如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。 disk属性值说明： rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/s wrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/s r/s: 每秒完成的读 I/O 设备次数。即 rio/s w/s: 每秒完成的写 I/O 设备次数。即 wio/s rsec/s: 每秒读扇区数。即 rsect/s wsec/s: 每秒写扇区数。即 wsect/s rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。 wkB/s: 每秒写K字节数。是 wsect/s 的一半。 avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。 avgqu-sz: 平均I/O队列长度。 await: 平均每次设备I/O操作的等待时间 (毫秒)。 svctm: 平均每次设备I/O操作的服务时间 (毫秒)。 %util: 一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比 如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。 如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间； 如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。 如果avgqu-sz比较大，也表示有大量io在等待。 sar 工具 sar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。 查看 cpu使用率 sar -u %user 用户模式下消耗的CPU时间的比例； %nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例 %system 系统模式下消耗的CPU时间的比例； %iowait CPU等待磁盘I/O导致空闲状态消耗的时间比例； %steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例； %idle CPU空闲时间比例； 查看平均负载 sar -q runq-sz：运行队列的长度（等待运行的进程数） plist-sz：进程列表中进程（processes）和线程（threads）的数量 ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载 ldavg-15：过去15分钟的系统平均负载 查看内存使用状况 sar -r kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间. kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间. %memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比. kbbuffers和kbcached：这两个值就是free命令中的buffer和cache. kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap). %commit：这个值是kbcommit与内存总量(包括swap)的一个百分比. sar参数说明 -A 汇总所有的报告 -a 报告文件读写使用情况 -B 报告附加的缓存的使用情况 -b 报告缓存的使用情况 -c 报告系统调用的使用情况 -d 报告磁盘的使用情况 -g 报告串口的使用情况 -h 报告关于buffer使用的统计数据 -m 报告IPC消息队列和信号量的使用情况 -n 报告命名cache的使用情况 -p 报告调页活动的使用情况 -q 报告运行队列和交换队列的平均长度 -R 报告进程的活动情况 -r 报告没有使用的内存页面和硬盘块 -u 报告CPU的利用率 -v 报告进程、i节点、文件和锁表状态 -w 报告系统交换活动状况 -y 报告TTY设备活动状况","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.tenpercent.top/tags/Linux/"},{"name":"工具","slug":"工具","permalink":"http://www.tenpercent.top/tags/工具/"}]},{"title":"深入解析 composer 的自动加载原理","date":"2018-05-16T16:00:00.000Z","path":"2018/05/17/composer-autoload/","text":"前言PHP 自5.3的版本之后，已经重焕新生，命名空间、性状（trait）、闭包、接口、PSR 规范、以及 composer 的出现已经让 PHP 变成了一门现代化的脚本语言。PHP 的生态系统也一直在演进，而 composer 的出现更是彻底的改变了以往构建 PHP 应用的方式，我们可以根据 PHP 的应用需求混合搭配最合适的 PHP 组件。当然这也得益于 PSR 规范的提出。 掌握 composer 自动加载原理的好处 更好的运用 composer 来构建我们的 PHP 应用程序 对 PSR 规范有进一步的了解 当需要用到没有 composer 化的第三方库时，可以将其 composer 化来提高工程效率 学习比较严谨、高深的编码技巧 大纲 PHP 自动加载功能 PSR 规范 comoposer 的自动加载过程 composer 源码分析 一、PHP 自动加载功能PHP 自动加载功能的由来在 PHP 开发过程中，如果希望从外部引入一个 Class ，通常会使用 include 和 require 方法，去把定义这个 Class 的文件包含进来。这个在小规模开发的时候，没什么大问题。但在大型的开发项目中，使用这种方式会带来一些隐含的问题：如果一个 PHP 文件需要使用很多其它类，那么就需要很多的 require/include 语句，这样有可能会 造成遗漏 或者 包含进不必要的类文件。如果大量的文件都需要使用其它的类，那么要保证每个文件都包含正确的类文件肯定是一个噩梦， 况且 require或 incloud 的性能代价很大。 PHP5 为这个问题提供了一个解决方案，这就是 类的自动加载(autoload)机制。autoload机制 可以使得 PHP 程序有可能在使用类时才自动包含类文件，而不是一开始就将所有的类文件include进来，这种机制也称为 Lazy loading (惰性加载)。 总结起来，自动加载功能带来了几处优点： 使用类之前无需 include / require 使用类的时候才会 include / require 文件，实现了 lazy loading ，避免了 include / require 多余文件。 无需考虑引入 类的实际磁盘地址 ，实现了逻辑和实体文件的分离。 PHP 自动加载函数 __autoload() 通常 PHP5 在使用一个类时，如果发现这个类没有加载，就会自动运行 __autoload() 函数，这个函数是我们在程序中自定义的，在这个函数中我们可以加载需要使用的类。下面是个简单的示例： 12345&lt;?phpfunction __autoload($classname) &#123; require_once ($classname . \".class.php\");&#125; 在我们这个简单的例子中，我们直接将类名加上扩展名 .class.php 构成了类文件名，然后使用 require_once 将其加载。 从这个例子中，我们可以看出 __autoload 至少要做三件事情： 根据类名确定类文件名； 确定类文件所在的磁盘路径； 将类从磁盘文件中加载到系统中。 第三步最简单，只需要使用 include / require 即可。要实现第一步，第二步的功能，必须在开发时约定类名与磁盘文件的映射方法，只有这样我们才能根据类名找到它对应的磁盘文件。 当有大量的类文件要包含的时候，我们只要确定相应的规则，然后在 __autoload() 函数中，将类名与实际的磁盘文件对应起来，就可以实现 lazy loading 的效果 。 如果想详细的了解关于 autoload 自动加载的过程，可以查看手册资料：PHP autoload函数说明 __autoload() 函数存在的问题 如果在一个系统的实现中，如果需要使用很多其它的类库，这些类库可能是由不同的开发人员编写的， 其类名与实际的磁盘文件的映射规则不尽相同。这时如果要实现类库文件的自动加载，就必须 在 __autoload() 函数中将所有的映射规则全部实现，这样的话 __autoload() 函数有可能会非常复杂，甚至无法实现。最后可能会导致 __autoload() 函数十分臃肿，这时即便能够实现，也会给将来的维护和系统效率带来很大的负面影响。 那么问题出现在哪里呢？问题出现在 __autoload() 是全局函数只能定义一次 ，不够灵活，所以所有的类名与文件名对应的逻辑规则都要在一个函数里面实现，造成这个函数的臃肿。那么如何来解决这个问题呢？答案就是使用一个 __autoload调用堆栈 ，不同的映射关系写到不同的 __autoload函数 中去，然后统一注册统一管理，这个就是 PHP5 引入的 SPL Autoload 。 SPL Autoload SPL是 Standard PHP Library(标准PHP库)的缩写。它是 PHP5 引入的一个扩展标准库，包括 spl autoload 相关的函数以及各种数据结构和迭代器的接口或类。spl autoload 相关的函数具体可见 php中spl_autoload 123456789101112131415161718192021222324252627282930313233343536&lt;?php// __autoload 函数//// function __autoload($class) &#123;// include 'classes/' . $class . '.class.php';// &#125;function my_autoloader($class) &#123; include 'classes/' . $class . '.class.php';&#125;spl_autoload_register('my_autoloader');// 定义的 autoload 函数在 class 里// 静态方法class MyClass &#123; public static function autoload($className) &#123; // ... &#125;&#125;spl_autoload_register(array('MyClass', 'autoload'));// 非静态方法class MyClass &#123; public function autoload($className) &#123; // ... &#125;&#125;$instance = new MyClass();spl_autoload_register(array($instance, 'autoload')); spl_autoload_register() 就是我们上面所说的__autoload调用堆栈，我们可以向这个函数注册多个我们自己的 autoload() 函数，当 PHP 找不到类名时，PHP就会调用这个堆栈，然后去调用自定义的 autoload() 函数，实现自动加载功能。如果我们不向这个函数输入任何参数，那么就会默认注册 spl_autoload() 函数。 二、PSR 规范与自动加载相关的规范是 PSR4，在说 PSR4 之前先介绍一下PSR标准。PSR 标准的发明和推出组织是：PHP-FIG，它的网站是：www.php-fig.org。由几位开源框架的开发者成立于 2009 年，从那开始也选取了很多其他成员进来，虽然不是 “官方” 组织，但也代表了社区中不小的一块。组织的目的在于：以最低程度的限制，来统一各个项目的编码规范，避免各家自行发展的风格阻碍了程序员开发的困扰，于是大伙发明和总结了 PSR，PSR是 PHP Standards Recommendation 的缩写，截止到目前为止，总共有 14 套 PSR 规范，其中有 7 套PSR规范已通过表决并推出使用，分别是： PSR-0 自动加载标准（已废弃，一些旧的第三方库还有在使用） PSR-1 基础编码标准 PSR-2 编码风格向导 PSR-3 日志接口 PSR-4 自动加载的增强版，替换掉了 PSR-0 PSR-6 缓存接口规范 PSR-7 HTTP 消息接口规范 具体详细的规范标准可以查看PHP 标准规范 PSR4 标准2013 年底，PHP-FIG 推出了第 5 个规范——PSR-4。 PSR-4 规范了如何指定文件路径从而自动加载类定义，同时规范了自动加载文件的位置。 1）一个完整的类名需具有以下结构：\\&lt;命名空间&gt;\\&lt;子命名空间&gt;\\&lt;类名&gt; 完整的类名必须要有一个顶级命名空间，被称为 “vendor namespace”； 完整的类名可以有一个或多个子命名空间； 完整的类名必须有一个最终的类名； 完整的类名中任意一部分中的下滑线都是没有特殊含义的； 完整的类名可以由任意大小写字母组成； 所有类名都必须是大小写敏感的。 2）根据完整的类名载入相应的文件 完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为「命名空间前缀」，其必须与至少一个「文件基目录」相对应； 紧接命名空间前缀后的子命名空间 必须 与相应的「文件基目录」相匹配，其中的命名空间分隔符将作为目录分隔符。 末尾的类名必须与对应的以 .php 为后缀的文件同名。 自动加载器（autoloader）的实现一定不可抛出异常、一定不可触发任一级别的错误信息以及不应该有返回值。 3) 例子PSR-4风格 类名：\\Zend\\Abc命名空间前缀：Zend文件基目录：/usr/includes/Zend/文件路径：/usr/includes/Zend/Abc.php 类名：\\Symfony\\Core\\Request命名空间前缀：Symfony\\Core文件基目录：./vendor/Symfony/Core/文件路径：./vendor/Symfony/Core/Request.php 目录结构 1234567-vendor/| -vendor_name/| | -package_name/| | | -src/| | | | -ClassName.php # Vendor_Name\\Package_Name\\ClassName| | | -tests/| | | | -ClassNameTest.php # Vendor_Name\\Package_Name\\ClassNameTest Composer自动加载过程Composer 做了哪些事情 你有一个项目依赖于若干个库。 其中一些库依赖于其他库。 你声明你所依赖的东西。 Composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。 例如，你正在创建一个项目，需要做一些单元测试。你决定使用 phpunit 。为了将它添加到你的项目中，你所需要做的就是在 composer.json 文件里描述项目的依赖关系。 12345&#123; \"require\": &#123; \"phpunit/phpunit\":\"~6.0\", &#125;&#125; 然后在 composer require 之后我们只要在项目里面直接 use phpunit 的类即可使用。 执行 composer require 时发生了什么 composer 会找到符合 PR4 规范的第三方库的源 将其加载到 vendor 目录下 初始化顶级域名的映射并写入到指定的文件里（如：&#39;PHPUnit\\\\Framework\\\\Assert&#39; =&gt; __DIR__ . &#39;/..&#39; . &#39;/phpunit/phpunit/src/Framework/Assert.php&#39;） 写好一个 autoload 函数，并且注册到 spl_autoload_register()里 题外话：现在很多框架都已经帮我们写好了顶级域名映射了，我们只需要在框架里面新建文件，在新建的文件中写好命名空间，就可以在任何地方 use 我们的命名空间了。 Composer 源码分析下面我们通过对源码的分析来看看 composer 是如何实现 PSR4标准 的自动加载功能。 很多框架在初始化的时候都会引入 composer 来协助自动加载的，以 Laravel 为例，它入口文件 index.php 第一句就是利用 composer 来实现自动加载功能。 启动1234&lt;?php define('LARAVEL_START', microtime(true)); require __DIR__ . '/../vendor/autoload.php'; 去 vendor 目录下的 autoload.php ： 1234&lt;?php require_once __DIR__ . '/composer' . '/autoload_real.php'; return ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29::getLoader(); 这里就是 Composer 真正开始的地方了 Composer自动加载文件首先，我们先大致了解一下Composer自动加载所用到的源文件。 autoload_real.php: 自动加载功能的引导类。 composer 加载类的初始化(顶级命名空间与文件路径映射初始化)和注册(spl_autoload_register())。 ClassLoader.php : composer 加载类。 composer 自动加载功能的核心类。 autoload_static.php : 顶级命名空间初始化类， 用于给核心类初始化顶级命名空间。 autoload_classmap.php : 自动加载的最简单形式， 有完整的命名空间和文件目录的映射； autoload_files.php : 用于加载全局函数的文件， 存放各个全局函数所在的文件路径名； autoload_namespaces.php : 符合 PSR0 标准的自动加载文件， 存放着顶级命名空间与文件的映射； autoload_psr4.php : 符合 PSR4 标准的自动加载文件， 存放着顶级命名空间与文件的映射； autoload_real 引导类 在 vendor 目录下的 autoload.php 文件中我们可以看出，程序主要调用了引导类的静态方法 getLoader() ，我们接着看看这个函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php public static function getLoader() &#123; if (null !== self::$loader) &#123; return self::$loader; &#125; spl_autoload_register( array('ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader'), true, true ); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister( array('ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader') ); $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION'); if ($useStaticLoader) &#123; require_once __DIR__ . '/autoload_static.php'; call_user_func( \\Composer\\Autoload\\ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::getInitializer($loader) ); &#125; else &#123; $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; /***********************注册自动加载核心类对象********************/ $loader-&gt;register(true); /***********************自动加载全局函数********************/ if ($useStaticLoader) &#123; $includeFiles = Composer\\Autoload\\ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$files; &#125; else &#123; $includeFiles = require __DIR__ . '/autoload_files.php'; &#125; foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file); &#125; return $loader; &#125; 我把自动加载引导类分为 5 个部分。 第一部分——单例第一部分很简单，就是个最经典的单例模式，自动加载类只能有一个。 1234&lt;?php if (null !== self::$loader) &#123; return self::$loader; &#125; 第二部分——构造ClassLoader核心类第二部分 new 一个自动加载的核心类对象。 1234567891011&lt;?php /***********************获得自动加载核心类对象********************/ spl_autoload_register( array('ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader'), true, true ); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister( array('ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader') ); loadClassLoader()函数： 1234567&lt;?phppublic static function loadClassLoader($class)&#123; if ('Composer\\Autoload\\ClassLoader' === $class) &#123; require __DIR__ . '/ClassLoader.php'; &#125;&#125; 从程序里面我们可以看出，composer 先向 PHP 自动加载机制注册了一个函数，这个函数 require 了 ClassLoader 文件。成功 new 出该文件中核心类 ClassLoader() 后，又销毁了该函数。 第三部分 —— 初始化核心类对象12345678910111213141516171819202122232425&lt;?php /***********************初始化自动加载核心类对象********************/ $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION'); if ($useStaticLoader) &#123; require_once __DIR__ . '/autoload_static.php'; call_user_func( \\Composer\\Autoload\\ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::getInitializer($loader) ); &#125; else &#123; $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; 这一部分就是对自动加载类的初始化，主要是给自动加载核心类初始化顶级命名空间映射。 初始化的方法有两种： 1. 使用 autoload_static 进行静态初始化； 2. 调用核心类接口初始化。 autoload_static 静态初始化 ( PHP &gt;= 5.6 )静态初始化只支持 PHP5.6 以上版本并且不支持 HHVM 虚拟机。我们深入 autoload_static.php 这个文件发现这个文件定义了一个用于静态初始化的类，名字叫 ComposerStaticInit7b790917ce8899df9af8ed53631a1c29，仍然为了避免冲突而加了 hash 值。这个类很简单： 12345678910111213141516171819202122232425&lt;?php class ComposerStaticInit7b790917ce8899df9af8ed53631a1c29&#123; public static $files = array(...); public static $prefixLengthsPsr4 = array(...); public static $prefixDirsPsr4 = array(...); public static $prefixesPsr0 = array(...); public static $classMap = array (...); public static function getInitializer(ClassLoader $loader) &#123; return \\Closure::bind(function () use ($loader) &#123; $loader-&gt;prefixLengthsPsr4 = ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$prefixLengthsPsr4; $loader-&gt;prefixDirsPsr4 = ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$prefixDirsPsr4; $loader-&gt;prefixesPsr0 = ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$prefixesPsr0; $loader-&gt;classMap = ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$classMap; &#125;, null, ClassLoader::class); &#125; 这个静态初始化类的核心就是 getInitializer() 函数，它将自己类中的顶级命名空间映射给了 ClassLoader 类。值得注意的是这个函数返回的是一个匿名函数，为什么呢？原因就是 ClassLoader类 中的 prefixLengthsPsr4 、prefixDirsPsr4等等变量都是 private的。利用匿名函数的绑定功能就可以将这些 private 变量赋给 ClassLoader 类 里的成员变量。 关于匿名函数的绑定功能。 接下来就是命名空间初始化的关键了。 classMap（命名空间映射）1234567891011121314151617&lt;?php public static $classMap = array ( 'App\\\\Console\\\\Kernel' =&gt; __DIR__ . '/../..' . '/app/Console/Kernel.php', 'App\\\\Exceptions\\\\Handler' =&gt; __DIR__ . '/../..' . '/app/Exceptions/Handler.php', 'App\\\\Http\\\\Controllers\\\\Auth\\\\ForgotPasswordController' =&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/ForgotPasswordController.php', 'App\\\\Http\\\\Controllers\\\\Auth\\\\LoginController' =&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/LoginController.php', 'App\\\\Http\\\\Controllers\\\\Auth\\\\RegisterController' =&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/RegisterController.php', ...) 直接命名空间全名与目录的映射，简单粗暴，也导致这个数组相当的大。 PSR4 标准顶级命名空间映射数组：1234567891011121314151617181920212223242526&lt;?php public static $prefixLengthsPsr4 = array( 'p' =&gt; array ( 'phpDocumentor\\\\Reflection\\\\' =&gt; 25, ), 'S' =&gt; array ( 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; 26, 'Symfony\\\\Component\\\\Yaml\\\\' =&gt; 23, 'Symfony\\\\Component\\\\VarDumper\\\\' =&gt; 28, ... ), ...); public static $prefixDirsPsr4 = array ( 'phpDocumentor\\\\Reflection\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-common/src', 1 =&gt; __DIR__ . '/..' . '/phpdocumentor/type-resolver/src', 2 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src', ), 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring', ), 'Symfony\\\\Component\\\\Yaml\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/symfony/yaml', ), ...) PSR4 标准顶级命名空间映射用了两个数组，第一个是用命名空间第一个字母作为前缀索引，然后是 顶级命名空间，但是最终并不是文件路径，而是 顶级命名空间的长度。为什么呢？ 因为 PSR4 标准是用顶级命名空间目录替换顶级命名空间，所以获得顶级命名空间的长度很重要。 具体说明这些数组的作用： 假如我们找 Symfony\\Polyfill\\Mbstring\\example 这个命名空间，通过前缀索引和字符串匹配我们得到了 12&lt;?php 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; 26, 这条记录，键是顶级命名空间，值是命名空间的长度。拿到顶级命名空间后去 $prefixDirsPsr4数组 获取它的映射目录数组：(注意映射目录可能不止一条) 1234&lt;?php 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring', ) 然后我们就可以将命名空间 Symfony\\\\Polyfill\\\\Mbstring\\\\example 前26个字符替换成目录 __DIR__ . &#39;/..&#39; . &#39;/symfony/polyfill-mbstring ，我们就得到了__DIR__ . &#39;/..&#39; . &#39;/symfony/polyfill-mbstring/example.php，先验证磁盘上这个文件是否存在，如果不存在接着遍历。如果遍历后没有找到，则加载失败。 ClassLoader 接口初始化（ PHP &lt; 5.6 ） 如果PHP版本低于 5.6 或者使用 HHVM 虚拟机环境，那么就要使用核心类的接口进行初始化。 1234567891011121314151617&lt;?php // PSR0 标准 $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; // PSR4 标准 $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; PSR4 标准的映射autoload_psr4.php 的顶级命名空间映射 123456789101112131415161718&lt;?php return array( 'XdgBaseDir\\\\' =&gt; array($vendorDir . '/dnoegel/php-xdg-base-dir/src'), 'Webmozart\\\\Assert\\\\' =&gt; array($vendorDir . '/webmozart/assert/src'), 'TijsVerkoyen\\\\CssToInlineStyles\\\\' =&gt; array($vendorDir . '/tijsverkoyen/css-to-inline-styles/src'), 'Tests\\\\' =&gt; array($baseDir . '/tests'), 'Symfony\\\\Polyfill\\\\Mbstring\\\\' =&gt; array($vendorDir . '/symfony/polyfill-mbstring'), ... ) PSR4 标准的初始化接口: 12345678910111213141516&lt;?php public function setPsr4($prefix, $paths) &#123; if (!$prefix) &#123; $this-&gt;fallbackDirsPsr4 = (array) $paths; &#125; else &#123; $length = strlen($prefix); if ('\\\\' !== $prefix[$length - 1]) &#123; throw new \\InvalidArgumentException( \"A non-empty PSR-4 prefix must end with a namespace separator.\" ); &#125; $this-&gt;prefixLengthsPsr4[$prefix[0]][$prefix] = $length; $this-&gt;prefixDirsPsr4[$prefix] = (array) $paths; &#125; &#125; PSR4初始化接口也很简单。如果没有顶级命名空间，就直接保存目录。如果有命名空间的话，要保证顶级命名空间最后是 \\ ，然后分别保存。 总结下上面的顶级命名空间映射过程： ( 前缀 -&gt; 顶级命名空间，顶级命名空间 -&gt; 顶级命名空间长度 ) ( 顶级命名空间 -&gt; 目录 ) 这两个映射数组。具体形式也可以查看下面的 autoload_static 的 prefixLengthsPsr4 、 $prefixDirsPsr4 。 命名空间映射autoload_classmap： 123456789&lt;?phppublic static $classMap = array ( 'App\\\\Console\\\\Kernel' =&gt; __DIR__ . '/../..' . '/app/Console/Kernel.php', 'App\\\\Exceptions\\\\Handler' =&gt; __DIR__ . '/../..' . '/app/Exceptions/Handler.php', ...) addClassMap: 123456789&lt;?php public function addClassMap(array $classMap) &#123; if ($this-&gt;classMap) &#123; $this-&gt;classMap = array_merge($this-&gt;classMap, $classMap); &#125; else &#123; $this-&gt;classMap = $classMap; &#125; &#125; 自动加载核心类 ClassLoader 的静态初始化到这里就完成了！ 其实说是5部分，真正重要的就两部分——初始化与注册。初始化负责顶层命名空间的目录映射，注册负责实现顶层以下的命名空间映射规则。 第四部分 —— 注册 讲完了 Composer 自动加载功能的启动与初始化，经过启动与初始化，自动加载核心类对象已经获得了顶级命名空间与相应目录的映射，也就是说，如果有命名空间 ‘App\\Console\\Kernel，我们已经可以找到它对应的类文件所在位置。那么，它是什么时候被触发去找的呢？ 这就是 composer 自动加载的核心了，我们先回顾一下自动加载引导类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 public static function getLoader() &#123; /***************************经典单例模式********************/ if (null !== self::$loader) &#123; return self::$loader; &#125; /***********************获得自动加载核心类对象********************/ spl_autoload_register(array('ComposerAutoloaderInit 7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader'), true, true); self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInit 7b790917ce8899df9af8ed53631a1c29', 'loadClassLoader')); /***********************初始化自动加载核心类对象********************/ $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION'); if ($useStaticLoader) &#123; require_once __DIR__ . '/autoload_static.php'; call_user_func(\\Composer\\Autoload\\ComposerStaticInit 7b790917ce8899df9af8ed53631a1c29::getInitializer($loader)); &#125; else &#123; $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; /***********************注册自动加载核心类对象********************/ $loader-&gt;register(true); /***********************自动加载全局函数********************/ if ($useStaticLoader) &#123; $includeFiles = Composer\\Autoload\\ComposerStaticInit 7b790917ce8899df9af8ed53631a1c29::$files; &#125; else &#123; $includeFiles = require __DIR__ . '/autoload_files.php'; &#125; foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire 7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file); &#125; return $loader;&#125; 现在我们开始引导类的第四部分：注册自动加载核心类对象。我们来看看核心类的 register() 函数： 1234public function register($prepend = false)&#123; spl_autoload_register(array($this, 'loadClass'), true, $prepend);&#125; 一行代码实现自动加载！ 其实奥秘都在自动加载核心类 ClassLoader 的 loadClass() 函数上： 12345678public function loadClass($class) &#123; if ($file = $this-&gt;findFile($class)) &#123; includeFile($file); return true; &#125; &#125; 这个函数负责按照 PSR 标准将顶层命名空间以下的内容转为对应的目录，也就是上面所说的将 ‘App\\Console\\Kernel 中’ Console\\Kernel 这一段转为目录，至于怎么转的在下面 “运行”的部分讲。核心类 ClassLoader 将 loadClass() 函数注册到PHP SPL中的 spl_autoload_register() 里面去。这样，每当PHP遇到一个不认识的命名空间的时候，PHP会自动调用注册到 spl_autoload_register 里面的 loadClass() 函数，然后找到命名空间对应的文件。 全局函数的自动加载 Composer 不止可以自动加载命名空间，还可以加载全局函数。怎么实现的呢？把全局函数写到特定的文件里面去，在程序运行前挨个 require就行了。这个就是 composer 自动加载的第五步，加载全局函数。 12345678if ($useStaticLoader) &#123; $includeFiles = Composer\\Autoload\\ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$files;&#125; else &#123; $includeFiles = require __DIR__ . '/autoload_files.php';&#125;foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file);&#125; 跟核心类的初始化一样，全局函数自动加载也分为两种：静态初始化和普通初始化，静态加载只支持PHP5.6以上并且不支持HHVM。 静态初始化： ComposerStaticInit7b790917ce8899df9af8ed53631a1c29::$files： 12345public static $files = array ('0e6d7bf4a5811bfa5cf40c5ccd6fae6a' =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring/bootstrap.php','667aeda72477189d0494fecd327c3641' =&gt; __DIR__ . '/..' . '/symfony/var-dumper/Resources/functions/dump.php',...); 普通初始化autoload_files: 12345678$vendorDir = dirname(dirname(__FILE__));$baseDir = dirname($vendorDir); return array('0e6d7bf4a5811bfa5cf40c5ccd6fae6a' =&gt; $vendorDir . '/symfony/polyfill-mbstring/bootstrap.php','667aeda72477189d0494fecd327c3641' =&gt; $vendorDir . '/symfony/var-dumper/Resources/functions/dump.php', ....); 其实跟静态初始化区别不大。 加载全局函数123456789101112131415161718class ComposerAutoloaderInit7b790917ce8899df9af8ed53631a1c29&#123; public static function getLoader()&#123; ... foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file); &#125; ... &#125;&#125;function composerRequire7b790917ce8899df9af8ed53631a1c29($fileIdentifier, $file) &#123; if (empty(\\$GLOBALS['__composer_autoload_files'][\\$fileIdentifier])) &#123; require $file; $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true; &#125;&#125; 第五部分 —— 运行到这里，终于来到了核心的核心—— composer 自动加载的真相，命名空间如何通过 composer 转为对应目录文件的奥秘就在这一章。前面说过，ClassLoader 的 register() 函数将 loadClass() 函数注册到 PHP 的 SPL 函数堆栈中，每当 PHP 遇到不认识的命名空间时就会调用函数堆栈的每个函数，直到加载命名空间成功。所以 loadClass() 函数就是自动加载的关键了。 看下 loadClass() 函数: 1234567891011121314151617181920212223242526272829303132333435363738public function loadClass($class)&#123; if ($file = $this-&gt;findFile($class)) &#123; includeFile($file); return true; &#125;&#125;public function findFile($class)&#123; // work around for PHP 5.3.0 - 5.3.2 https://bugs.php.net/50731 if ('\\\\' == $class[0]) &#123; $class = substr($class, 1); &#125; // class map lookup if (isset($this-&gt;classMap[$class])) &#123; return $this-&gt;classMap[$class]; &#125; if ($this-&gt;classMapAuthoritative) &#123; return false; &#125; $file = $this-&gt;findFileWithExtension($class, '.php'); // Search for Hack files if we are running on HHVM if ($file === null &amp;&amp; defined('HHVM_VERSION')) &#123; $file = $this-&gt;findFileWithExtension($class, '.hh'); &#125; if ($file === null) &#123; // Remember that this class does not exist. return $this-&gt;classMap[$class] = false; &#125; return $file;&#125; 我们看到 loadClass() ，主要调用 findFile() 函数。findFile() 在解析命名空间的时候主要分为两部分：classMap 和 findFileWithExtension() 函数。classMap 很简单，直接看命名空间是否在映射数组中即可。麻烦的是 findFileWithExtension() 函数，这个函数包含了 PSR0 和 PSR4 标准的实现。还有个值得我们注意的是查找路径成功后 includeFile() 仍然是外面的函数，并不是 ClassLoader 的成员函数，原理跟上面一样，防止有用户写 $this 或 self。还有就是如果命名空间是以\\开头的，要去掉\\然后再匹配。 看下 findFileWithExtension 函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private function findFileWithExtension($class, $ext)&#123; // PSR-4 lookup $logicalPathPsr4 = strtr($class, '\\\\', DIRECTORY_SEPARATOR) . $ext; $first = $class[0]; if (isset($this-&gt;prefixLengthsPsr4[$first])) &#123; foreach ($this-&gt;prefixLengthsPsr4[$first] as $prefix =&gt; $length) &#123; if (0 === strpos($class, $prefix)) &#123; foreach ($this-&gt;prefixDirsPsr4[$prefix] as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) &#123; return $file; &#125; &#125; &#125; &#125; &#125; // PSR-4 fallback dirs foreach ($this-&gt;fallbackDirsPsr4 as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) &#123; return $file; &#125; &#125; // PSR-0 lookup if (false !== $pos = strrpos($class, '\\\\')) &#123; // namespaced class name $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1) . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR); &#125; else &#123; // PEAR-like class name $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext; &#125; if (isset($this-&gt;prefixesPsr0[$first])) &#123; foreach ($this-&gt;prefixesPsr0[$first] as $prefix =&gt; $dirs) &#123; if (0 === strpos($class, $prefix)) &#123; foreach ($dirs as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123; return $file; &#125; &#125; &#125; &#125; &#125; // PSR-0 fallback dirs foreach ($this-&gt;fallbackDirsPsr0 as $dir) &#123; if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123; return $file; &#125; &#125; // PSR-0 include paths. if ($this-&gt;useIncludePath &amp;&amp; $file = stream_resolve_include_path($logicalPathPsr0)) &#123; return $file; &#125;&#125; 最后小结我们通过举例来说下上面代码的流程： 如果我们在代码中写下 new phpDocumentor\\Reflection\\Element()，PHP 会通过 SPL_autoload_register 调用 loadClass -&gt; findFile -&gt; findFileWithExtension。步骤如下： 将 \\ 转为文件分隔符/，加上后缀php，变成 $logicalPathPsr4, 即 phpDocumentor/Reflection//Element.php; 利用命名空间第一个字母p作为前缀索引搜索 prefixLengthsPsr4 数组，查到下面这个数组： 12345p' =&gt; array ( 'phpDocumentor\\\\Reflection\\\\' =&gt; 25, 'phpDocumentor\\\\Fake\\\\' =&gt; 19, ) 遍历这个数组，得到两个顶层命名空间 phpDocumentor\\Reflection\\ 和 phpDocumentor\\Fake\\ 在这个数组中查找 phpDocumentor\\Reflection\\Element，找出 phpDocumentor\\Reflection\\ 这个顶层命名空间并且长度为25。 在prefixDirsPsr4 映射数组中得到phpDocumentor\\Reflection\\ 的目录映射为： 123456'phpDocumentor\\\\Reflection\\\\' =&gt; array ( 0 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-common/src', 1 =&gt; __DIR__ . '/..' . '/phpdocumentor/type-resolver/src', 2 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src', ), 遍历这个映射数组，得到三个目录映射； 查看 “目录+文件分隔符//+substr(\\$logicalPathPsr4, \\$length)”文件是否存在，存在即返回。这里就是&#39;__DIR__/../phpdocumentor/reflection-common/src + substr(phpDocumentor/Reflection/Element.php,25)&#39; 如果失败，则利用 fallbackDirsPsr4 数组里面的目录继续判断是否存在文件 The end. Thanks!","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"composer","slug":"composer","permalink":"http://www.tenpercent.top/tags/composer/"}]},{"title":"对PHP 后期静态绑定的理解","date":"2018-03-19T16:00:00.000Z","path":"2018/03/20/late-static-bindings/","text":"什么是后期静态绑定在看一些框架源码或者是某个项目的代码时，经常能看到后期静态绑定的用法。比如下面这段： 1234567public static function getInstance()&#123; if (is_null(static::$instance)) &#123; static::$instance = new static; &#125; return static::$instance;&#125; 这里用到的就是后期静态绑定。那么，什么是后期静态绑定？ “后期绑定”的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。 这里要先说两个概念，一个是转发调用，另一个是非转发调用。 转发调用所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：self::, parent::, static:: 以及 forward_ static _call()。即在进行静态调用时未指名类名的调用属于转发调用。 非转发调用非转发调用其实就是明确指定类名的静态调用（foo::bar()）和非静态调用($foo-&gt;bar())。即明确地指定类名的静态调用和非静态调用。 顾名思义，非转发调用前面有类名所以调用的函数一定是属于“这个类的”，不需要转到别的类。转发调用就是由于前期的静态绑定导致在后面调用静态方法时可能“转发到其他的类” 在PHP的官方文档里，对于后期静态绑定是这样说的：后期静态绑定工作原理是存储了在上一个“非转发调用”（non-forwarding call）中的类名。意思是当我们调用一个转发调用的静态调用时，实际调用的类是上一个非转发调用的类。 来看两个例子： 例1： 1234567891011121314class A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; static::who(); // 后期静态绑定从这里开始 &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test(); 以上代码会输出 1B 例2： 12345678910111213141516171819202122232425262728class A &#123; public static function foo() &#123; static::who(); &#125; public static function who() &#123; echo __CLASS__.\"\\n\"; &#125;&#125;class B extends A &#123; public static function test() &#123; A::foo(); parent::foo(); self::foo(); &#125; public static function who() &#123; echo __CLASS__.\"\\n\"; &#125;&#125;class C extends B &#123; public static function who() &#123; echo __CLASS__.\"\\n\"; &#125;&#125;C::test(); 以上代码会输出 123ACC 在这里主要分析下例2。 1.C::test()，这是一个非转发调用，因为::前面有类名C。 2.进入test()方法，有三个静态调用 A::foo(),parent::foo(),self::foo(),对于这三个静态调用来说，他们的非转发调用类就是 C。 3.现在执行A::foo(),这是一个非转发调用。A::foo()中的代码是 static::who(),这是一个转发调用，对于这个转发调用来说他的非转发调用类就是不再是C而是A（因为之前执行了A::foo()）。因此执行的结果为A 4.现在执行 parent::foo(),这是一个转发调用，转发到哪里呢？就是它的上一个非转发调用的类，也就是类C（在步骤2中提到的）。在这里一定要注意虽然在这之前执行了 A::foo(),但是 parent::foo()的上一个非转发调用的类任然是类C。因此执行的结果是 C. 5.现在执行 self::foo(),这个和 parent::foo()一样都是转发调用，因此也输出 C。 使用后期静态绑定的好处后期静态绑定目前我看到较多的是用于对象实例化中，在实例化对象时，static 会根据运行时调用的类来决定实例化对象，而 self 则是根据所在位置的类来决定实例化对象。当我们只想实例化子类，并且不希望后续在对子类的使用中由于父类的变化对子类产生影响时，后期静态绑定就能发挥它的作用了。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"星云链（Nabulas）——区块链领域的新基石","date":"2018-02-05T16:00:00.000Z","path":"2018/02/06/nabulas/","text":"最近对区块链比较感兴趣，前几个月就开始关注区块链了，但是因为时间不够并没有去深究，只是粗粗的看了一本《区块链技术的应用与未来》，这个书偏入门，很多概念讲的比较浅。打算后续要花点时间在技术细节上面的学习，比如共识算法，智能合约，图灵完备，零知识证明，隔离见证，闪电网络等等，后续会抽空写篇文章来总结一下这些概念。 这段时间也对市面上的很多区块链项目有了一些了解，也投资了一些项目，注意，是投资，不是炒币，我始终是坚持长线的价值投资的，看好区块链的未来。这其中，我觉得一个叫星云链的项目潜力很大，要做区块链领域的谷歌。最近他们官方组织一个征文比赛，要在 medium 上发稿，我也参加了下，链接在这里 Nabulas, a new foundation for blockchain technology ，有看到的童鞋可以点个赞哈。ps: 需要科学上网查看。 但是这一两个月有点偏不务正业了，自己的编程学习计划都没怎么好好开展，一月份的总结文章都没腾出空写，后面要补上。得收收心，不能本末倒置了，先把手头的东西学精了再说，区块链技术慢慢了解慢慢深入。嗯。继续加油！","tags":[{"name":"区块链","slug":"区块链","permalink":"http://www.tenpercent.top/tags/区块链/"},{"name":"星云链","slug":"星云链","permalink":"http://www.tenpercent.top/tags/星云链/"}]},{"title":"关于 RESTful API 设计的总结","date":"2017-12-08T16:00:00.000Z","path":"2017/12/09/RESTful/","text":"为什么要用 RESTfulRESTful 给我的最大感觉就是规范、易懂和优雅，一个结构清晰、易于理解的 API 完全可以省去许多无意义的沟通和文档。并且 RESTful 现在越来越流行， 在开始介绍 RESTful API 之前，先介绍一下 RESTful 架构。 RESTful 架构REST，即Representational State Transfer 的缩写。意为 “ 表现层状态转化 “ 。 要理解RESTful架构，最好的方法就是去理解 Representational State Transfer 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果把这个名称搞懂了，也就不难体会 REST 是一种什么样的设计。 资源 （Resources）REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或独一无二的识别符。所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的 URI 。 表现层（Representation）“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、 XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。URI 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的” .html “后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而 URI 应该只代表”资源”的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对”表现层”的描述。 状态转化（State Transfer）访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET 、 POST 、 PUT 、 DELETE 。 它们分别对应四种基本操作： GET 用来获取资源， POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 综述总结一下什么是RESTful架构： 每一个URI代表一种资源； 客户端和服务器之间，传递这种资源的某种表现层； 客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 RESTful API 的设计介绍完 RESTful 的含义，再说说 RESTful API 的设计。 协议如果能全站 HTTPS 当然是最好的，不能的话也请尽量将登录、注册等涉及密码的接口使用 HTTPS。 域名应该尽量将API部署在专用域名之下。如： 1https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 1https://example.org/api/ 版本号API 的版本号和客户端 APP 的版本号是毫无关系的，不要让 APP 将它们用于提交应用市场的版本号传递到服务器，而是提供类似于v1、v2之类的 API 版本号。 版本号拼接在 URL 中。如： 1api.example.com/v1/users 或是放在 Header 中: 123api.xxx.com/usersversion=v1 请求一般来说 API 的外在形式无非就是增删改查（当然具体的业务逻辑肯定要复杂得多），而查询又分为详情和列表两种，在 RESTful 中这就相当于通用的模板。例如针对文章（Article）设计 API，那么最基础的 URL 就是这几种： GET /articles： 文章列表 GET /articles/id：文章详情 POST /articles/： 创建文章 PUT /articles/id：修改文章 DELETE /articles/id：删除文章 Token 和 SignAPI 需要设计成无状态，所以客户端在每次请求时都需要提供有效的 Token 和 Sign，在我看来它们的用途分别是： Token 用于证明请求所属的用户，一般都是服务端在登录后随机生成一段字符串（UUID）和登录用户进行绑定，再将其返回给客户端。Token 的状态保持一般有两种方式实现：一种是在用户每次操作都会延长或重置 TOKEN 的生存时间（类似于缓存的机制），另一种是 Token 的生存时间固定不变，但是同时返回一个刷新用的 Token，当 Token 过期时可以将其刷新而不是重新登录。 Sign 用于证明该次请求合理，所以一般客户端会把请求参数拼接后并加密作为 Sign 传给服务端，这样即使被抓包了，对方只修改参数而无法生成对应的 Sign 也会被服务端识破。当然也可以将时间戳、请求地址和 Token 也混入 Sign，这样 Sign 也拥有了所属人、时效性和目的地。 业务参数在 RESTful 的标准中，PUT 和 PATCH 都可以用于修改操作，它们的区别是 PUT 需要提交整个对象，而 PATCH 只需要提交修改的信息。但是在我看来实际应用中不需要这么麻烦，所以我一律使用 PUT，并且只提交修改的信息。 另一个问题是在 POST 创建对象时，究竟该用表单提交更好些还是用 JSON 提交更好些。其实两者都可以，在我看来它们唯一的区别是 JSON 可以比较方便的表示更为复杂的结构（有嵌套对象）。另外无论使用哪种，请保持统一，不要两者混用。 还有一个建议是最好将过滤、分页和排序的相关信息全权交给客户端，包括过滤条件、页数或是游标、每页的数量、排序方式、升降序等，这样可以使 API 更加灵活。但是对于过滤条件、排序方式等，不需要支持所有方式，只需要支持目前用得上的和以后可能会用上的方式即可，并通过字符串枚举解析，这样可见性要更好些。例如： 搜索，客户端只提供关键词，具体搜索的字段，和搜索方式（前缀、全文、精确）由服务端决定： 1/users/?query=ScienJus 过滤，只需要对已有的情况进行支持： 1/users/?gender=1 分页： 1/users/?page=2&amp;pre_page=20 响应尽量使用 HTTP 状态码，常用的有： 200：请求成功 201：创建、修改成功 204：删除成功 400：参数错误 401：未登录 403：禁止访问 404：未找到 500：系统错误 但是有些时候仅仅使用 HTTP 状态码没有办法明确的表达错误信息，所以也可以在里面再包一层自定义的返回码，例如： 成功时： 12345&#123; &quot;code&quot;: 100, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: &#123;&#125;&#125; 1234&#123; &quot;code&quot;: -1000, &quot;msg&quot;: &quot;用户名或密码错误&quot;&#125; data是真正需要返回的数据，并且只会在请求成功时才存在，msg只用在开发环境，并且只为了开发人员识别。客户端逻辑只允许识别code，并且不允许直接将msg的内容展示给用户。如果这个错误很复杂，无法使用一段话描述清楚，也可以在添加一个doc字段，包含指向该错误的文档的链接。 返回数据JSON 比 XML 可视化更好，也更加节约流量，所以尽量不要使用 XML。 创建和修改操作成功后，需要返回该资源的全部信息。 返回数据不要和客户端界面强耦合，不要在设计 API 时就考虑少查询一张关联表或是少查询 / 返回几个字段能带来多大的性能提升。并且一定要以资源为单位，即使客户端一个页面需要展示多个资源，也不要在一个接口中全部返回，而是让客户端分别请求多个接口。 最好将返回数据进行加密和压缩，尤其是压缩在移动应用中还是比较重要的。","tags":[{"name":"API","slug":"API","permalink":"http://www.tenpercent.top/tags/API/"},{"name":"RESTful","slug":"RESTful","permalink":"http://www.tenpercent.top/tags/RESTful/"}]},{"title":"观察者模式的总结","date":"2017-11-17T16:00:00.000Z","path":"2017/11/18/observer-pattern/","text":"什么是观察者模式观察者模式用于实现对对象进行观察：一旦主体对象状态发生改变，与之关联的观察者对象会收到通知，并进行相应操作。 举个例子说明：假设一个这样的情景，当公司有一个新员工入职了，入职的当天，HR需要为他办理入职手续，网管需要给他配好电脑和办公用品，部门主管需要带他熟悉部门。传统的编程方式，就是在员工入职这个事件发生的代码之后直接加入处理逻辑,当后续我们需要增加处理逻辑时（比如员工入职后增加培训），代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要改变事件主题的代码。运用观察者模式，将员工的入职作为事件，其他的处理逻辑都做为观察者的操作，那么，当以后需要再增加更多的逻辑时，新增逻辑代码就会很方便。具体代码实现如下。 代码实现首先定义一个观察者接口，所有的观察者都实现这个接口（为什么要定义成接口呢？因为每一个观察者的具体行为需要具体去实现，用接口定义一个统一的方法，具体的实现交给观察者去实现） 1234interface observer&#123; public function update();&#125; 再定义一个事件生成器的抽象类，用来使继承它的事件都具有通知观察者的能力。 1234567891011121314151617181920abstract class EventGenerator&#123; private $observers = []; //定义一个添加观察者的方法 public function addOberver(Observer $observer) &#123; $this-&gt;observers[] = $observer; &#125; //定义一个通知观察者的方法 public function notify() &#123; foreach($this-&gt;observers as $observer) &#123; $observer-&gt;update(); &#125; &#125;&#125; 然后再来定义事件类 1234567891011class event extends EventGenerator&#123; //定义一个触发观察者的方法 public funtion trigger() &#123; echo \"Event &lt;br/&gt;\"; //开始通知观察者 $this-&gt;notify(); &#125; &#125; 开始使用 12$event = new event();$event-&gt;trigger(); 这个时候，当我们要在事件发生的时候增加别的操作，只需要新增观察者就可以了 新增一个观察者 12345678class Observer1 implements Observer&#123; public function update() &#123; echo \"操作1&lt;br/&gt;\"; &#125; &#125; 然后使用的时候就是 1234$event = new event();// 增加观察者$event-&gt;addObserver(new Observer1);$event-&gt;trigger(); 如果需要在事件发生后再增加操作，只需再新增相应的观察者即可。 应用观察者模式的好处观察者模式解除了主体和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。降低对象之间的耦合度以达到解耦的目的，符合”开闭原则”的要求。 利用 SPL 实现观察者模式PHP 通过内置的 SPL 扩展提供了对观察者模式的原生支持，其中的观察者由 3 个元素组成 ： SplObserver 接口、 SplSubject 接口和 SplObjectStorage 工具类。下面是利用 SPL 实现观察者模式的代码。SPL 的地址见这里。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class MyObserver1 implements SplObserver &#123; public function update(SplSubject $subject) &#123; echo __CLASS__ . ' - ' . $subject-&gt;getName(); &#125;&#125;class MyObserver2 implements SplObserver &#123; public function update(SplSubject $subject) &#123; echo __CLASS__ . ' - ' . $subject-&gt;getName(); &#125;&#125;class MySubject implements SplSubject &#123; private $observers; private $name; public function __construct($name) &#123; $this-&gt;observers = new SplObjectStorage(); $this-&gt;name = $name; &#125; public function attach(SplObserver $observer) &#123; $this-&gt;observers-&gt;attach($observer); &#125; public function detach(SplObserver $observer) &#123; $this-&gt;observers-&gt;detach($observer); &#125; public function notify() &#123; foreach ($this-&gt;observers as $observer) &#123; $observer-&gt;update($this); &#125; &#125; public function getName() &#123; return $this-&gt;name; &#125;&#125;$observer1 = new MyObserver1();$observer2 = new MyObserver2();$subject = new MySubject(\"test\");$subject-&gt;attach($observer1);$subject-&gt;attach($observer2);$subject-&gt;notify();/* 输出:MyObserver1 - testMyObserver2 - test*/$subject-&gt;detach($observer2);$subject-&gt;notify();/* 输出:MyObserver1 - test*/","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"PHP代码简洁之道——SOLID原则","date":"2017-10-13T16:00:00.000Z","path":"2017/10/14/clean-code-solid/","text":"SOLID 是Michael Feathers推荐的便于记忆的首字母简写，它代表了Robert Martin命名的最重要的五个面对对象编码设计原则 S: 单一职责原则 (SRP) O: 开闭原则 (OCP) L: 里氏替换原则 (LSP) I: 接口隔离原则 (ISP) D: 依赖反转原则 (DIP) 单一职责原则 Single Responsibility Principle (SRP)“修改一个类应该只为一个理由”。人们总是易于用一堆方法塞满一个类，如同我们在飞机上只能携带一个行李箱（把所有的东西都塞到箱子里）。这样做的问题是：从概念上这样的类不是高内聚的，并且留下了很多理由去修改它。将你需要修改类的次数降低到最小很重要。这是因为，当有很多方法在类中时，修改其中一处，你很难知晓在代码库中哪些依赖的模块会被影响到。 Bad: 123456789101112131415161718192021class UserSettings&#123; private $user; public function __construct($user) &#123; $this-&gt;user = $user; &#125; public function changeSettings($settings) &#123; if ($this-&gt;verifyCredentials()) &#123; // ... &#125; &#125; private function verifyCredentials() &#123; // ... &#125;&#125; Good: 123456789101112131415161718192021222324252627282930313233class UserAuth &#123; private $user; public function __construct($user) &#123; $this-&gt;user = $user; &#125; public function verifyCredentials() &#123; // ... &#125;&#125;class UserSettings &#123; private $user; private $auth; public function __construct($user) &#123; $this-&gt;user = $user; $this-&gt;auth = new UserAuth($user); &#125; public function changeSettings($settings) &#123; if ($this-&gt;auth-&gt;verifyCredentials()) &#123; // ... &#125; &#125;&#125; 开闭原则 Open/Closed Principle (OCP)正如Bertrand Meyer所述，”软件的实体（类, 模块, 函数,等）应该对扩展开放，对修改关闭。”这个原则是在说明应该允许用户在不改变已有代码的情况下增加新的功能。 Bad: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960abstract class Adapter&#123; protected $name; public function getName() &#123; return $this-&gt;name; &#125;&#125;class AjaxAdapter extends Adapter&#123; public function __construct() &#123; parent::__construct(); $this-&gt;name = 'ajaxAdapter'; &#125;&#125;class NodeAdapter extends Adapter&#123; public function __construct() &#123; parent::__construct(); $this-&gt;name = 'nodeAdapter'; &#125;&#125;class HttpRequester&#123; private $adapter; public function __construct($adapter) &#123; $this-&gt;adapter = $adapter; &#125; public function fetch($url) &#123; $adapterName = $this-&gt;adapter-&gt;getName(); if ($adapterName === 'ajaxAdapter') &#123; return $this-&gt;makeAjaxCall($url); &#125; elseif ($adapterName === 'httpNodeAdapter') &#123; return $this-&gt;makeHttpCall($url); &#125; &#125; private function makeAjaxCall($url) &#123; // request and return promise &#125; private function makeHttpCall($url) &#123; // request and return promise &#125;&#125; 在上面的代码中，对于HttpRequester类中的fetch方法，如果我新增了一个新的xxxAdapter类并且要在fetch方法中用到的话，就需要在HttpRequester类中去修改类（如加上一个elseif 判断），而通过下面的代码，就可很好的解决这个问题。下面代码很好的说明了如何在不改变原有代码的情况下增加新功能。 Good: 1234567891011121314151617181920212223242526272829303132333435interface Adapter&#123; public function request($url);&#125;class AjaxAdapter implements Adapter&#123; public function request($url) &#123; // request and return promise &#125;&#125;class NodeAdapter implements Adapter&#123; public function request($url) &#123; // request and return promise &#125;&#125;class HttpRequester&#123; private $adapter; public function __construct(Adapter $adapter) &#123; $this-&gt;adapter = $adapter; &#125; public function fetch($url) &#123; return $this-&gt;adapter-&gt;request($url); &#125;&#125; 里氏替换原则 Liskov Substitution Principle (LSP)对这个概念最好的解释是：如果你有一个父类和一个子类，在不改变原有结果正确性的前提下父类和子类可以互换。这个听起来让人有些迷惑，所以让我们来看一个经典的正方形-长方形的例子。从数学上讲，正方形是一种长方形，但是当你的模型通过继承使用了”is-a”的关系时，就不对了。 Bad: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Rectangle&#123; protected $width = 0; protected $height = 0; public function render($area) &#123; // ... &#125; public function setWidth($width) &#123; $this-&gt;width = $width; &#125; public function setHeight($height) &#123; $this-&gt;height = $height; &#125; public function getArea() &#123; return $this-&gt;width * $this-&gt;height; &#125;&#125;class Square extends Rectangle&#123; public function setWidth($width) &#123; $this-&gt;width = $this-&gt;height = $width; &#125; public function setHeight(height) &#123; $this-&gt;width = $this-&gt;height = $height; &#125;&#125;function renderLargeRectangles($rectangles)&#123; foreach ($rectangles as $rectangle) &#123; $rectangle-&gt;setWidth(4); $rectangle-&gt;setHeight(5); $area = $rectangle-&gt;getArea(); // BAD: Will return 25 for Square. Should be 20. $rectangle-&gt;render($area); &#125;&#125;$rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles($rectangles); Good: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263abstract class Shape&#123; protected $width = 0; protected $height = 0; abstract public function getArea(); public function render($area) &#123; // ... &#125;&#125;class Rectangle extends Shape&#123; public function setWidth($width) &#123; $this-&gt;width = $width; &#125; public function setHeight($height) &#123; $this-&gt;height = $height; &#125; public function getArea() &#123; return $this-&gt;width * $this-&gt;height; &#125;&#125;class Square extends Shape&#123; private $length = 0; public function setLength($length) &#123; $this-&gt;length = $length; &#125; public function getArea() &#123; return pow($this-&gt;length, 2); &#125;&#125;function renderLargeRectangles($rectangles)&#123; foreach ($rectangles as $rectangle) &#123; if ($rectangle instanceof Square) &#123; $rectangle-&gt;setLength(5); &#125; elseif ($rectangle instanceof Rectangle) &#123; $rectangle-&gt;setWidth(4); $rectangle-&gt;setHeight(5); &#125; $area = $rectangle-&gt;getArea(); $rectangle-&gt;render($area); &#125;&#125;$shapes = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles($shapes); 接口隔离原则接口隔离原则：”客户端不应该被强制去实现于它不需要的接口”。 有一个清晰的例子来说明示范这条原则。当一个类需要一个大量的设置项，为了方便不会要求客户端去设置大量的选项，因为在通常他们不需要所有的设置项。使设置项可选有助于我们避免产生”胖接口” Bad: 1234567891011121314151617181920212223242526272829303132interface Employee&#123; public function work(); public function eat();&#125;class Human implements Employee&#123; public function work() &#123; // ....working &#125; public function eat() &#123; // ...... eating in lunch break &#125;&#125;class Robot implements Employee&#123; public function work() &#123; //.... working much more &#125; public function eat() &#123; //.... robot can't eat, but it must implement this method &#125;&#125; 上面的代码中，Robot类并不需要eat()这个方法，但是实现了Emplyee接口，于是只能实现所有的方法了，这使得Robot实现了它并不需要的方法。所以在这里应该对Emplyee接口进行拆分，正确的代码如下： Good: 1234567891011121314151617181920212223242526272829303132333435interface Workable&#123; public function work();&#125;interface Feedable&#123; public function eat();&#125;interface Employee extends Feedable, Workable&#123;&#125;class Human implements Employee&#123; public function work() &#123; // ....working &#125; public function eat() &#123; //.... eating in lunch break &#125;&#125;// robot can only workclass Robot implements Workable&#123; public function work() &#123; // ....working &#125;&#125; 依赖反转原则 Dependency Inversion Principle (DIP)这条原则说明两个基本的要点： 高阶的模块不应该依赖低阶的模块，它们都应该依赖于抽象 抽象不应该依赖于实现，实现应该依赖于抽象 这条起初看起来有点晦涩难懂，但是如果你使用过php框架（例如 Symfony），你应该见过依赖注入（DI）对这个概念的实现。虽然它们不是完全相通的概念，依赖倒置原则使高阶模块与低阶模块的实现细节和创建分离。可以使用依赖注入（DI）这种方式来实现它。更多的好处是它使模块之间解耦。耦合会导致你难于重构，它是一种非常糟糕的的开发模式。 Bad: 123456789101112131415161718192021222324252627282930class Employee&#123; public function work() &#123; // ....working &#125;&#125;class Robot extends Employee&#123; public function work() &#123; //.... working much more &#125;&#125;class Manager&#123; private $employee; public function __construct(Employee $employee) &#123; $this-&gt;employee = $employee; &#125; public function manage() &#123; $this-&gt;employee-&gt;work(); &#125;&#125; Good: 1234567891011121314151617181920212223242526272829303132333435interface Employee&#123; public function work();&#125;class Human implements Employee&#123; public function work() &#123; // ....working &#125;&#125;class Robot implements Employee&#123; public function work() &#123; //.... working much more &#125;&#125;class Manager&#123; private $employee; public function __construct(Employee $employee) &#123; $this-&gt;employee = $employee; &#125; public function manage() &#123; $this-&gt;employee-&gt;work(); &#125;&#125; 别写重复代码 (DRY)这条原则大家应该都是比较熟悉了。 尽你最大的努力去避免复制代码，它是一种非常糟糕的行为，复制代码通常意味着当你需要变更一些逻辑时，你需要修改不止一处。 Bad: 12345678910111213141516171819202122232425262728293031function showDeveloperList($developers)&#123; foreach ($developers as $developer) &#123; $expectedSalary = $developer-&gt;calculateExpectedSalary(); $experience = $developer-&gt;getExperience(); $githubLink = $developer-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125;function showManagerList($managers)&#123; foreach ($managers as $manager) &#123; $expectedSalary = $manager-&gt;calculateExpectedSalary(); $experience = $manager-&gt;getExperience(); $githubLink = $manager-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125; Good: 123456789101112131415function showList($employees)&#123; foreach ($employees as $employee) &#123; $expectedSalary = $employee-&gt;calculateExpectedSalary(); $experience = $employee-&gt;getExperience(); $githubLink = $employee-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125; Very good: 12345678910function showList($employees)&#123; foreach ($employees as $employee) &#123; render([ $employee-&gt;calculateExpectedSalary(), $employee-&gt;getExperience(), $employee-&gt;getGithubLink() ]); &#125;&#125; 后记：虽然OOP设计需要遵守如上原则，不过实际的代码设计一定要简单、简单、简单。在实际编码中要根据情况进行取舍，一味遵守原则，而不注重实际情况的话，可能会让你的代码变的难以理解!","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"PHP代码简洁之道——类和对象部分","date":"2017-10-02T16:00:00.000Z","path":"2017/10/03/clean-code-php-object/","text":"使用getter和setter在 PHP 中，通过为属性或方法设置 public, protected 和 private 关键字可以实现对属性或方法的可见性控制。不过，通过 getter 和 setter 也可以达到控制可见性的目的，并且在某些场景下它具备一些额外的好处。 使用 getter和 setter 有以下好处： 当你除了获取对象之外还想做一些别的事情时，就不用到项目中去查找所有的属性并修改 使添加验证更简单 在获取和设置时添加日志和错误处理更方便 我们可以延迟加载类的属性 继承了类，你可以重写默认的函数 另外，这是面向对象的基本设计原则中的开放/封闭原则。 Bad: 123456789class BankAccount&#123; public $balance = 1000;&#125;$bankAccount = new BankAccount();// 买了一双鞋...$bankAccount-&gt;balance -= 100; Good: 12345678910111213141516171819202122232425262728293031323334353637class BankAccount&#123; private $balance; public function __construct($balance = 1000) &#123; $this-&gt;balance = $balance; &#125; //做一些事情 public function withdrawBalance($amount) &#123; if ($amount &gt; $this-&gt;balance) &#123; throw new \\Exception('Amount greater than available balance.'); &#125; $this-&gt;balance -= $amount; &#125; public function depositBalance($amount) &#123; $this-&gt;balance += $amount; &#125; public function getBalance() &#123; return $this-&gt;balance; &#125;&#125;$bankAccount = new BankAccount();// 买了一双鞋...$bankAccount-&gt;withdrawBalance($shoesPrice);// 获取结余$balance = $bankAccount-&gt;getBalance(); 让对象具有私有或受保护的的成员Bad: 123456789101112class Employee&#123; public $name; public function __construct($name) &#123; $this-&gt;name = $name; &#125;&#125;$employee = new Employee('John Doe');echo 'Employee name: '.$employee-&gt;name; // Employee name: John Doe Good: 1234567891011121314151617class Employee&#123; private $name; public function __construct($name) &#123; $this-&gt;name = $name; &#125; public function getName() &#123; return $this-&gt;name; &#125;&#125;$employee = new Employee('John Doe');echo 'Employee name: '.$employee-&gt;getName(); // Employee name: John Doe 使用组合而不是继承这里不是说不使用继承，使用“组合模式”和使用“继承”都有很多好的理由。 这里想说的是当你本能的要使用继承时就想一想“组合模式”是否能更好帮你的解决问题。 那么，你可能想知道，“什么时候应该用继承？”， 这取决于你手头上问题。 以下几点说明了什么时候使用继承会更合适。 你的继承表达了一个对等（比如”人类是动物”）的关系，不是包含的关系（比如”用户具有用户详情”） 你能从基类中复用代码 你想通过修改全局类来对所有派生类进行修改。 Bad: 123456789101112131415161718192021222324252627282930313233class Employee &#123; private $name; private $email; public function __construct($name, $email) &#123; $this-&gt;name = $name; $this-&gt;email = $email; &#125; // ...&#125;// 因为雇员和税收不是对等关系而是包含的关系// 所以这里应用组合比较合适class EmployeeTaxData extends Employee &#123; private $ssn; private $salary; public function __construct($name, $email, $ssn, $salary) &#123; parent::__construct($name, $email); $this-&gt;ssn = $ssn; $this-&gt;salary = $salary; &#125; // ...&#125; Good: 123456789101112131415161718192021222324252627282930313233class EmployeeTaxData &#123; private $ssn; private $salary; public function __construct($ssn, $salary) &#123; $this-&gt;ssn = $ssn; $this-&gt;salary = $salary; &#125; // ...&#125;class Employee &#123; private $name; private $email; private $taxData; public function __construct($name, $email) &#123; $this-&gt;name = $name; $this-&gt;email = $email; &#125; public function setTaxData($ssn, $salary) &#123; $this-&gt;taxData = new EmployeeTaxData($ssn, $salary); &#125; // ...&#125;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"PHP代码简洁之道——函数部分","date":"2017-09-30T16:00:00.000Z","path":"2017/10/01/clean-code-php-function/","text":"函数参数不要超过两个限制函数的参数数量是非常重要的，因为它使你的函数更容易测试。超过三个参数会导致参数之间的组合过多，你必须对每个单独的参数测试大量不同的情况。 没有参数是最理想的情况，一个或两个参数是可以接受的，三个以上则是应该避免的。这很重要。如果你有两个以上的参数，那么你的函数可能试图做的太多，如果不是，你可能需要将一个高级别的对象传当做参数传进去。 Bad: 12345function createMenu($title, $body, $buttonText, $cancellable)&#123; // ...&#125; Good： 123456789101112131415161718class MenuConfig&#123; public $title; public $body; public $buttonText; public $cancellable = false;&#125;$config = new MenuConfig();$config-&gt;title = 'Foo';$config-&gt;body = 'Bar';$config-&gt;buttonText = 'Baz';$config-&gt;cancellable = true;function createMenu(MenuConfig $config)&#123; // ...&#125; 一个函数只做一件事这是软件工程中一个重要的原则。这会让你的代码清晰易懂以及易于复用。 Bad： 123456789function emailClients($clients)&#123; foreach ($clients as $client) &#123; $clientRecord = $db-&gt;find($client); if ($clientRecord-&gt;isActive()) &#123; email($client); &#125; &#125;&#125; Good: 1234567891011121314151617function emailClients($clients)&#123; $activeClients = activeClients($clients); array_walk($activeClients, 'email');&#125;function activeClients($clients)&#123; return array_filter($clients, 'isClientActive');&#125;function isClientActive($client)&#123; $clientRecord = $db-&gt;find($client); return $clientRecord-&gt;isActive();&#125; 函数名要能说明它是做什么的Bad: 12345678910111213class Email&#123; //... public function handle() &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// 这是什么？一条消息的句柄？还是要写一个文件？（读者的疑问）$message-&gt;handle(); Good: 12345678910111213class Email &#123; //... public function send() &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// 一目了然$message-&gt;send(); 函数应该只做一层抽象当你有多个层次的抽象时，你的函数就已经做的太多了。拆分这些函数，可以让代码可重用性更高且更易测试。Bad: 123456789101112131415161718192021222324function parseBetterJSAlternative($code)&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; // ... &#125; &#125; $ast = []; foreach ($tokens as $token) &#123; // lex... &#125; foreach ($ast as $node) &#123; // parse... &#125;&#125; Bad too:我们从函数中迁出去了一些工作，但是 parseBetterJSAlternative() 函数还是很复杂，不可测试。 1234567891011121314151617181920212223242526272829303132333435function tokenize($code)&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens;&#125;function lexer($tokens)&#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast;&#125;function parseBetterJSAlternative($code)&#123; $tokens = tokenize($code); $ast = lexer($tokens); foreach ($ast as $node) &#123; // parse... &#125;&#125; Good: 最好的解决方案是移除 parseBetterJSAlternative 函数的依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Tokenizer&#123; public function tokenize($code) &#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens; &#125;&#125;class Lexer&#123; public function lexify($tokens) &#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast; &#125;&#125;class BetterJSAlternative&#123; private $tokenizer; private $lexer; public function __construct(Tokenizer $tokenizer, Lexer $lexer) &#123; $this-&gt;tokenizer = $tokenizer; $this-&gt;lexer = $lexer; &#125; public function parse($code) &#123; $tokens = $this-&gt;tokenizer-&gt;tokenize($code); $ast = $this-&gt;lexer-&gt;lexify($tokens); foreach ($ast as $node) &#123; // parse... &#125; &#125;&#125; 不要使用标志作为函数的参数当你在函数中使用标志来作为参数时，你的函数就不是只做一件事情了，这与我们前面所讲的每个函数只做一件事的原则相违背，所以不要使用标志作为函数的参数。 Bad: 12345678function createFile($name, $temp = false)&#123; if ($temp) &#123; touch('./temp/'.$name); &#125; else &#123; touch($name); &#125;&#125; Good: 12345678910function createFile($name)&#123; touch($name);&#125;function createTempFile($name)&#123; touch('./temp/'.$name);&#125; 避免副作用如果一个函数做了“拿到一个值并返回一个值或者多个值”以外的事情，那么这个函数就有可能产生副作用，副作用可能是意外的写入了文件、修改了全局变量、或者打钱给了陌生人。 现在假如你确实要在函数中做一些有可能产生副作用的事情。 比如要写一个文件，你需要做的是将写文件的操作集中到一处，而不是在几个函数或者类里对同一个文件做操作，实现一个服务（函数或者类）去操作它，有且仅有一个。 关键是要能避免常见的陷阱：像是在没有结构的对象之间共享状态、使用可能被写入任何值的可变数据类型、 不集中处理有可能产生副作用的操作。 如果你能做到这些，你会比绝大多数程序员更快乐。 Bad: 1234567891011121314// Global variable referenced by following function.// If we had another function that used this name, now it'd be an array and it could break it.$name = 'Ryan McDermott';function splitIntoFirstAndLastName()&#123; global $name; $name = explode(' ', $name);&#125;splitIntoFirstAndLastName();var_dump($name); // ['Ryan', 'McDermott']; Good: 1234567891011function splitIntoFirstAndLastName($name)&#123; return explode(' ', $name);&#125;$name = 'Ryan McDermott';$newName = splitIntoFirstAndLastName($name);var_dump($name); // 'Ryan McDermott';var_dump($newName); // ['Ryan', 'McDermott']; 不要修改全局变量在许多编程语言中污染全局是一种糟糕的做法，因为你的库可能会与另一个库冲突，但是你的库的用户却一无所知，直到在生产环境中爆发异常。让我们来考虑一个例子：如果你想要拿到配置数组怎么办？你可以编写全局函数，如config()，但是它可能与另一个试图做同样事情的库冲突。 Bad: 123456function config()&#123; return [ 'foo' =&gt; 'bar', ]&#125; Good: 12345678910111213141516171819class Configuration&#123; private $configuration = []; public function __construct(array $configuration) &#123; $this-&gt;configuration = $configuration; &#125; public function get($key) &#123; return isset($this-&gt;configuration[$key]) ? $this-&gt;configuration[$key] : null; &#125;&#125;$configuration = new Configuration([ 'foo' =&gt; 'bar',]); 避免条件判断人们会问“如果不用 if 语句我该怎么做？”，答案是在许多情况下，你可以用多态来实现同样的效果。那这样做什么好处，还是那句话：“一个函数应该只做一件事”， 当你的类或函数中有了 if 语句，你的函数就不止是只做一件事情了。 Bad: 12345678910111213141516class Airplane&#123; // ... public function getCruisingAltitude() &#123; switch ($this-&gt;type) &#123; case '777': return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); case 'Air Force One': return $this-&gt;getMaxAltitude(); case 'Cessna': return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125; &#125;&#125; Good: 123456789101112131415161718192021222324252627282930313233343536interface Airplane&#123; // ... public function getCruisingAltitude();&#125;class Boeing777 implements Airplane&#123; // ... public function getCruisingAltitude() &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); &#125;&#125;class AirForceOne implements Airplane&#123; // ... public function getCruisingAltitude() &#123; return $this-&gt;getMaxAltitude(); &#125;&#125;class Cessna implements Airplane&#123; // ... public function getCruisingAltitude() &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125;&#125;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"PHP代码简洁之道——变量部分","date":"2017-09-23T16:00:00.000Z","path":"2017/09/24/clean-code-php/","text":"将代码写的简洁并且易读易懂是每一位优秀的coder所应该具备的基本功。 前几天在github上看到clean-code-php这个项目，感觉很有收获，于是在这里记录一下。 使用有意义并且可读的变量名称Bad: 1$ymdstr = $moment-&gt;format('y-m-d'); Good: 1$currentDate = $moment-&gt;format('y-m-d'); 对同一只类型的变量使用同样的词汇Bad: 1234getUserInfo();getUserData();getUserRecord();getUserProfile(); Good: 1getUser(); 使用易于查找的命名Bad: 1234// 这里的4是什么鬼??if ($user-&gt;access &amp; 4) &#123; // ...&#125; Good: 1234567891011class User&#123; const ACCESS_READ = 1; const ACCESS_CREATE = 2; const ACCESS_UPDATE = 4; const ACCESS_DELETE = 8;&#125;if ($user-&gt;access &amp; User::ACCESS_UPDATE) &#123; // do edit ...&#125; 不要让读者猜Bad: 123456789101112$l = ['Austin', 'New York', 'San Francisco'];for ($i = 0; $i &lt; count($l); $i++) &#123; $li = $l[$i]; doStuff(); doSomeOtherStuff(); // ... // ... // ... // $li 变量代表什么？？？ dispatch($li);&#125; Good: 12345678910$locations = ['Austin', 'New York', 'San Francisco'];foreach ($locations as $location) &#123; doStuff(); doSomeOtherStuff(); // ... // ... // ... dispatch($location);&#125; 避免过深的嵌套Bad: 123456789101112131415161718192021function isShopOpen($day)&#123; if ($day) &#123; if (is_string($day)) &#123; $day = strtolower($day); if ($day === 'friday') &#123; return true; &#125; elseif ($day === 'saturday') &#123; return true; &#125; elseif ($day === 'sunday') &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125;&#125; Good: 123456789101112function isShopOpen($day)&#123; if (empty($day) &amp;&amp; ! is_string($day)) &#123; return false; &#125; $openingDays = [ 'friday', 'saturday', 'sunday' ]; return in_array(strtolower($day), $openingDays);&#125; Bad: 12345678910111213141516function fibonacci($n)&#123; if ($n &lt; 50) &#123; if ($n !== 0) &#123; if ($n !== 1) &#123; return fibonacci($n - 1) + fibonacci($n - 2); &#125; else &#123; return 1; &#125; &#125; else &#123; return 0; &#125; &#125; else &#123; return 'Not supported'; &#125;&#125; Good: 12345678910111213141516function fibonacci($n)&#123; if ($n === 0) &#123; return 0; &#125; if ($n === 1) &#123; return 1; &#125; if ($n &gt; 50) &#123; return 'Not supported'; &#125; return fibonacci($n - 1) + fibonacci($n - 2);&#125; 不要添加不必要的上下文如果你的类/对象已经说明了一些信息,不要在你的变量名和属性里重复 Bad: 12345678class Car&#123; public $carMake; public $carModel; public $carColor; //...&#125; Good: 12345678class Car&#123; public $make; public $model; public $color; //...&#125; 参数初始化时设置默认值12345function create($name = null)&#123; $newName = $name ?: 'ABC'; // ...&#125; 设置默认值一个比较明显的好处是，当对一个较早之前已经定义好的函数添加参数时,将新增的参数设置默认值可以省得去修改以前使用该函数的地方。 参考链接","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://www.tenpercent.top/tags/代码简洁/"}]},{"title":"通俗易懂的谈谈装饰器模式","date":"2017-09-16T16:00:00.000Z","path":"2017/09/17/Decorator-Pattern/","text":"前言在编码的时候，我们为了扩展一个类经常是使用继承方式来实现，随着扩展功能的增多，子类会越来越膨胀，使系统变得不灵活。 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。它能让我们在扩展类的时候让系统较好的保持灵活性。 那么装饰器模式具体是什么样的呢？ 从一个情景开始我们有一块地，在这块地上，我们要盖一栋有好几间房间的别墅，每间房间的装修费用都不同，现在，我们要对盖别墅的费用进行计算。 先定义一个Land类，表示这块地，Land类定义了在这块地上盖别墅需要花钱这个规则。 1234abstract class Land&#123; abstract function cost();&#125; Land已经定义好了在这块地上盖房需要花钱的这个规则了，但是盖一间房间具体花多少钱呢？此时我们再定义一个Room类，这个类具体的定义了一个房间建造的基本费用（一个最简单房间，里面啥也没有的）。 12345678class Room extends Land&#123; private $money = 1000; public function cost() &#123; return $this-&gt;money; &#125;&#125; 然后开始建造房间，我们建了两个房间，分别是客厅和餐厅，用LivingRoom类和DiningRoom类来表示 12345678910111213141516class LivingRoom extends Room&#123; public function cost() &#123; return parent::cost()+200; //客厅的建造费用在房屋建造费用的基础上多200，比如要买沙发，电视 &#125; &#125;class DiningRoom extends Room&#123; public function cost() &#123; return parent::cost()+100; //餐厅的建造费用在房屋建造费用的基础上多100，比如买餐桌 &#125;&#125; 现在，我们很容易就能得到建造一间客厅所需的花费 12$livingRoomCost = new LivingRoom();echo $livingRoomCost-&gt;cost(); 问题的产生不过，这样的结构并不具备灵活性，虽然我们可以很容易的分别得出建造一间客厅和建造一间餐厅的费用，但是，如果我买的地比较小，只能把餐厅和客厅建在同一个房间里，那要怎么去计算费用？难道还要很麻烦的去创建一个包含客厅和餐厅的LivingDiningRoom类？这样做的话除了麻烦，还会使代码产生重复。 解决问题为了更好的解决这个问题，我们得做一些调整，同样先声明Land类和Room类，不同的是，引入了一个房间的装饰类RoomDecorator，它继承了Land类，因为没有实现Land类的cost()方法，所以需将它声明为抽象类，并且定义了一个以Land类的对象为参数的构造方法，传入的对象会保存在$land属性中，该属性声明为protected，以便子类访问。具体如下。 12345678abstract class RoomDecorator extends Land&#123; protected $land; public function __construct(Land $land) &#123; $this-&gt;land = $land; &#125;&#125; 然后我们再重新定义客厅类和餐厅类 12345678910111213141516class LivingRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+200; &#125;&#125;class DiningRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+100; &#125;&#125; 这两个类都扩展自RoomDecorator类，这意味着它们都拥有指向Land对象的引用。当它们的cost()方法被调用时，都会先调用所引用的Land类对象的cost()方法，然后再执行自己特有的操作。 所以这时候，建造一间客厅所需的费用是这样计算 12$livingRoomCost = new LivingRoom(new Room());echo $livingRoomCost-&gt;cost(); //输出1200 建造一间餐厅所需的费用是这样计算 12$diningRoomCost = new DiningRoom(new Room());echo $diningRoomCost-&gt;cost(); //输出1100 回到刚才的问题，如果我们需计算建造一间包含客厅餐厅的房间所需费用，代码如下 12$livingRoom = new DiningRoom(new LivingRoom(new Room()));echo $livingRoom-&gt;cost(); //输出1300 看，我们现在计算建造费用的思路是：计算出基础房间的费用 –&gt; 在基础房间上装饰成客厅的费用 –&gt; 在客厅的基础上加装饰餐厅的费用 –&gt; 得到包含客厅餐厅的房间费用。已经不需要麻烦的通过创建一个LivingDiningRoom类来计算包含客厅餐厅的房间建造费用了。 这便是装饰模式，通过一层一层的装饰，我们可以灵活的得到我们想要的结果。可以轻松的添加新的装饰器类或者新的组件来创建灵活的结构。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpabstract class Land&#123; abstract function cost();&#125;class Room extends Land&#123; private $money = 1000; public function cost() &#123; return $this-&gt;money; &#125;&#125;//装饰器abstract class RoomDecorator extends Land&#123; protected $land; public function __construct(Land $land) &#123; $this-&gt;land = $land; &#125;&#125;class LivingRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+200; &#125;&#125;class DiningRoom extends RoomDecorator&#123; public function cost() &#123; return $this-&gt;land-&gt;cost()+100; &#125;&#125;$livingRoomCost = new LivingRoom(new Room());echo $livingRoomCost-&gt;cost(); //输出1200$diningRoomCost = new DiningRoom(new Room());echo $diningRoomCost-&gt;cost(); //输出1100$livingDining = new DiningRoom(new LivingRoom(new Room()));echo $livingDining-&gt;cost(); //输出1300 the end. happy coding! ^_^","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"外观模式的总结","date":"2017-09-09T16:00:00.000Z","path":"2017/09/10/Facade-pattern/","text":"前言外观模式(Facade Pattern)是一个比较简单的概念，它只是为一个子系统创建一个单一的入口。这样的好处是有助于分离项目中不同的部分，其次，会使得我们在访问代码时变得简洁方便。另外，由于只在一个地方调用子系统，减少了出错的可能性。 外观模式比较简单，这里就不做过多的赘述了，主要是要吸收该模式减少耦合的思想，直接上代码。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass SystemA&#123; public function operationA() &#123; echo \"operationA &lt;br&gt;\"; &#125;&#125;class SystemB&#123; public function operationB() &#123; echo \"operationB &lt;br&gt;\"; &#125;&#125;class SystemC&#123; public function operationC() &#123; echo \"operationC &lt;br&gt;\"; &#125;&#125;class Facade&#123; protected $systemA; protected $systemB; protected $systemC; function __construct() &#123; $this-&gt;systemA = new SystemA(); $this-&gt;systemB = new SystemB(); $this-&gt;systemC = new SystemC(); &#125; public function myOperation() &#123; $this-&gt;systemA-&gt;operationA(); $this-&gt;systemB-&gt;operationB(); $this-&gt;systemC-&gt;operationC(); &#125;&#125;$facade = new Facade();$facade-&gt;myOperation();//只通过一个入口调用 总结使用外观模式最大的优点就是子系统与客户端之间是松耦合的关系，客户端不必知道具体有哪些子系统，也无需知道他们是如何工作的，通过引入一个外观类，提供一个客户端间接访问子系统的高级接口。子系统和外观类可以独立运作，修改某一个子系统的内容，不会影响到其他子系统，也不会影响到外观对象。 不过它的缺点就是它不够灵活，当需要增加一个子系统的时候，需要修改外观类。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"使用 Vagrant 并搭建 LNMP 环境","date":"2017-09-02T16:00:00.000Z","path":"2017/09/03/use-vagrant/","text":"Vagrant介绍 Vagrant 是一个自动化构建虚拟机环境的工具，可以自动化虚拟机的安装和配置流程。 在团队开发的情况下，我们常常需要在多台机器间同步开发时，有的同事用的 wamp ,有的同事是用的 xampp ，可能在某些配置上的些许不同会导致些许不同或者bug，通过使用 Vagrant ，我们只需要同步 Vagrantfile ，就可以保证各台机器拥有一致的开发环境。也可以通过打包好一个Vagrant box ,供团队的同事使用，这样就能最大程度的保证开发环境一致，避免出现一些没必要的问题从而浪费精力去解决。 安装 Vagrant1、安装 VirtualBox ,具体安装包直接从官网下载（要下载顺畅的话需翻墙）：https://www.virtualbox.org/wiki/Downloads 2、安装 Vagrant，下载地址：https://releases.hashicorp.com/vagrant/ 3、下载box镜像，这里我是下载的Ubuntu的box,可以到这个网址上去查找想下载的box：https://app.vagrantup.com/boxes/search 切换到自己的文件夹下，初始化vagrant环境，生成一个vagrantfile文件，命令如下： 用 vagrant 命令加 box 1$ vagrant box add testUbuntu ~/Downloads/ubuntu-14.04-amd64.box 初始化虚拟机 1$ vagrant init testUbuntu 启动虚拟机 1$ vagrant up 进入虚拟机的 Ubuntu 系统 1$ vagrant ssh 接下来还要对虚拟机进行一些配置。 打开 vagrantfile 文件进行配置，我的配置如下： 到这里，利用 vagrant 搭建虚拟机环境就基本完成了。 vagrant 常用命令 123456789vagrant box add 添加box，自动帮你生成vagrantfilevagrant init 初始化vagrantfilevagrant halt 关闭虚拟机vagrant destroy 销毁虚拟机vagrant ssh 连接虚拟机vagrant reload 重新加载vagarntfile文件vagrant suspend 暂时挂起虚拟机vagrant status 查看虚拟机运行状态vagrant package --output 打包导出box 搭建 LNMP 环境使用 vagrant ssh 登录到虚拟机的 Linux 系统上，就可以开始搭建 LNMP 的环境了。 在安装软件之前，需要对 Ubuntu 系统的镜像源文件 source.list 进行修改一下，可以在网上找一下网易的镜像源或者是阿里搜狐等的镜像源，然后写入 source.list 文件夹里（对源文件先进行下备份）。修改完之后还要运行一下 apt-get update 命令来更新一下镜像源。 安装 Nginx使用apt-get install nginx便可以安装nginx。非常简单。安转完之后，可以使用 curl -I &#39;127.0.0.1&#39;访问一下，看看是否安装成功。 安装 MySQL使用 apt-get install mysql-server mysql-cli 安装MySQL的服务端可客户端，安装的时候需要设置一下密码。安装完之后，通过命令 mysql -uroot -ppassword 命令来登录数据库。 安装PHP 7.0在这里，我使用 Ubuntu 的 PPA 源来安装 PHP 7.0。 先介绍一下 PPA源 PPA 全称为 Personal Package（个人软件包档案），是 Ubuntu Launchpad 网站提供的一项服务，当然不仅限于 Launchpad 。它允许个人用户上传软件源代码，通过 Launchpad 进行编译并发布为二进制软件包，作为 apt/新立得源供其他用户下载和更新。在Launchpad网站上的每一个用户和团队都可以拥有一个或多个PPA。通常 PPA 源里的软件是官方源里没有的，或者是最新版本的软件。相对于通过 Deb 包安装来说，使用 PPA 的好处是，一旦软件有更新，通过 sudo apt-get upgrade 这样命令就可以直接升级到新版本。 如何通过 PPA 源来安装软件： 我们可以通过 Google 来搜索一些常用软件的 PPA 源，通常的搜索方法是软件名称关键字 + PPA ，或者也可直接到 launchpad.net 上去搜索，搜索到后我们就可以直接用 sudo apt-add-repository 命令把 PPA 源添加到 Source list 中了。比如 FireFox PPA 源：https://launchpad.net/~ubuntu-mozilla-daily/+archive/ppa ，我们可以在这里找到 ppa:ubuntu-mozilla-daily/ppa 的字样，然后我们通过以下命令把这个源加入到 source list 中。 sudo apt-add-repository ppa:ubuntu-mozilla-daily/ppa 开始安装 PHP 7.0 第一次使用PPA时，需要先安装一下 python-software-properties 和 software-properties-common apt-get install python-software-properties software-properties-common 然后便可以开始安装PHP 7.0 了 123$ add-apt-repository ppa:ondrej/php$ apt-get update 安装PHP的一些扩展 $ apt-get install php7.0-fpm php7.0-mysql php7.0-common php7.0-curl php7.0-cli php7.0-mbstring php7.0-dom 打开 php.ini进行配置 vim /etc/php/7.0/fpm/php.ini 将cgi.fixpathinfo=1 改成cgi.fixpathinfo=0,这个配置是为了避免 nginx 产生某个漏洞。具体参考鸟哥的文章http://www.laruence.com/2010/05/20/1495.html cgi.fix_pathinfo=0 然后重启一下 php-fpm 服务。 到这里就成功搭建好了 LNMP环境了。 happy codding ! ^_^","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.tenpercent.top/tags/Linux/"},{"name":"Vagrant","slug":"Vagrant","permalink":"http://www.tenpercent.top/tags/Vagrant/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://www.tenpercent.top/tags/虚拟机/"}]},{"title":"PSR编程规范摘录","date":"2017-08-26T16:00:00.000Z","path":"2017/08/27/PSR-reference/","text":"这篇文章记录一下PHP的编程代码规范，做一个规范的PHPer。 PSR：即PHP Standards recommendation(PHP推荐标准)。 PSR-1:基本的代码风格 PHP标签： PHP标签只使用&lt;?php ?&gt;和&lt;?= ?&gt;，不得使用其他PHP标签句法。 编码： PHP所有文件都必须使用UTF-8字符集编码。 目的： 一个PHP文件可以定义符号（类、性状、函数和常量），或者执行有副作用的操作（例如，生成结果或处理数据），但是不能同时做这两件事。 自动加载： PHP命名空间和类必须遵守PSR-4自动加载器标准。 类的名称： PHP类的名称必须使用CamelCase这种驼峰式。 常量的名称：PHP常量的名称必须全部使用大写字母。如果需要，可以使用下划线把单词分开。例如：THIS_VARIABLE 方法的命名： PHP方法的名称必须使用camelCase这种驼峰式，首字母是小写的，后续的所有单词的首字母都是大写的。如：phpIsAwesome PSR-2:严格的代码风格PSR-2是在PSR-1的基础上进一步的要求。 缩进 PSR-2推荐的规范要求是使用4个空格缩进（因为空格最可靠，在不同的代码编辑器中渲染的效果基本一致） 文件和代码 PHP文件的最后一行要有一个空行，而且不能使用PHP关闭标签?&gt;，每行末尾都不能有空格。（这些要求大多数编辑器能帮你做好） 注：PHP文件不写关闭标签的目的是能避免意料之外的输出错误。如果加上关闭标签?&gt;，而且在关闭标签后有空行。那么这个空行会被当成输出导致错误。（例如，设定HTTP头部时） 关键字 对于ture,false和null,PSR-2推荐这些关键字都要使用小写字母的形式。 命名空间 每个命名空间声明语句后面必须跟着一个空行。使用use关键字导入命名空间时，在一系列的use声明语句后要加一个空行。 类 PSR-2推荐类定义体的起始括号应该在类名之后新起一行写。如下代码所示： 1234567&lt;?phpclass example &#123; //类的定义&#125; 方法 （直接代码示例如下） 12345678910&lt;?phpnamespace Animals //注意这里的命名空间首字母需要大写class example&#123; public function test($params = 1, $params = 'two')//注意这里起始括号和结束括号两边都没有空格 &#123; //方法的定义 &#125;&#125; 可见性 类中的每个属性和方法都要声明可见性。abstract和final这俩关键字要放在可见性关键字前面。static关键字要放在可见性关键字后面。代码如下 12345678910class example&#123; public static $number = 0; public function __construct() &#123; static::$number++; &#125;&#125; 控制结构 控制结构中如if else switch foreach等这些关键字后面都要有一个空格。示例代码如下 12345&lt;?phpif (a == b)&#123; //注意这里的花括号不用新起一行 &#125; 虽然现在有挺多的编辑器支持根据PSR-1和PSR-2来格式化代码了，不过这些写代码中的规范还是需要记住一下，尽量让自己的代码风格规范一些，这样在日常的工作中也方便团队交流。 PSR-3：日志记录器接口PSR-3与前面得规范不同，它是一个接口，规定PHP日志记录器组件可以实现得方法。 大多数PHP框架都在某种程度上实现了日志功能。为了实现互操作性和专业化，PHP-FIG制定了PSR-3日志记录器接口。若想使用符合PSR-3规范得日志记录器，框架要做到两件重要得事：日志功能委托给第三方库实现；最终用户能选择使用他们喜欢得日志记录器组件。 编写PSR-3日志记录器符合PSR-3推荐规范的PHP日志记录器组件，必须包含一个实现Psr\\Log|LoggerInterface接口得PHP类。PSR-3接口复用了系统日志协议，规定要实现以下九个方法： 123456789101112131415&lt;?phpnamespace Psr\\Log;interface LoggerInterface&#123; public function emergency($message,array $context = array()); public function alert($message,array $context = array()); public function critial($message,array $context = array()); public function error($message,array $context = array()); public function warning($message,array $context = array()); public function notice($message,array $context = array()); public function info($message,array $context = array()); public function debug($message,array $context = array()); public function log($level,$message,array $context = array());&#125; 但是，我们现在已经不需要自己去编写一个日志记录器了，因为已经有了Monolog(可访问packagist这个网站查看介绍)这个十分出色的PHP日志记录器组件了，它几乎提供了开发过程中所有需要的功能。 PSR-4：自动加载器PSR-4描述了一个标准的自动加载器策略。自动加载器策略是指，在运行时按需查找PHP类、接口或者性状，并将其载入PHP解释器。支持PSR-4自动加载器标准的PHP组件和框架，使用同一个自动加载器就能找到相关代码 在PHP-FIG发布PSR-4推荐规范之前，PHP组件和框架的作者使用__autoload()和spl_autoload_register()函数注册自定义的自动加载器策略。可是，每个PHP组件和框架都使用独特的自动加载器，而且每个加载器使用不同的逻辑查找并加载PHP类、性状和接口。使用这些组件和框架的开发者，在引导PHP应用时必须调用每个组件各自的自动加载器时必须调用每个组件各自的自动加载器。这样在开发中很麻烦。 如今，得益于PSR-4，我们只需要使用一个自动加载器就能自动加载应用中的所有PHP组件。大多数现代的PHP组件和框架都符合PSR-4规范。 PSR自动加载策略PSR-4自动加载策略依赖PHP命名空间和文件系统目录结构查找并加载PHP类、接口，性状。 它的精髓是把命名空间的前缀和文件系统中的目录对应起来。例如，\\Oreilly\\ModernPHP\\Chapter1命名空间对应与src/chapter1目录，\\Oreilly\\ModernPHP\\Chapter1\\Example类对应于src/Chapter1/Example。 实现一个PSR-4自动加载器123456789101112131415161718192021222324252627282930313233343536&lt;?php/*** 该代码中，使用SPL注册这个自动加载函数后，遇到下述代码时，这个函数会* 自动尝试从/path/to/project/src/Baz/Qux.php文件中加载* \\Foo\\Bar\\Baz\\Quz类：* new \\Foo\\Bar\\Baz\\Qux;* */spl_autpload_register(function ($class))&#123; //这个项目的命名空间前缀 $prefix = 'Foo\\\\Bar\\\\'; //这个命名空间对应的根目录； $base_url = __DIR__.'/src/'; //参数传入的类使用这个命名空间前缀吗？ $len = strlen($prefix); if(strncmp($prefix, $class, $len) !==0)&#123; //不使用，交给注册的下一个自动加载器处理 return; &#125; //获取去掉前缀后的类名 $relative_class = substr($class, $len); //把命名空间前缀替换成根目录， //去掉前缀的类命中，把命名空间分隔符替换成目录分隔符， //然后再后面加上.php $file = $base_dir.str_replace('\\\\', '/', $relative_class).'.php'; //如果文件存在，将其导入 if(file_exists($file))&#123; require $file; &#125;&#125; 以上代码是一个PSR-4自动加载器的逻辑。不过在现在，我们也无须自己编写一个PSR-4自动加载器了，因为我们可以使用依赖管理器Composer自动生成PSR-4自动加载器。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"PSR","slug":"PSR","permalink":"http://www.tenpercent.top/tags/PSR/"}]},{"title":"记一个问题的解决：Can't connect to MySQL server on 'x.x.x.x' (61)","date":"2017-08-19T16:00:00.000Z","path":"2017/08/20/ubuntu-mysql/","text":"最近在电脑上安装了虚拟机并且使用vagrant配置了基于Ubuntu的LAMP环境，然后在使用本地主机的MySQL客户端连接虚拟机的MySQL时却出现了问题，Google了一圈解决了问题，在此记录下。 遇到的问题是这样Sequel软件提示”Can’t connect to MySQL servet on ‘x.x.x.x’ (61)”错误 搜了一下，找到了这个答案 即Linux系统里的MySQL是默认监听127.0.0.1的，也就是说，只有在这个Linux本身才能访问到。 运行了下netstat -tulpen这个命令，该命令可以查看端口的监听情况，如下图。 这里可以看到3306的端口是绑定着127.0.0.1的。 要更改这个端口绑定，需要修改/etc/mysql/my.cnf 这个MySQL配置文件。 注意：MySQL 7.0以上版本得，该配置文件得路径是/etc/mysql/mysql.conf.d/mysqld.cnf 这个地址 在my.cnf文件中找到 bind-address = 127.0.0.1 这一行，然后将127.0.0.1改成 0.0.0.0 ，0.0.0.0的意思就是指任何ip地址。 修改之后重启一下MySQL，这时我们再看一下端口绑定情况就可以看到3306这个端口已经绑定成0.0.0.0了。 但是，还没有大功告成在本地主机再次尝试连接MySQL，却出现“Host ‘192.168.100.100’ is not allowed to connect to this MySQL server” 这个问题是在本地主机使用的登录账户不被允许远程登录到虚拟机的Linux上。可以先看一下虚拟机里Linux的MySQL用户情况 运行以下命令可以看到： 这里的登录账户都是在localhost的。 所以我们需要手动添加一个可以远程访问的账户。 添加的方法如下： 添加用户root使用password从任何主机连接到MySQL服务器的话。语句如下： GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION; 添加用户root从ip为192.168.1.1的主机连接到mysql服务器，并使用password作为密码 GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;192.168.1.1&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION; 添加用户root从ip为192.168.1.1的主机连接到mysql服务器的dk数据库，并使用password作为密码 GRANT ALL PRIVILEGES ON dk.* TO &#39;root&#39;@&#39;192.168.1.1&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION; 这里我使用的是第一条语句，执行完之后，再查看MySQL的用户情况就可以看到多出了一个root账户，并且其主机ip是任意的。 到这里，就可以在本地主机的MySQL客户端上愉快的访问到虚拟机里的MySQL啦！！ 后记： 最近折腾了一下vagrant配置虚拟机上的开发环境（具体过程后续会再写一篇文章），又配了一遍LAMP的环境，对Linux的系统更加熟悉了一点。虽然期间会被各种问题卡住，不过解决了问题之后，就会又多懂了一些知识。感觉收获满满，哈哈。^_^ 生命的乐趣还是在于折腾呀！！","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.tenpercent.top/tags/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://www.tenpercent.top/tags/Ubuntu/"}]},{"title":"现代化PHP的标准","date":"2017-08-12T16:00:00.000Z","path":"2017/08/13/php-standard/","text":"在今天，PHP组件和框架的数量很多，可以说是多如牛毛。PHP生态系统是个名副其实的大熔炉，有各种各样的代码，帮助开发者构建强大的应用。为了使这些不同的组件代码、框架能互相通信，共享代码，就诞生了PHP-FIG这个组织，PHP-FIG制定了推荐规范，PHP框架可以自愿实现这些规范，改进与其他框架的通信和共享功能。如今的很多受欢迎的大型PHP框架通常都会实现定案的PHP-FIG推荐规范。 PHP-FIG的使命是实现框架的互操作性。框架的互操作性是指，通过接口、自动加载机制和标准的风格，让框架互相操作。 接口PHP框架之间通过共用的接口合作。框架通过PHP接口假定第三方依赖提供了什么方法，而不关心依赖是如何实现接口的。 例如：假如第三方日志记录器对象实现了alert()，critical()，error()，warning()和debug()等方法，那么框架就可以放心的使用这个记录器对象。至于这些方法是如何实现的无关紧要，框架只关心第三方依赖是否实现了这些方法。 PHP开发者使用接口可以开发、共享并使用专门的组件，而无需使用庞大的框架。 自动加载PHP框架之间通过自动加载机制合作。自动加载是指，PHP解释器在运行时按需自动找到并加载PHP类的过程。 在这些PHP标准出现之前，PHP组件和框架会使用模式方法__autoload（）或最新的spl_autoload_register()方法实现各自特有的自动加载器。因此，我们要学习使用每一个组件和框架各自特有的自动加载器。而如今，多数现代的PHP组件和框架都符合同一个自动加载器标准。这意味着，我们只需使用一个自动加载器就能混合搭配多个PHP组件。 风格PHP框架之间通过标准的代码风格合作。代码风格是指如何使用空格、大小写和括号的位置（等待）。如果PHP框架都使用标准的代码风格，那么每次使用新PHP框架时，PHP开发者已经对框架所用的风格就很熟悉了，就不用适应新的风格。标准的代码风格还能降低项目新贡献者的门槛，让新贡献者把更多的时间用在解决缺陷上，而不用花太多时间学习不熟悉的风格。 标准的代码风格对我们自己的项目也有好处。每个开发者都有一些独特的风格，如果多为开发者在同一个代码基中工作，就会显露问题。使用标准的代码风格，不管作者是谁，团队中的所有成员都能立即理解代码基。 关于代码风格的规范，PHP-FIG退出了PSR，即PHP Standard Recommendation（PHP推荐标准）的简称。它包括PSR-1，PSR-2，PSR-3，PSR-4四个规范，现代的PHP框架基本都会遵守这些规范，这些个规范的具体详细内容就等下一篇总结再介绍吧。今天就先写到这里。 ^_^ happy coding!","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"PHP标准","slug":"PHP标准","permalink":"http://www.tenpercent.top/tags/PHP标准/"}]},{"title":"关于三种工厂模式的总结","date":"2017-07-09T16:00:00.000Z","path":"2017/07/10/factory-pattern/","text":"工厂模式分为简单工厂模式，工厂方法模式和抽象工厂模式，它们都属于设计模式中的创建型模式。其主要功能都是帮助我们把对象的实例化部分抽取了出来，目的是降低系统中代码耦合度，并且增强了系统的扩展性。本文对这三种模式进行了介绍并且分析它们之间的区别。 简单工厂模式简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码逻辑将会非常复杂。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php//简单工厂方法interface People&#123; public function say();&#125;class Man implements People&#123; public function say() &#123; echo 'this is a man '; &#125;&#125;class Women implements People&#123; public function say() &#123; echo 'this is a women'; &#125;&#125;class SimpleFactory&#123; public static function create($name) &#123; if ($name == 'man') &#123; return new Man(); &#125; elseif ($name == 'women') &#123; return new Women(); &#125; &#125; &#125;//具体调用$man = SimpleFactory::create('man');$man-&gt;say();$women = SimpleFactory::create('women');$women-&gt;say(); 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。 工厂方法模式此模式中，通过定义一个抽象的核心工厂类，并定义创建产品对象的接口，创建具体产品实例的工作延迟到其工厂子类去完成。这样做的好处是核心类只关注工厂类的接口定义，而具体的产品实例交给具体的工厂子类去创建。当系统需要新增一个产品是，无需修改现有系统代码，只需要添加一个具体产品类和其对应的工厂子类，使系统的扩展性变得很好，符合面向对象编程的开闭原则。体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php//工厂方法模式interface People&#123; public function say();&#125;class Man implements People&#123; public function say() &#123; echo 'this is a man'; &#125;&#125;class Women implements People&#123; public function say() &#123; echo 'this is a women'; &#125;&#125;//与简单工厂模式相比。区别在于，此处将对象的创建抽象成一个接口interface CreatePeople&#123; public function create();&#125;class FactoryMan implements CreatePeople&#123; public function create() &#123; return new Man(); &#125;&#125;class FactoryWomen implements CreatePeople&#123; public function create() &#123; return new Women(); &#125;&#125;class Client&#123; // 具体生产对象并执行对象方法测试 public function test() &#123; $factory = new FactoryMan(); $man = $factory-&gt;create(); $man-&gt;say(); $factory = new FactoryWomen(); $man = $factory-&gt;create(); $man-&gt;say(); &#125;&#125;// 执行$demo = new Client();$demo-&gt;test(); 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 此模式是对工厂方法模式的进一步扩展。在工厂方法模式中，一个具体的工厂负责生产一类具体的产品，即一对一的关系，但是，如果需要一个具体的工厂生产多种产品对象，那么就需要用到抽象工厂模式了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php interface TV&#123; public function open(); public function watch();&#125;class HaierTv implements TV&#123; public function open() &#123; echo \"Open Haier TV &lt;br&gt;\"; &#125; public function watch() &#123; echo \"I'm watching TV &lt;br&gt;\"; &#125;&#125;interface PC&#123; public function work(); public function play();&#125;class LenovoPc implements PC&#123; public function work() &#123; echo \"I'm working on a Lenovo computer &lt;br&gt;\"; &#125; public function play() &#123; echo \"Lenovo computers can be used to play games &lt;br&gt;\"; &#125;&#125;abstract class Factory&#123; abstract public static function createPc(); abstract public static function createTv();&#125;class ProductFactory extends Factory&#123; public static function createTV() &#123; return new HaierTv(); &#125; public static function createPc() &#123; return new LenovoPc(); &#125;&#125;$newTv = ProductFactory::createTV();$newTv-&gt;open();$newTv-&gt;watch();$newPc = ProductFactory::createPc();$newPc-&gt;work();$newPc-&gt;play(); 在上面的Factory抽象类中，定义了两个抽象方法，这两个抽象方法分别用来生产不同的产品（即由不同类实例化的对象）。 工厂方法模式和抽象工厂模式对比通过以上代码：我们来对比一下工厂方法模式和抽象工厂模式： 工厂方法模式中 当我需要多生产一种新的产品，比如factoryKid这个产品，我需要专门再设一个factoryKid的工厂，即添加如下代码： 1234567891011121314class Kid implements People&#123; public function say() &#123; echo 'this is a kid'; &#125;&#125;class FactoryKid implements CreatePeople&#123; public function create() &#123; return new Kid(); &#125;&#125; 抽象工厂模式中 同样当我需要多生产一种新的产品，比如生产一个iphone,此时我需要修改工厂父类里的接口，并且在具体工厂类ProductFactory这个工厂里增加一条createPhone生产线(即类里面的方法)，所需添加的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041interface Phone&#123; public function work(); public function sms();&#125;class IPhone implements Phone&#123; public function work() &#123; echo \"I'm iphone &lt;br&gt;\"; &#125; public function sms() &#123; echo \"this is an iphone &lt;br&gt;\"; &#125;&#125;//在原来的抽象工厂类中添加方法声明abstract class Factory&#123; abstract public static function createPc(); abstract public static function createTv(); abstract public static function createPhone();&#125;//在原来的工厂类里添加一个方法class ProductFactory extends Factory&#123; public static function createTV() &#123; return new HaierTv(); &#125; public static function createPc() &#123; return new LenovoPc(); &#125; public static function createPhone() &#123; return new IPhone(); &#125;&#125; 从上面的分析可以看出，要生产一个新的产品，抽象工厂模式并不比工厂方法模式更为便捷，那么抽象工厂模式的好处在哪呢?它优点就是在于是增加固定类型产品的不同具体工厂比较方便，比如我要增加一个生产同样类型产品的具体工厂Product2Factory，那么就再建一个Product2Factory类继承Factory就可以了。 最后的最后，总结一下工厂方法模式和抽象工厂模式的核心区别 工厂方法模式利用继承，抽象工厂模式利用组合 工厂方法模式产生一个对象，抽象工厂模式产生一族对象 工厂方法模式利用子类创造对象，抽象工厂模式利用接口的实现创造对象","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"PHP单例模式的总结","date":"2017-06-19T16:00:00.000Z","path":"2017/06/20/Singleton-Pattern/","text":"什么是单例模式含义单例模式是一种对象的创建模式，它用来确保某一个类只有一个实例，而且自行实例化并向整个系统全局的提供这个实例。 单例模式的特点1、有一个保存类的唯一实例的静态成员变量 2、有一个定义为私有的构造函数，表明这个类是不可能形成实例的，防止出现这个类有多个实例的情况出现（有时也可添加个声明为私有的克隆函数）。 3、提供一个能访问这个实例的声明为公共的静态方法（通常为getInstance方法），用来作为返回唯一实例的引用。 具体实现代码： 1234567891011121314151617181920212223242526272829class Preferences &#123; private $props = array(); private static $instance; private function __construct()&#123; &#125; private function __clone()&#123;&#125;; public static function getInstance()&#123; if(empty(self::$instance))&#123; self::$instance = new Preferences(); &#125; return self::$instance; &#125; public function setProperty($key,$val)&#123; $this-&gt;props[$key] = $val; &#125; public function getProperty($key)&#123; return $this-&gt;props[$key]; &#125; &#125;//调用单例 $pref = Preferences::getInstance(); $pref-&gt;setProperty('name','cjhlfy'); unset($pref); $pref2 = Preferences::getInstance(); echo $pref2-&gt;getProperty('name'); //name的属性值不会丢失,因为实例引用 $instance是静态属性 为什么要用单例模式全局变量是面向对象程序员遇到的引发bug的主要原因之一，这是因为全局变量将捆绑于特定的环境，破坏了封装。如果新的应用程序无法保证一开始就定义了相同的全局变量，那么一个依赖于全局变量的类就无法就无法从一个应用程序中提取出来并应用到新的应用程序中。所以单例模式是一种对于全局变量的改进。 不过，单例模式的使用也有不利的地方，它可能导致很难调试的依赖关系。如果改变一个实例，那么所有使用改单例的类可能都会受到影响。当单例被使用时，依赖便会隐藏在方法内部，而且并不会出现在方法声明里。这使得系统中的依赖关系更难以追踪，因此需要谨慎小心的部署单例类 单例模式应用应用场合1、应用程序与数据库的交互 一个应用中会存在大量的数据库操作，比如通过数据库句柄来连接数据库这一行为，使用单例模式可以避免大量的new操作，因为每一次new操作都会消耗内存资源和系统资源。 2、控制配置信息 如果系统中有有一个类来全局控制某些配置信息，那么使用单例模式就可以很方便实现，并且可以对配置进行统一管理。 以数据库操作为例深入理解12345678910111213141516171819202122232425262728293031323334class DB &#123; private $db; private static $instance; private function __construct()&#123; //进行数据库连接 &#125; private function __clone() &#123; &#125;; public static function getInstance()&#123; if(empty(self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; //数据库查询操作 public function select()&#123; //... &#125; //数据库插入操作 public function insert()&#123; //... &#125;&#125; //数据库编辑操作 public function update()&#123; //... &#125;&#125; //获取数据库单例类实例化之后，便可对数据库进行操作$db = DB::getInstance();$db-&gt;select();$db-&gt;insert();$db-&gt;update(); 单例模式的总结就到这里。 参考：《面向对象、模式与实践》","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.tenpercent.top/tags/设计模式/"}]},{"title":"数据库查询中的exists与in分析比较","date":"2017-06-07T16:00:00.000Z","path":"2017/06/08/about-exists/","text":"最近在用Laravel的ORM写数据库查询时，用到了whereHas的写法，这个写法的背后实现的SQL语句就是select * from `table1` where exists(select * from `table2` where table1.id = table2.table1_id),于是就查清楚了一下exists的用法和特点，在这里记录一下。 exists的用法以下图的两张表关系作为分析： exists表示存在，它常常和子查询配合使用。例如对于上图，写下下面的SQL语句 SELECT FROM `user` WHERE exists (SELECT FROM `order` WHERE user.id = order.user_id) 在这里，exists用于检查查询子查询语句是否会至少返回一行数据，如果有返回数据，则返回值是true，反之是false。 放子查询返回为true时，则外层的查询语句将进行查询，反之，外层查询语句将不进行查询或者查不出任何记录。 因此：上面的SQL所实现的意义在于，搜索出所有下过单的会员。 exists和in的区别和使用场景除了exitst，in的使用也可以实现上面语句的效果。如下： SELECT * FROM `user` WHERE id in (SELECT user_id FROM `order`) 那么，它们之间有什么区别呢。 in()语句只会执行一次，它查出order表中的所有user_id字段并且缓存起来，之后，检查user表的id是否和order表中的user_id相当，如果相等则加入结果期，直到遍历完user的所有记录。用程序来表示如下： 123456789101112131415161718192021222324252627$result = [];$users = \"SELECT * FROM `user`\";$orders = \"SELECT user_id FROM `order`\";for($i = 0;$i &lt; $users.length;$i++)&#123; for($j = 0;$j &lt; $orders.length;$j++)&#123; // 此过程为内存操作，不涉及数据库查询。 if($users[$i].id == $orders[$j].user_id)&#123; $result[] = $users[$i]; break; &#125; &#125;&#125;``` 从上面的程序可以明显的看出，当order表数据很大的时候不适合用in,因为最多会将order表数据全部遍历一遍。如：user表有10000条记录,order表有1000000条记录,那么最多有可能遍历10000*1000000次,这样的话效率就很差了。* 再看exists，它的查询过程类似如下：```php $result = [];$users = \"SELECT * FROM `user`\";for($i=0;$i&lt;$users.length;$i++)&#123; if(exists($users[$i].id))&#123;// 执行SELECT * FROM `order` WHERE user.id = order.user_id $result[] = $users[$i]; &#125;&#125; 显而易见：当order表比user表大很多的时候，使用exists是再恰当不过了，它没有那么多遍历操作,只需要再执行一次查询就行。查询次数的多少完全取决于user表的记录条数。 但是：如果说user表有10000条记录,order表有100条记录,那么exists()还是执行10000次,反而不如使用in()遍历10000*100次,因为in()是在内存里遍历,而exists()需要查询数据库,我们都知道查询数据库所消耗的性能比较大,而操作内存的话会比较快. 因此，可以得出总结： 若外层查询表小于子查询表，则用exists。 若外层查询表(记录条数很多)远大于子查询表，则考虑用in。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.tenpercent.top/tags/MySQL/"}]},{"title":"PHP的匿名函数和闭包","date":"2017-05-23T16:00:00.000Z","path":"2017/05/24/php-closure/","text":"匿名函数匿名函数（Anonymous function），也叫闭包函数（closures），允许临时创建一个没有指定名称的函数，最经常用作回调函数（callback）参数的值。 匿名函数的实现匿名函数是目前是通过Closure类来实现，匿名函数会产生这个类的对象。自PHP 5.4起，这个类带有一些方法，允许在匿名函数创建后对其进行更多的控制。 注意：PHP手册特别说明__invoke()这个魔术方法与匿名函数的实现过程无关。 Closure类如下： 12345678910Closure &#123; /* 方法 */ __construct ( void ) public static Closure bind ( Closure $closure , object $newthis [, mixed $newscope = 'static' ] ) public Closure bindTo ( object $newthis [, mixed $newscope = 'static' ] ) &#125;Closure::__construct — 用于禁止实例化的构造函数Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。 匿名函数例子： 1234$func = function($str)&#123; echo $str;&#125;;$func('hello'); 闭包闭包是指在创建时封装周围状态(如变量)的函数，即使闭包所在的环境的不存在了，闭包中封装的状态依然存在。 闭包的实现将匿名函数放在一个普通函数中（也可以将匿名函数返回），就构成了一个闭包。 1234567function closureFunc()&#123; $func = function()&#123; echo 'hello'; &#125; $func();&#125;closureFunc();//输出:hello 闭包的使用在匿名函数中引入局部变量时需要用到use关键字。这是因为PHP中的变量范围只在它的生效范围中。在匿名函数里并没有对变量进行定义，所以需要使用use关键字 123456789function closureFunc1()&#123; $num = 1; $func = function() use($num)&#123; echo $num; &#125;; $func();&#125;closureFunc2();//输出 闭包返回匿名函数并传参 12345678910function closureFunc2()&#123; $num = 1; $func = function($str) use($num)&#123; echo $num; echo $str; &#125;; return $func;&#125;$func = $closureFunc2();$func('hello');//输出 1 hello","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP手册【4】——类与对象（二）","date":"2017-05-09T16:00:00.000Z","path":"2017/05/10/review-php-04/","text":"Final关键字如果父类中的方法被声明为final,则子类无法继承。如果一个类被声明为final，则不能被继承。 NOTE: 属性不能被定义为final,只有类和方法才能被定义为final. 类型约束类型约束即函数的参数可以指定必须为对象、接口、数组或者callable。如果一个类或接口。类型约束不能用于标量类型如int或string。Trait也不允许。例子如下： 1234567891011121314151617181920212223242526272829303132class MyClass&#123; /** * 测试函数 * 第一个参数必须为 OtherClass 类的一个对象 */ public function test(OtherClass $otherclass)&#123; echo $otherclass-&gt;var; &#125; /** * 另一个测试函数 * 第一个参数必须为数组 */ public function test_array(array $input_array) &#123; print_r($input_array); &#125; /** * 第一个参数必须为递归类型 */ public function test_interface(Traversable $iterator) &#123; echo get_class($iterator); &#125; /** * 第一个参数必须为回调类型 */ public function test_callable(callable $callback, $data) &#123; call_user_func($callback, $data); &#125;&#125; 当函数调用的参数与定义的参数类型不一致时，会抛出一个致命的错误。 后期静态绑定这个目前不知道什么用处，先直接看例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Example #1 self:: 用法&lt;?phpclass A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; self::who(); &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test();?&gt;以上例程会输出：AExample #2 static:: 简单用法&lt;?phpclass A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; static::who(); // 后期静态绑定从这里开始 &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test();?&gt;以上例程会输出：B","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP手册【3】——类与对象（-）","date":"2017-04-22T16:00:00.000Z","path":"2017/04/23/review-php-03/","text":"类与对象构造函数和析构函数 构造函数 具有构造函数的类会在每次创建新对象时先调用此方法，所以适合在使用对象前做一些初始化工作。 Note: 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承。 析构函数 析构函数会在某个对象的所有引用都被删除或者当对象被显式销毁时执行。 访问控制被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其自身访问。例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** * Define MyClass */class MyClass&#123; public $public = 'Public'; protected $protected = 'Protected'; private $private = 'Private'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj = new MyClass();echo $obj-&gt;public; // 这行能被正常执行echo $obj-&gt;protected; // 这行会产生一个致命错误echo $obj-&gt;private; // 这行也会产生一个致命错误$obj-&gt;printHello(); // 输出 Public、Protected 和 Private/** * Define MyClass2 */class MyClass2 extends MyClass&#123; // 可以对 public 和 protected 进行重定义，但 private 而不能 protected $protected = 'Protected2'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj2 = new MyClass2();echo $obj2-&gt;public; // 这行能被正常执行echo $obj2-&gt;private; // 未定义 privateecho $obj2-&gt;protected; // 这行会产生一个致命错误$obj2-&gt;printHello(); // 输出 Public、Protected2 和 Undefined 抽象类定义为抽象的类不能被实例化。如果某个类里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。 继承一个抽象类时，子类必须定义父类中的所有抽象方法；另外这些方法的访问控制必须和父类中一样（或者更为宽松） TraitPHP是单继承语言，trait是为这种单继承语言而准备的一种代码复用机制，Trait使开发人员可以自由的在不同层次结构内独立的类中复用方法。示例如下： 1234567891011121314151617&lt;?phptrait ezcReflectionReturnInfo &#123; function getReturnType() &#123; /*1*/ &#125; function getReturnDescription() &#123; /*2*/ &#125;&#125;class ezcReflectionMethod extends ReflectionMethod &#123; use ezcReflectionReturnInfo; /* ... */&#125;class ezcReflectionFunction extends ReflectionFunction &#123; use ezcReflectionReturnInfo; /* ... */&#125;?&gt; 优先级从基类继承的成员会被trait插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了trait的方法，而trait则覆盖了被继承的方法。例： 1234567891011121314151617&lt;?phptrait HelloWorld &#123; public function sayHello() &#123; echo 'Hello World!'; &#125;&#125;class TheWorldIsNotEnough &#123; use HelloWorld; public function sayHello() &#123; echo 'Hello Universe!'; &#125;&#125;$o = new TheWorldIsNotEnough();$o-&gt;sayHello();?&gt; 以上例程会输出： Hello Universe! 重载重载是指动态的”创建”类属性和方法。是通过魔术方法来实现的。 当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。 属性重载 在给不可访问（或未定义）属性赋值时，__set()会被调用 在读取不可访问（或未定义）属性时，__get()会被调用 当对不可访问（或未定义）属性调用isset()或empty()时，__isset()会被调用 当对不可访问（或未定义）属性调用unset()时，__unset()会被调用 方法重载使用__call()函数和__callStatic()函数 在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"重温PHP手册【2】——变量、常量、函数","date":"2017-04-09T16:00:00.000Z","path":"2017/04/10/review-php-02/","text":"变量变量范围变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的PHP变量只有一个单独的范围。这个单独的范围跨度同样包含了include和require引入的文件。例如： 1234&lt;?php $a = 1; include 'b.php';?&gt; 这里变量$a将会在包含文件b.php中生效。但是，在用户自定义函数中，一个局部函数范围将被引入，任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。例如 123456789&lt;?php $a =1;//全局 function Test() &#123; echo $a; //位于函数内部 &#125; Test()； ?&gt; 这个脚本将不会有任何输出，因为echo语句引用了一个局部版本的变量$a，它并没有被赋值。PHP的全局变量和C语言的有一点点不同，在C语言中，全局变量在函数中自动生效，除非被局部变量覆盖。而PHP中全局变量在函数中使用时必须声明为global。 global关键字例： 1234567891011&lt;？php $a = 1; $b = 2; function sum() &#123; global $a,$b; $b = $a + $b; &#125; sum(); echo $b;?&gt; 以上脚本的输出将是3。 在函数中声明了全局变量 $a 和 $b 之后，对任一变量的所有引用都会指向其全局版本。对于一个函数能够声明的全局变量的最大个数，PHP 没有限制。 在全局范围内访问变量的第二个办法，是用特殊的 PHP 自定义 $GLOBALS 数组。 使用静态变量变量范围的另一个重要特性是静态变量（static variable）。静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不会丢失。例如： 12345678&lt;?php function test() &#123; $a = 0; echo $a; $a++; &#125;?&gt; 该函数没什么用处，因为每次调用时都会将$a的值设为0并输出0。将变量加一的$a++没有作用，因为一旦退出本函数则变量$a就不存在了。要写一个不会丢失本次计数值的技术函数，要将变量$a定义为静态的。如下例子： 12345678&lt;?php function test() &#123; static $a = 0; echo $a; $a++; &#125;?&gt; 现在，变量$a仅在第一次调用test()函数时被初始化，之后每次调用test()函数都会输出$a的值并加一。 静态变量也提供了一种处理递归函数的方法。写递归函数的时候，可能会无穷递归下去。必须确保有充分的方法来终止递归。以下的简单的例子说明使用静态变量来判断何时停止。 12345678910111213&lt;?php function test() &#123; static $count = 0; $count++; echo $count; if($count &lt; 10) &#123; test(); &#125; $count--; &#125;?&gt; 可变变量将变量名再赋予某个变量 可变函数将函数名赋予某个变量，当调用该变量外加括号时，即调用该函数。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"计算机组成","date":"2017-03-21T16:00:00.000Z","path":"2017/03/22/Computer/","text":"冯诺依曼结构的工作原理计算机组成的依据是冯诺依曼结构，它将计算机分为以下五大组成部分： 运算器+控制器（CPU） 存储器（内存） 输入设备 输出设备 数据和指令以二进制形式，不加区别的存放在存储器中。 速度不匹配问题由于CPU的运行速度非常快，与主存储器，磁盘的I/O速度相差非常大（千百倍以上），为了解决这个问题，计算机采用将CPU “忙死” 的方法。对于程序的执行采用以下方案： 同步 =&gt; 异步 即CPU在运行程序时，当某个程序需要它来运行时它才动作，不需要它运行时，CPU去运行别的程序去。 顺序 =&gt; 并发 将多个程序并发执行，CPU在这些程序里进行很快速的切换（由操作系统控制），这样会使人觉得好像每个程序同时运行一样，其实在每个时间点时（极短），CPU只执行一个程序。 增加中间层：缓存 1、当CPU要读取一个数据时，首先从CPU缓存中查找，找到就立刻读取并送给CPU处理；2、没有找到，就从速率相对较慢的内存中读取并送给CPU处理，同时把这个数据所在的数据块调入缓存中，可以使得以后对CPU数据的读取都从缓存中进行，不必在调用内存。 按下电源之后发生了什么 按下电源，主板开始供电 主板向CPU发出RESET信号 当RESET信号撤去后，CPU开始干活，去一个特定的内存地址查找第一条指令（这是一条跳转指令，跳转到系统BIOS中真正的启动代码处） BIOS的代码对系统进行自检：内存，硬盘，显卡..如果硬件出现问题，主板会发出不同含义的蜂鸣，启动终止。如果没有问题，屏幕就会出现CPU、内存、硬盘等信息。 hello world的一生 程序写好了以后，编译成二进制文件（包含机器语言指令），存放在硬盘中。 运行hello world程序，操作系统吧helloworld从硬盘读到内存 CPU开始执行main程序中的机器语言指令 机器语言指令把”helloworld”字符串从内存复制到寄存器 机器语言把寄存器数据复制到显示设备，显示在屏幕上。","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://www.tenpercent.top/tags/计算机基础/"}]},{"title":"重温PHP手册【1】——基础句法和类型","date":"2017-03-10T16:00:00.000Z","path":"2017/03/11/review-php-01/","text":"前言：最近想开始好好提升一下自己的英语水平，因为感觉熟练的英语是每一个优秀软件工程师的基本功，虽然是一枚过了六级的选手，但是感觉英文阅读和写作都还是有些压力。正巧听闻有个PHP高手说他把PHP官方手册读了不下8遍，深以为然，孰能生巧这个道理放在哪里都没有错。所以第一步我打算开始重温PHP手册，在加强自己英语水平的同时来达到温故而知新的目的。 1、PHP tagsWhen PHP parses a file, it look for opening and closing tags, which are &lt;?phpand ?&gt; which tell PHP to start and stop interpreting the code between them.if a file is pure PHP code, it is preferable to omit the PHP closing tag at the end of the file. This prevents accidental whitespace or new lines being added after the PHP closing tag, which may cause unwanted effects because PHP will start output buffering when there is no intention from the programmer to send any output at that point in the script. 12345&lt;?php echo \"hello chenjiehui!\"; //...more code echo \"last statement.\"; // the script ends here with no PHP closing tag 2、Escaping from HTMLEverything outside of a pair of opening and closing tags is ignored by the PHP parser which allows PHP files to have mixed content. This allows PHP to be embedded in HTML documents.But there is one exception that in the middle of a conditional statement in which case the interpreter will determine the outcome of the confitional before making a decision of what to skip over. See the next example. Using structures with conditions. 12345&lt;?php if($expression == true) : ?&gt; This will show if the expression is true.&lt;?php else : ?&gt; Otherwise this will show.&lt;?php endif; ?&gt; In this example PHP will ship the blocks where the condition is not met, even though they are outside of the PHP open/close tags;For outputting large blocks of text, dropping out of PHP parsing mode is generally more effcient than sending all of text through echo or print. Starting with PHP 5.4, short echo tag &lt;?= is always recongnized and vaild, regardless of the short_open_tag setting. 3、CommentsPHP support ‘C’,’C++’ and Unix shell-style(Perl style) comments. For example: 1234567&lt;?php echo 'this is a test'; //this is a one line c++ style comment /* This is a multi line comment yet another line of comment */ echo 'This is yet another test'; echo 'one Final Test'; # This is a one-line shell-style comment?&gt; ##4、typePHP supports eight primitive types(原始数据类型): Four scalar types(标量类型): boolean integer float(aka(又称作) double) string Three compound types: array object callable And finally two special types resource NULL This manual also introduces some pseudo-types(伪类型) for readability reasons： mixed number callback array|object void And the pseudo-variable $…The type of the variable is not usually set by programmer; rather(确切的说), it is decided at runtime by PHP depending on the context in which that variable is used. Note: To check the type and variable of the expression, use the var_dump() function.To get a human-readable representation of a type for debugging, use the gettype() function. To check for a certain type, do not use gettype(), but rather the is_type functions. Some examples: 123456789101112131415&lt;?php $a_bool = TRUE ; $a_str = \"foo\"; $a_str2 = 'foo'; $an_int = 12; echo gettype($a_bool);//print out: boolean echo gettype($a_str);//print out: string if(is_int($an_int))&#123; $an_int+=4; &#125; if (is_string($a_bool)) &#123; echo \"String: $a_bool\"; &#125;?&gt;&gt; To forcibly(强制地) convert a variable to a certain type, either cast(eg: (bool)$a_str) or use the settype() function on it.Note that a variable may be evaluated(被评估) with diffrent values in certain situations, depending on what type it is at the time.","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.tenpercent.top/tags/PHP/"}]},{"title":"操作系统【1】——导论","date":"2017-03-05T16:00:00.000Z","path":"2017/03/06/operating-system-01/","text":"操作系统是管理计算机硬件的程序，它还为应用程序提供基础，并充当计算机硬件和计算机用户的中介。大型机的操作系统设计主要目的是为了充分优化硬件的使用率，个人计算机的操作系统是为了能够支持从复杂游戏到商业应用的各种事物，手持计算机的操作系统是为了给用户一个可以与计算机方便的交互并执行程序的环境。因此，有的操作系统设计是为了方便，有的是为了高效，而有的设计目标则是兼而有之。 本章目标 提供对操作系统主要部件的浏览 提供基本的计算机系统体系结构的概述 1.1 操作系统做什么从计算机的角度来看，操作系统是与硬件最为密切的程序。计算机系统可能有许多资源，用来解决CPU时间、内存时间、文件存储空间、I/O设备等问题。操作系统管理这些资源。面对许多甚至冲突的请求，操作系统必须决定如何为各个程序和用户分配资源，以便计算机系统能够有效而公平的运行。众所周知，资源分配对多用户访问主机或微型计算机特别重要。操作系统是控制程序。控制程序管理用户程序的执行以防止计算机资源的错误使用或使用不当。它特别关注I/O设备的操作和控制。 1.1.1 定义操作系统一个比较公认的定义是，操作系统是一直运行在计算机上的程序（通常称之为内核），其他程序为系统程序和应用程序。 1.2 计算机系统组织1.2.1 计算机系统操作当计算机打开电源或重启时，计算机开始运行，它需要运行一个初始化程序，该初始化程序或引导程序（bootstrap program）比较简单，通常位于ROM或EEPROM中，称为计算机硬件中的固件。它初始化系统中的所有部分，包括CPU寄存器、设备控制器和内存内容。引导程序必须知道如何装入操作系统并开始执行系统。为了完成这一目标，引导程序必须定位操作系统内核并把它转入内存，接着，操作系统孔i是执行第一个进程如init，并等待事件的发生。事件的发生通常通过硬件或软件中断（interrupt）。硬件可随时通过系统总线向CPU发出信号，以触发中断。软件通过执行特别操作如系统调用（system call）也称为监视器调用（monitor call））也能触发中断。 1.2.2 存储结构计算机程序必须在内存（或随机访问内存（random access memory）RAM ）中以便于运行。内存是处理器可以直接访问的唯一的大容量存储区域（数兆到数千兆字节）。它通常是用被称为动态随机访问内存（dynamic random access memory,DRAM）的半导体技术来实现的，是一组内存字的数组，每个字都有其地址。通过对特定内存地址执行一系列load或store指令来实现交互。指令load能将内存中的字转移到CPU的寄存器中，而指令store能将寄存器的内容移到内存。除了显式使用load和store外，CPU可自动从内存中装入指令来执行。 一个典型指令执行周期（在冯诺依曼体系结构上执行时）首先从内存中获取指令，并保存在指令寄存器中。接着，指令被解码，并可能导致从内存中获取操作数或将操作数保存在内部寄存器中。在指令完成对操作数的执行，其结果可以存回到内存。注意内存单元只看见内存地址流，它并不知道它们是如何产生，或者它们是什么地址。相应地，可忽视程序如何产生内存地址，只对程序运行所产生的地址序列感兴趣。 由于内存太小以及内存是易失性存储设备，所以绝大多数计算机需要提供辅存，最常用的辅存设备为磁盘，它能存储程序和数据。绝大多数程序（浏览器，编译器，制表软件等）保存在磁盘上，直到要执行时才装入到内存中。许多程序都是使用磁盘来作为它们所处理信息的来源和目的。因此，适当的管理磁盘存储对计算机系统来说十分重要。 存储设备层次 寄存器 =&gt; 高速缓存 =&gt; 主存 =&gt; 电子磁盘 =&gt; 磁盘 =&gt; 光盘 =&gt; 磁带 1.3 计算机系统体系结构 单处理器系统 绝大多数系统采用单处理器，在单处理器系统中，有一个主CPU能够执行一个通用的指令集，包括来自于用户进程的指令。 多处理器系统 多处理器系统有多个紧密通信的CPU，它们共享计算机总线，有时还有时钟、没存和外设等。多处理器系统主要有三个优点： 1、增加吞吐量：通过增加处理器的数量，希望能够在更短的时间内做更多的事情。用N个处理器的加速比不是N，而是比N小。当多个CPU在同一件事情上时，为了使得各部分能正确工作，会产生一定的额外开销。这些开销，加上对共享资源的竞争，会降低因为增加了CPU的期望增益。这与一组N为程序员在一起紧密地工作，并不能完成N倍的单个程序员的工作量类似。 2、规模经济：多处理器系统比单个处理器系统能节省资金。 3、增加可靠性：如果将功能分布在多个处理器上，那么单个处理器的失灵将不会使得整个系统停止，只会使它变慢。如果有一个处理器出现故障，那么剩下的处理器会分担起故障处理器的那部分工作。 1.3.1 集群系统多CPU系统的另一种类型是集群系统（clustered system）。与多处理器系统一样，集群系统将多个CPU集中起来完成计算任务。然而，集群系统与多处理器系统不同，它是由两个或多个独立的系统耦合起来的。集群系统通常用来提供高可用服务，这意味着即使集群中的一个或多个系统出错，服务仍在运行。 集群分为非对称集群和对称集群 非对称集群 一台机器处于热备份模式（hot standby mode），而另一台运行应用程序。热备份主机只监视活动服务器。如果该服务器失效，那么热备份主机会成为现行服务器 对称集群 两个或者多个主机都运行应用程序，它们互相监视。这种模式因为充分使用了现有硬件，所以更为高效。","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://www.tenpercent.top/tags/计算机基础/"}]}]